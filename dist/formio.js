/*! ng-formio v2.18.4 | https://unpkg.com/ng-formio@2.18.4/LICENSE.txt */
(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
"use strict";
_dereq_('./polyfills/polyfills');


var app = angular.module('formio', [
  'ngSanitize',
  'ui.bootstrap',
  'ui.bootstrap.datetimepicker',
  'ui.select',
  'ui.mask',
  'angularMoment',
  'ngDialog',
  'ngFileUpload',
  'ngFileSaver'
]);

/**
 * Create the formio providers.
 */
app.provider('Formio', _dereq_('./providers/Formio'));

/**
 * Provides a way to register the Formio scope.
 */
app.factory('FormioScope', _dereq_('./factories/FormioScope'));

app.factory('FormioUtils', _dereq_('./factories/FormioUtils'));

app.factory('formioInterceptor', _dereq_('./factories/formioInterceptor'));

app.factory('formioTableView', _dereq_('./factories/formioTableView'));

app.directive('formio', _dereq_('./directives/formio'));

app.directive('formioDelete', _dereq_('./directives/formioDelete'));

app.directive('formioErrors', _dereq_('./directives/formioErrors'));

app.directive('customValidator', _dereq_('./directives/customValidator'));

app.directive('formioSubmissions', _dereq_('./directives/formioSubmissions'));

app.directive('formioSubmission', _dereq_('./directives/formioSubmission'));

app.directive('formioComponent', _dereq_('./directives/formioComponent'));

app.directive('formioComponentView', _dereq_('./directives/formioComponentView'));

app.directive('formioElement', _dereq_('./directives/formioElement'));

app.directive('formioWizard', _dereq_('./directives/formioWizard'));

app.directive('formioBindHtml', _dereq_('./directives/formioBindHtml.js'));

/**
 * Filter to flatten form components.
 */
app.filter('flattenComponents', _dereq_('./filters/flattenComponents'));
app.filter('tableComponents', _dereq_('./filters/tableComponents'));
app.filter('tableView', _dereq_('./filters/tableView'));
app.filter('tableFieldView', _dereq_('./filters/tableFieldView'));
app.filter('safehtml', _dereq_('./filters/safehtml'));
app.filter('formioTranslate', _dereq_('./filters/translate'));
app.filter('trustAsResourceUrl', _dereq_('./filters/trusturl'));
app.config([
  '$httpProvider',
  '$injector',
  function(
    $httpProvider,
    $injector
  ) {
    if (!$httpProvider.defaults.headers.get) {
      $httpProvider.defaults.headers.get = {};
    }

    // Make sure that ngAnimate doesn't mess up loader.
    try {
      $injector.get('$animateProvider').classNameFilter(/^((?!(fa-spinner|glyphicon-spin)).)*$/);
    }
    /* eslint-disable no-empty */
    catch (err) {}
    /* eslint-enable no-empty */

    // Disable IE caching for GET requests.
    $httpProvider.defaults.headers.get['Cache-Control'] = 'no-cache';
    $httpProvider.defaults.headers.get.Pragma = 'no-cache';
    $httpProvider.interceptors.push('formioInterceptor');
  }
]);

app.run([
  '$templateCache',
  '$rootScope',
  '$window',
  function($templateCache, $rootScope, $window) {
    $window.addEventListener('message', function(event) {
      var eventData = null;
      try {
        eventData = JSON.parse(event.data);
      }
      catch (err) {
        eventData = null;
      }
      if (eventData && eventData.name) {
        $rootScope.$broadcast('iframe-' + eventData.name, eventData.data);
      }
    });

    // The template for the formio forms.
    $templateCache.put('formio.html',
      "<div>\r\n  <i style=\"font-size: 2em;\" ng-if=\"formLoading\" ng-class=\"{'formio-hidden': !formLoading}\" class=\"formio-loading glyphicon glyphicon-refresh glyphicon-spin\"></i>\r\n  <formio-wizard ng-if=\"form.display === 'wizard'\" src=\"src\" form=\"form\" submission=\"submission\" form-action=\"formAction\" read-only=\"readOnly\" hide-components=\"hideComponents\" disable-components=\"disableComponents\" formio-options=\"formioOptions\" storage=\"form.name\"></formio-wizard>\r\n  <div ng-if=\"form.display === 'pdf' && form.settings.pdf\" style=\"position:relative;\">\r\n    <span style=\"position:absolute;right:10px;top:10px;cursor:pointer;\" class=\"btn btn-default no-disable\" ng-click=\"zoomIn()\"><spann class=\"glyphicon glyphicon-zoom-in\"></spann></span>\r\n    <span style=\"position:absolute;right:10px;top:60px;cursor:pointer;\" class=\"btn btn-default no-disable\" ng-click=\"zoomOut()\"><span class=\"glyphicon glyphicon-zoom-out\"></span></span>\r\n    <a ng-if=\"downloadUrl\" style=\"position:absolute;right:10px;top:110px;cursor:pointer;\" class=\"btn btn-primary no-disable\" href=\"{{ downloadUrl | trustAsResourceUrl }}\" target=\"_blank\"><span class=\"glyphicon glyphicon-cloud-download\"></span></a>\r\n    <iframe src=\"{{ getIframeSrc(form.settings.pdf) | trustAsResourceUrl }}\" seamless class=\"formio-iframe\"></iframe>\r\n    <button ng-if=\"!readOnly && !form.builder\" type=\"button\" class=\"btn btn-primary\" ng-click=\"submitIFrameForm()\">Submit</button>\r\n  </div>\r\n  <form ng-if=\"!form.display || (form.display === 'form')\" role=\"form\" name=\"formioForm\" ng-submit=\"onSubmit(formioForm)\" novalidate>\r\n    <div ng-repeat=\"alert in formioAlerts track by $index\" class=\"alert alert-{{ alert.type }}\" role=\"alert\" ng-if=\"::!builder\">\r\n      {{ alert.message | formioTranslate:null:builder }}\r\n    </div>\r\n    <!-- DO NOT PUT \"track by $index\" HERE SINCE DYNAMICALLY ADDING/REMOVING COMPONENTS WILL BREAK -->\r\n    <formio-component\r\n      ng-repeat=\"component in form.components track by $index\"\r\n      component=\"component\"\r\n      ng-if=\"builder ? '::true' : isVisible(component)\"\r\n      data=\"submission.data\"\r\n      formio-form=\"formioForm\"\r\n      formio=\"formio\"\r\n      submission=\"submission\"\r\n      hide-components=\"hideComponents\"\r\n      read-only=\"isDisabled(component, submission.data)\"\r\n      builder=\"builder\"\r\n    ></formio-component>\r\n  </form>\r\n</div>\r\n"
    );

    $templateCache.put('formio-wizard.html',
      "<div class=\"formio-wizard-wrapper\">\r\n  <div class=\"row bs-wizard\" style=\"border-bottom:0;\" ng-class=\"{hasTitles: hasTitles}\">\r\n    <div ng-class=\"{disabled: ($index > currentPage) && !formioOptions.wizardFreeNavigation, active: ($index == currentPage), complete: ($index < currentPage), noTitle: !page.title}\" class=\"{{ colclass }} bs-wizard-step\" ng-repeat=\"page in pages track by $index\">\r\n      <div class=\"bs-wizard-stepnum-wrapper\">\r\n        <div class=\"text-center bs-wizard-stepnum\" ng-if=\"page.title\">{{ page.title }}</div>\r\n      </div>\r\n      <div class=\"progress\"><div class=\"progress-bar progress-bar-primary\"></div></div>\r\n      <a ng-click=\"goto($index)\" class=\"bs-wizard-dot bg-primary\"><div class=\"bs-wizard-dot-inner\"\r\n        ng-class=\"{\r\n          'bg-success': !pageHasErrors[$index],\r\n          'bg-danger': pageHasErrors[$index],\r\n          'bg-warning': !pageWasVisited[$index] && currentPage > $index\r\n        }\"></div></a>\r\n    </div>\r\n  </div>\r\n  <style type=\"text/css\">.bs-wizard > .bs-wizard-step:first-child { margin-left: {{ margin }}%; }</style>\r\n  <i ng-show=\"!wizardLoaded\" id=\"formio-loading\" style=\"font-size: 2em;\" class=\"glyphicon glyphicon-refresh glyphicon-spin\"></i>\r\n  <div ng-repeat=\"alert in formioAlerts track by $index\" class=\"alert alert-{{ alert.type }}\" role=\"alert\">{{ alert.message | formioTranslate:null:builder }}</div>\r\n  <div class=\"formio-wizard\">\r\n    <formio\r\n      ng-if=\"wizardLoaded\"\r\n      submission=\"submission\"\r\n      form=\"page\"\r\n      url=\"url\"\r\n      read-only=\"readOnly\"\r\n      hide-components=\"hideComponents\"\r\n      disable-components=\"disableComponents\"\r\n      formio-options=\"formioOptions\"\r\n      id=\"formio-wizard-form\"\r\n    ></formio>\r\n  </div>\r\n  <ul ng-show=\"wizardLoaded\" class=\"list-inline\">\r\n    <li><a class=\"btn btn-default\" ng-click=\"cancel()\">Cancel</a></li>\r\n    <li ng-if=\"currentPage > 0\"><a class=\"btn btn-primary\" ng-click=\"prev()\">Previous</a></li>\r\n    <li ng-if=\"currentPage < (pages.length - 1)\">\r\n      <a class=\"btn btn-primary\" ng-click=\"next()\">Next</a>\r\n    </li>\r\n    <li ng-if=\"currentPage >= (pages.length - 1)\">\r\n      <a class=\"btn btn-primary\" ng-click=\"submit()\">Submit Form</a>\r\n    </li>\r\n  </ul>\r\n</div>\r\n"
    );

    $templateCache.put('formio-delete.html',
      "<form role=\"form\">\r\n  <div ng-repeat=\"alert in formioAlerts track by $index\" class=\"alert alert-{{ alert.type }}\" role=\"alert\">\r\n    {{ alert.message | formioTranslate:null:builder }}\r\n  </div>\r\n  <h3>{{ deleteMessage | formioTranslate:null:builder }}</h3>\r\n  <div class=\"btn-toolbar\">\r\n    <button ng-click=\"onDelete()\" class=\"btn btn-danger\">{{ 'Yes' | formioTranslate:null:builder }}</button>\r\n    <button ng-click=\"onCancel()\" class=\"btn btn-default\">{{ 'No' | formioTranslate:null:builder }}</button>\r\n  </div>\r\n</form>\r\n"
    );

    $templateCache.put('formio/submission.html',
      "<div>\r\n  <div ng-repeat=\"component in form.components track by $index\" ng-if=\"submission && submission.data\">\r\n    <formio-component-view\r\n      form=\"form\"\r\n      component=\"component\"\r\n      data=\"submission.data\"\r\n      ignore=\"ignore\"\r\n      submission=\"submission\"\r\n      ng-if=\"builder ? '::true' : isVisible(component)\"\r\n      builder=\"builder\"\r\n    ></formio-component-view>\r\n  </div>\r\n</div>\r\n"
    );

    $templateCache.put('formio/submissions.html',
      "<div>\r\n  <div ng-repeat=\"alert in formioAlerts track by $index\" class=\"alert alert-{{ alert.type }}\" role=\"alert\">\r\n    {{ alert.message | formioTranslate:null:builder }}\r\n  </div>\r\n  <table class=\"table\">\r\n    <thead>\r\n      <tr>\r\n        <th ng-repeat=\"component in form.components | flattenComponents track by $index\" ng-if=\"tableView(component)\">{{ component.label || component.key }}</th>\r\n        <th>Submitted</th>\r\n        <th>Updated</th>\r\n        <th>Operations</th>\r\n      </tr>\r\n    </thead>\r\n    <tbody>\r\n      <tr ng-repeat=\"submission in submissions track by $index\" class=\"formio-submission\" ng-click=\"$emit('submissionView', submission)\">\r\n        <td ng-repeat=\"component in form.components | flattenComponents track by $index\" ng-if=\"tableView(component)\">{{ submission.data | tableView:component }}</td>\r\n        <td>{{ submission.created | amDateFormat:'l, h:mm:ss a' }}</td>\r\n        <td>{{ submission.modified | amDateFormat:'l, h:mm:ss a' }}</td>\r\n        <td>\r\n          <div class=\"button-group\" style=\"display:flex;\">\r\n            <a ng-click=\"$emit('submissionView', submission); $event.stopPropagation();\" class=\"btn btn-primary btn-xs\"><span class=\"glyphicon glyphicon-eye-open\"></span></a>&nbsp;\r\n            <a ng-click=\"$emit('submissionEdit', submission); $event.stopPropagation();\" class=\"btn btn-default btn-xs\"><span class=\"glyphicon glyphicon-edit\"></span></a>&nbsp;\r\n            <a ng-click=\"$emit('submissionDelete', submission); $event.stopPropagation();\" class=\"btn btn-danger btn-xs\"><span class=\"glyphicon glyphicon-remove-circle\"></span></a>\r\n          </div>\r\n        </td>\r\n      </tr>\r\n    </tbody>\r\n  </table>\r\n  <pagination\r\n    ng-if=\"submissions.serverCount > perPage\"\r\n    ng-model=\"currentPage\"\r\n    ng-change=\"pageChanged(currentPage)\"\r\n    total-items=\"submissions.serverCount\"\r\n    items-per-page=\"perPage\"\r\n    direction-links=\"false\"\r\n    boundary-links=\"true\"\r\n    first-text=\"&laquo;\"\r\n    last-text=\"&raquo;\"\r\n    >\r\n  </pagination>\r\n</div>\r\n"
    );

    // A formio component template.
    $templateCache.put('formio/component.html',
      "<div class=\"form-group form-field-type-{{ component.type }} formio-component-{{ component.key }} {{component.customClass}}\" id=\"form-group-{{ componentId }}\"\r\n     ng-class=\"{'has-feedback ': (component.hideLabel === true || component.label === '' || !component.label) && component.validate.required,\r\n             'has-error': formioForm[componentId].$invalid && !formioForm[componentId].$pristine }\"\r\n     ng-style=\"component.style\"\r\n     ng-hide=\"component.hidden\">\r\n  <formio-element></formio-element>\r\n</div>\r\n\r\n"
    );

    $templateCache.put('formio/component-view.html',
      "<div name=\"{{ componentId }}\" class=\"form-group has-feedback form-field-type-{{ component.type }} {{component.customClass}} formio-component-{{ component.key }}\" id=\"form-group-{{ componentId }}\" ng-style=\"component.style\">\r\n  <formio-element></formio-element>\r\n</div>\r\n"
    );

    $templateCache.put('formio/element-view.html',
      "<div>\r\n  <div ng-if=\"component.label\"><strong>{{ component.label }}</strong></div>\r\n  <div formio-bind-html=\"data | tableView:component\"></div>\r\n</div>\r\n"
    );

    $templateCache.put('formio/errors.html',
      "<div ng-show=\"formioForm[componentId].$error && !formioForm[componentId].$pristine\">\r\n  <p class=\"help-block\" ng-show=\"formioForm[componentId].$error.email\">{{ component.label || component.placeholder || component.key }} {{'must be a valid email' | formioTranslate:null:builder}}.</p>\r\n  <p class=\"help-block\" ng-show=\"formioForm[componentId].$error.required\">{{ component.label || component.placeholder || component.key }} {{'is required' | formioTranslate:null:builder}}.</p>\r\n  <p class=\"help-block\" ng-show=\"formioForm[componentId].$error.number\">{{ component.label || component.placeholder || component.key }} {{'must be a number' | formioTranslate:null:builder}}.</p>\r\n  <p class=\"help-block\" ng-show=\"formioForm[componentId].$error.maxlength\">{{ component.label || component.placeholder || component.key }} {{'must be shorter than' | formioTranslate:null:builder}} {{ component.validate.maxLength + 1 }} {{'characters' | formioTranslate:null:builder}}.</p>\r\n  <p class=\"help-block\" ng-show=\"formioForm[componentId].$error.minlength\">{{ component.label || component.placeholder || component.key }} {{'must be longer than' | formioTranslate:null:builder}} {{ component.validate.minLength - 1 }} {{'characters' | formioTranslate:null:builder}}.</p>\r\n  <p class=\"help-block\" ng-show=\"formioForm[componentId].$error.min\">{{ component.label || component.placeholder || component.key }} {{'must be greater than or equal to' | formioTranslate:null:builder}} {{ component.validate.min }}.</p>\r\n  <p class=\"help-block\" ng-show=\"formioForm[componentId].$error.max\">{{ component.label || component.placeholder || component.key }} {{'must be less than or equal to' | formioTranslate:null:builder}} {{ component.validate.max }}.</p>\r\n  <p class=\"help-block\" ng-show=\"formioForm[componentId].$error.custom\">{{ component.customError | formioTranslate }}</p>\r\n  <p class=\"help-block\" ng-show=\"formioForm[componentId].$error.pattern\">{{ component.label || component.placeholder || component.key }} {{'does not match the pattern' | formioTranslate:null:builder}} {{ component.validate.pattern }}</p>\r\n  <p class=\"help-block\" ng-show=\"formioForm[componentId].$error.day\">{{ component.label || component.placeholder || component.key }} {{'must be a valid date' | formioTranslate:null:builder}}.</p>\r\n</div>\r\n"
    );
  }
]);

_dereq_('./components');

},{"./components":200,"./directives/customValidator":216,"./directives/formio":217,"./directives/formioBindHtml.js":218,"./directives/formioComponent":219,"./directives/formioComponentView":220,"./directives/formioDelete":221,"./directives/formioElement":222,"./directives/formioErrors":223,"./directives/formioSubmission":224,"./directives/formioSubmissions":225,"./directives/formioWizard":226,"./factories/FormioScope":227,"./factories/FormioUtils":228,"./factories/formioInterceptor":230,"./factories/formioTableView":231,"./filters/flattenComponents":232,"./filters/safehtml":233,"./filters/tableComponents":234,"./filters/tableFieldView":235,"./filters/tableView":236,"./filters/translate":237,"./filters/trusturl":238,"./polyfills/polyfills":240,"./providers/Formio":241}],2:[function(_dereq_,module,exports){
/*!
 * EventEmitter2
 * https://github.com/hij1nx/EventEmitter2
 *
 * Copyright (c) 2013 hij1nx
 * Licensed under the MIT license.
 */
;!function(undefined) {

  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {
    return Object.prototype.toString.call(obj) === "[object Array]";
  };
  var defaultMaxListeners = 10;

  function init() {
    this._events = {};
    if (this._conf) {
      configure.call(this, this._conf);
    }
  }

  function configure(conf) {
    if (conf) {
      this._conf = conf;

      conf.delimiter && (this.delimiter = conf.delimiter);
      this._events.maxListeners = conf.maxListeners !== undefined ? conf.maxListeners : defaultMaxListeners;
      conf.wildcard && (this.wildcard = conf.wildcard);
      conf.newListener && (this.newListener = conf.newListener);
      conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);

      if (this.wildcard) {
        this.listenerTree = {};
      }
    } else {
      this._events.maxListeners = defaultMaxListeners;
    }
  }

  function logPossibleMemoryLeak(count, eventName) {
    var errorMsg = '(node) warning: possible EventEmitter memory ' +
        'leak detected. %d listeners added. ' +
        'Use emitter.setMaxListeners() to increase limit.';

    if(this.verboseMemoryLeak){
      errorMsg += ' Event name: %s.';
      console.error(errorMsg, count, eventName);
    } else {
      console.error(errorMsg, count);
    }

    if (console.trace){
      console.trace();
    }
  }

  function EventEmitter(conf) {
    this._events = {};
    this.newListener = false;
    this.verboseMemoryLeak = false;
    configure.call(this, conf);
  }
  EventEmitter.EventEmitter2 = EventEmitter; // backwards compatibility for exporting EventEmitter property

  //
  // Attention, function return type now is array, always !
  // It has zero elements if no any matches found and one or more
  // elements (leafs) if there are matches
  //
  function searchListenerTree(handlers, type, tree, i) {
    if (!tree) {
      return [];
    }
    var listeners=[], leaf, len, branch, xTree, xxTree, isolatedBranch, endReached,
        typeLength = type.length, currentType = type[i], nextType = type[i+1];
    if (i === typeLength && tree._listeners) {
      //
      // If at the end of the event(s) list and the tree has listeners
      // invoke those listeners.
      //
      if (typeof tree._listeners === 'function') {
        handlers && handlers.push(tree._listeners);
        return [tree];
      } else {
        for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {
          handlers && handlers.push(tree._listeners[leaf]);
        }
        return [tree];
      }
    }

    if ((currentType === '*' || currentType === '**') || tree[currentType]) {
      //
      // If the event emitted is '*' at this part
      // or there is a concrete match at this patch
      //
      if (currentType === '*') {
        for (branch in tree) {
          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {
            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+1));
          }
        }
        return listeners;
      } else if(currentType === '**') {
        endReached = (i+1 === typeLength || (i+2 === typeLength && nextType === '*'));
        if(endReached && tree._listeners) {
          // The next element has a _listeners, add it to the handlers.
          listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));
        }

        for (branch in tree) {
          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {
            if(branch === '*' || branch === '**') {
              if(tree[branch]._listeners && !endReached) {
                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));
              }
              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));
            } else if(branch === nextType) {
              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+2));
            } else {
              // No match on this one, shift into the tree but not in the type array.
              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));
            }
          }
        }
        return listeners;
      }

      listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i+1));
    }

    xTree = tree['*'];
    if (xTree) {
      //
      // If the listener tree will allow any match for this part,
      // then recursively explore all branches of the tree
      //
      searchListenerTree(handlers, type, xTree, i+1);
    }

    xxTree = tree['**'];
    if(xxTree) {
      if(i < typeLength) {
        if(xxTree._listeners) {
          // If we have a listener on a '**', it will catch all, so add its handler.
          searchListenerTree(handlers, type, xxTree, typeLength);
        }

        // Build arrays of matching next branches and others.
        for(branch in xxTree) {
          if(branch !== '_listeners' && xxTree.hasOwnProperty(branch)) {
            if(branch === nextType) {
              // We know the next element will match, so jump twice.
              searchListenerTree(handlers, type, xxTree[branch], i+2);
            } else if(branch === currentType) {
              // Current node matches, move into the tree.
              searchListenerTree(handlers, type, xxTree[branch], i+1);
            } else {
              isolatedBranch = {};
              isolatedBranch[branch] = xxTree[branch];
              searchListenerTree(handlers, type, { '**': isolatedBranch }, i+1);
            }
          }
        }
      } else if(xxTree._listeners) {
        // We have reached the end and still on a '**'
        searchListenerTree(handlers, type, xxTree, typeLength);
      } else if(xxTree['*'] && xxTree['*']._listeners) {
        searchListenerTree(handlers, type, xxTree['*'], typeLength);
      }
    }

    return listeners;
  }

  function growListenerTree(type, listener) {

    type = typeof type === 'string' ? type.split(this.delimiter) : type.slice();

    //
    // Looks for two consecutive '**', if so, don't add the event at all.
    //
    for(var i = 0, len = type.length; i+1 < len; i++) {
      if(type[i] === '**' && type[i+1] === '**') {
        return;
      }
    }

    var tree = this.listenerTree;
    var name = type.shift();

    while (name !== undefined) {

      if (!tree[name]) {
        tree[name] = {};
      }

      tree = tree[name];

      if (type.length === 0) {

        if (!tree._listeners) {
          tree._listeners = listener;
        }
        else {
          if (typeof tree._listeners === 'function') {
            tree._listeners = [tree._listeners];
          }

          tree._listeners.push(listener);

          if (
            !tree._listeners.warned &&
            this._events.maxListeners > 0 &&
            tree._listeners.length > this._events.maxListeners
          ) {
            tree._listeners.warned = true;
            logPossibleMemoryLeak.call(this, tree._listeners.length, name);
          }
        }
        return true;
      }
      name = type.shift();
    }
    return true;
  }

  // By default EventEmitters will print a warning if more than
  // 10 listeners are added to it. This is a useful default which
  // helps finding memory leaks.
  //
  // Obviously not all Emitters should be limited to 10. This function allows
  // that to be increased. Set to zero for unlimited.

  EventEmitter.prototype.delimiter = '.';

  EventEmitter.prototype.setMaxListeners = function(n) {
    if (n !== undefined) {
      this._events || init.call(this);
      this._events.maxListeners = n;
      if (!this._conf) this._conf = {};
      this._conf.maxListeners = n;
    }
  };

  EventEmitter.prototype.event = '';

  EventEmitter.prototype.once = function(event, fn) {
    this.many(event, 1, fn);
    return this;
  };

  EventEmitter.prototype.many = function(event, ttl, fn) {
    var self = this;

    if (typeof fn !== 'function') {
      throw new Error('many only accepts instances of Function');
    }

    function listener() {
      if (--ttl === 0) {
        self.off(event, listener);
      }
      fn.apply(this, arguments);
    }

    listener._origin = fn;

    this.on(event, listener);

    return self;
  };

  EventEmitter.prototype.emit = function() {

    this._events || init.call(this);

    var type = arguments[0];

    if (type === 'newListener' && !this.newListener) {
      if (!this._events.newListener) {
        return false;
      }
    }

    var al = arguments.length;
    var args,l,i,j;
    var handler;

    if (this._all && this._all.length) {
      handler = this._all.slice();
      if (al > 3) {
        args = new Array(al);
        for (j = 0; j < al; j++) args[j] = arguments[j];
      }

      for (i = 0, l = handler.length; i < l; i++) {
        this.event = type;
        switch (al) {
        case 1:
          handler[i].call(this, type);
          break;
        case 2:
          handler[i].call(this, type, arguments[1]);
          break;
        case 3:
          handler[i].call(this, type, arguments[1], arguments[2]);
          break;
        default:
          handler[i].apply(this, args);
        }
      }
    }

    if (this.wildcard) {
      handler = [];
      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
    } else {
      handler = this._events[type];
      if (typeof handler === 'function') {
        this.event = type;
        switch (al) {
        case 1:
          handler.call(this);
          break;
        case 2:
          handler.call(this, arguments[1]);
          break;
        case 3:
          handler.call(this, arguments[1], arguments[2]);
          break;
        default:
          args = new Array(al - 1);
          for (j = 1; j < al; j++) args[j - 1] = arguments[j];
          handler.apply(this, args);
        }
        return true;
      } else if (handler) {
        // need to make copy of handlers because list can change in the middle
        // of emit call
        handler = handler.slice();
      }
    }

    if (handler && handler.length) {
      if (al > 3) {
        args = new Array(al - 1);
        for (j = 1; j < al; j++) args[j - 1] = arguments[j];
      }
      for (i = 0, l = handler.length; i < l; i++) {
        this.event = type;
        switch (al) {
        case 1:
          handler[i].call(this);
          break;
        case 2:
          handler[i].call(this, arguments[1]);
          break;
        case 3:
          handler[i].call(this, arguments[1], arguments[2]);
          break;
        default:
          handler[i].apply(this, args);
        }
      }
      return true;
    } else if (!this._all && type === 'error') {
      if (arguments[1] instanceof Error) {
        throw arguments[1]; // Unhandled 'error' event
      } else {
        throw new Error("Uncaught, unspecified 'error' event.");
      }
      return false;
    }

    return !!this._all;
  };

  EventEmitter.prototype.emitAsync = function() {

    this._events || init.call(this);

    var type = arguments[0];

    if (type === 'newListener' && !this.newListener) {
        if (!this._events.newListener) { return Promise.resolve([false]); }
    }

    var promises= [];

    var al = arguments.length;
    var args,l,i,j;
    var handler;

    if (this._all) {
      if (al > 3) {
        args = new Array(al);
        for (j = 1; j < al; j++) args[j] = arguments[j];
      }
      for (i = 0, l = this._all.length; i < l; i++) {
        this.event = type;
        switch (al) {
        case 1:
          promises.push(this._all[i].call(this, type));
          break;
        case 2:
          promises.push(this._all[i].call(this, type, arguments[1]));
          break;
        case 3:
          promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));
          break;
        default:
          promises.push(this._all[i].apply(this, args));
        }
      }
    }

    if (this.wildcard) {
      handler = [];
      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
    } else {
      handler = this._events[type];
    }

    if (typeof handler === 'function') {
      this.event = type;
      switch (al) {
      case 1:
        promises.push(handler.call(this));
        break;
      case 2:
        promises.push(handler.call(this, arguments[1]));
        break;
      case 3:
        promises.push(handler.call(this, arguments[1], arguments[2]));
        break;
      default:
        args = new Array(al - 1);
        for (j = 1; j < al; j++) args[j - 1] = arguments[j];
        promises.push(handler.apply(this, args));
      }
    } else if (handler && handler.length) {
      if (al > 3) {
        args = new Array(al - 1);
        for (j = 1; j < al; j++) args[j - 1] = arguments[j];
      }
      for (i = 0, l = handler.length; i < l; i++) {
        this.event = type;
        switch (al) {
        case 1:
          promises.push(handler[i].call(this));
          break;
        case 2:
          promises.push(handler[i].call(this, arguments[1]));
          break;
        case 3:
          promises.push(handler[i].call(this, arguments[1], arguments[2]));
          break;
        default:
          promises.push(handler[i].apply(this, args));
        }
      }
    } else if (!this._all && type === 'error') {
      if (arguments[1] instanceof Error) {
        return Promise.reject(arguments[1]); // Unhandled 'error' event
      } else {
        return Promise.reject("Uncaught, unspecified 'error' event.");
      }
    }

    return Promise.all(promises);
  };

  EventEmitter.prototype.on = function(type, listener) {
    if (typeof type === 'function') {
      this.onAny(type);
      return this;
    }

    if (typeof listener !== 'function') {
      throw new Error('on only accepts instances of Function');
    }
    this._events || init.call(this);

    // To avoid recursion in the case that type == "newListeners"! Before
    // adding it to the listeners, first emit "newListeners".
    this.emit('newListener', type, listener);

    if (this.wildcard) {
      growListenerTree.call(this, type, listener);
      return this;
    }

    if (!this._events[type]) {
      // Optimize the case of one listener. Don't need the extra array object.
      this._events[type] = listener;
    }
    else {
      if (typeof this._events[type] === 'function') {
        // Change to array.
        this._events[type] = [this._events[type]];
      }

      // If we've already got an array, just append.
      this._events[type].push(listener);

      // Check for listener leak
      if (
        !this._events[type].warned &&
        this._events.maxListeners > 0 &&
        this._events[type].length > this._events.maxListeners
      ) {
        this._events[type].warned = true;
        logPossibleMemoryLeak.call(this, this._events[type].length, type);
      }
    }

    return this;
  };

  EventEmitter.prototype.onAny = function(fn) {
    if (typeof fn !== 'function') {
      throw new Error('onAny only accepts instances of Function');
    }

    if (!this._all) {
      this._all = [];
    }

    // Add the function to the event listener collection.
    this._all.push(fn);
    return this;
  };

  EventEmitter.prototype.addListener = EventEmitter.prototype.on;

  EventEmitter.prototype.off = function(type, listener) {
    if (typeof listener !== 'function') {
      throw new Error('removeListener only takes instances of Function');
    }

    var handlers,leafs=[];

    if(this.wildcard) {
      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
    }
    else {
      // does not use listeners(), so no side effect of creating _events[type]
      if (!this._events[type]) return this;
      handlers = this._events[type];
      leafs.push({_listeners:handlers});
    }

    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {
      var leaf = leafs[iLeaf];
      handlers = leaf._listeners;
      if (isArray(handlers)) {

        var position = -1;

        for (var i = 0, length = handlers.length; i < length; i++) {
          if (handlers[i] === listener ||
            (handlers[i].listener && handlers[i].listener === listener) ||
            (handlers[i]._origin && handlers[i]._origin === listener)) {
            position = i;
            break;
          }
        }

        if (position < 0) {
          continue;
        }

        if(this.wildcard) {
          leaf._listeners.splice(position, 1);
        }
        else {
          this._events[type].splice(position, 1);
        }

        if (handlers.length === 0) {
          if(this.wildcard) {
            delete leaf._listeners;
          }
          else {
            delete this._events[type];
          }
        }

        this.emit("removeListener", type, listener);

        return this;
      }
      else if (handlers === listener ||
        (handlers.listener && handlers.listener === listener) ||
        (handlers._origin && handlers._origin === listener)) {
        if(this.wildcard) {
          delete leaf._listeners;
        }
        else {
          delete this._events[type];
        }

        this.emit("removeListener", type, listener);
      }
    }

    function recursivelyGarbageCollect(root) {
      if (root === undefined) {
        return;
      }
      var keys = Object.keys(root);
      for (var i in keys) {
        var key = keys[i];
        var obj = root[key];
        if ((obj instanceof Function) || (typeof obj !== "object") || (obj === null))
          continue;
        if (Object.keys(obj).length > 0) {
          recursivelyGarbageCollect(root[key]);
        }
        if (Object.keys(obj).length === 0) {
          delete root[key];
        }
      }
    }
    recursivelyGarbageCollect(this.listenerTree);

    return this;
  };

  EventEmitter.prototype.offAny = function(fn) {
    var i = 0, l = 0, fns;
    if (fn && this._all && this._all.length > 0) {
      fns = this._all;
      for(i = 0, l = fns.length; i < l; i++) {
        if(fn === fns[i]) {
          fns.splice(i, 1);
          this.emit("removeListenerAny", fn);
          return this;
        }
      }
    } else {
      fns = this._all;
      for(i = 0, l = fns.length; i < l; i++)
        this.emit("removeListenerAny", fns[i]);
      this._all = [];
    }
    return this;
  };

  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;

  EventEmitter.prototype.removeAllListeners = function(type) {
    if (arguments.length === 0) {
      !this._events || init.call(this);
      return this;
    }

    if (this.wildcard) {
      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
      var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);

      for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {
        var leaf = leafs[iLeaf];
        leaf._listeners = null;
      }
    }
    else if (this._events) {
      this._events[type] = null;
    }
    return this;
  };

  EventEmitter.prototype.listeners = function(type) {
    if (this.wildcard) {
      var handlers = [];
      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);
      return handlers;
    }

    this._events || init.call(this);

    if (!this._events[type]) this._events[type] = [];
    if (!isArray(this._events[type])) {
      this._events[type] = [this._events[type]];
    }
    return this._events[type];
  };

  EventEmitter.prototype.listenerCount = function(type) {
    return this.listeners(type).length;
  };

  EventEmitter.prototype.listenersAny = function() {

    if(this._all) {
      return this._all;
    }
    else {
      return [];
    }

  };

  if (typeof define === 'function' && define.amd) {
     // AMD. Register as an anonymous module.
    define(function() {
      return EventEmitter;
    });
  } else if (typeof exports === 'object') {
    // CommonJS
    module.exports = EventEmitter;
  }
  else {
    // Browser global.
    window.EventEmitter2 = EventEmitter;
  }
}();

},{}],3:[function(_dereq_,module,exports){
(function (global){
'use strict';

// Intentionally use native-promise-only here... Other promise libraries (es6-promise)
// duck-punch the global Promise definition which messes up Angular 2 since it
// also duck-punches the global Promise definition. For now, keep native-promise-only.

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Promise = _dereq_("native-promise-only");
_dereq_('whatwg-fetch');
var EventEmitter = _dereq_('eventemitter2').EventEmitter2;
var copy = _dereq_('shallow-copy');

/**
 * The Formio interface class.
 *
 *   let formio = new Formio('https://examples.form.io/example');
 */

var Formio = function () {
  function Formio(path) {
    var _this = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Formio);

    // Ensure we have an instance of Formio.
    if (!(this instanceof Formio)) {
      return new Formio(path);
    }

    // Initialize our variables.
    this.base = '';
    this.projectsUrl = '';
    this.projectUrl = '';
    this.projectId = '';
    this.formUrl = '';
    this.formsUrl = '';
    this.formId = '';
    this.submissionsUrl = '';
    this.submissionUrl = '';
    this.submissionId = '';
    this.actionsUrl = '';
    this.actionId = '';
    this.actionUrl = '';
    this.query = '';

    if (options.hasOwnProperty('base')) {
      this.base = options.base;
    } else if (Formio.baseUrl) {
      this.base = Formio.baseUrl;
    } else {
      this.base = window.location.href.match(/http[s]?:\/\/api./)[0];
    }

    if (!path) {
      // Allow user to create new projects if this was instantiated without
      // a url
      this.projectUrl = this.base + '/project';
      this.projectsUrl = this.base + '/project';
      this.projectId = false;
      this.query = '';
      return;
    }

    if (options.hasOwnProperty('project')) {
      this.projectUrl = options.project;
    }

    var project = this.projectUrl || Formio.projectUrl;

    // The baseURL is the same as the projectUrl. This is almost certainly against
    // the Open Source server.
    if (project && this.base === project) {
      this.noProject = true;
      this.projectUrl = this.base;
    }

    // Normalize to an absolute path.
    if (path.indexOf('http') !== 0 && path.indexOf('//') !== 0) {
      path = this.base + path;
    }

    var hostparts = Formio.getUrlParts(path);
    var parts = [];
    var hostName = hostparts[1] + hostparts[2];
    path = hostparts.length > 3 ? hostparts[3] : '';
    var queryparts = path.split('?');
    if (queryparts.length > 1) {
      path = queryparts[0];
      this.query = '?' + queryparts[1];
    }

    // Register a specific path.
    var registerPath = function registerPath(name, base) {
      _this[name + 'sUrl'] = base + '/' + name;
      var regex = new RegExp('\/' + name + '\/([^/]+)');
      if (path.search(regex) !== -1) {
        parts = path.match(regex);
        _this[name + 'Url'] = parts ? base + parts[0] : '';
        _this[name + 'Id'] = parts.length > 1 ? parts[1] : '';
        base += parts[0];
      }
      return base;
    };

    // Register an array of items.
    var registerItems = function registerItems(items, base, staticBase) {
      for (var i in items) {
        if (items.hasOwnProperty(i)) {
          var item = items[i];
          if (item instanceof Array) {
            registerItems(item, base, true);
          } else {
            var newBase = registerPath(item, base);
            base = staticBase ? base : newBase;
          }
        }
      }
    };

    if (!this.projectUrl || this.projectUrl === this.base) {
      this.projectUrl = hostName;
    }

    if (!this.noProject) {
      // Determine the projectUrl and projectId
      if (path.search(/(^|\/)(project)($|\/)/) !== -1) {
        // Get project id as project/:projectId.
        registerItems(['project'], hostName);
      } else if (hostName === this.base) {
        // Get project id as first part of path (subdirectory).
        if (hostparts.length > 3 && path.split('/').length > 1) {
          var pathParts = path.split('/');
          pathParts.shift(); // Throw away the first /.
          this.projectId = pathParts.shift();
          path = '/' + pathParts.join('/');
          this.projectUrl = hostName + '/' + this.projectId;
        }
      } else {
        // Get project id from subdomain.
        if (hostparts.length > 2 && (hostparts[2].split('.').length > 2 || hostName.indexOf('localhost') !== -1)) {
          this.projectUrl = hostName;
          this.projectId = hostparts[2].split('.')[0];
        }
      }
      this.projectsUrl = this.projectsUrl || this.base + '/project';
    }

    // Configure Form urls and form ids.
    if (path.search(/(^|\/)(project|form)($|\/)/) !== -1) {
      registerItems(['form', ['submission', 'action']], this.projectUrl);
    } else {
      var subRegEx = new RegExp('\/(submission|action)($|\/.*)');
      var subs = path.match(subRegEx);
      this.pathType = subs && subs.length > 1 ? subs[1] : '';
      path = path.replace(subRegEx, '');
      path = path.replace(/\/$/, '');
      this.formsUrl = this.projectUrl + '/form';
      this.formUrl = this.projectUrl + path;
      this.formId = path.replace(/^\/+|\/+$/g, '');
      var items = ['submission', 'action'];
      for (var i in items) {
        if (items.hasOwnProperty(i)) {
          var item = items[i];
          this[item + 'sUrl'] = this.projectUrl + path + '/' + item;
          if (this.pathType === item && subs.length > 2 && subs[2]) {
            this[item + 'Id'] = subs[2].replace(/^\/+|\/+$/g, '');
            this[item + 'Url'] = this.projectUrl + path + subs[0];
          }
        }
      }
    }

    // Set the app url if it is not set.
    if (!Formio.projectUrlSet) {
      Formio.projectUrl = this.projectUrl;
    }
  }

  _createClass(Formio, [{
    key: 'delete',
    value: function _delete(type, opts) {
      var _id = type + 'Id';
      var _url = type + 'Url';
      if (!this[_id]) {
        Promise.reject('Nothing to delete');
      }
      Formio.cache = {};
      return this.makeRequest(type, this[_url], 'delete', null, opts);
    }
  }, {
    key: 'index',
    value: function index(type, query, opts) {
      var _url = type + 'Url';
      query = query || '';
      if (query && (typeof query === 'undefined' ? 'undefined' : _typeof(query)) === 'object') {
        query = '?' + Formio.serialize(query.params);
      }
      return this.makeRequest(type, this[_url] + query, 'get', null, opts);
    }
  }, {
    key: 'save',
    value: function save(type, data, opts) {
      var _id = type + 'Id';
      var _url = type + 'Url';
      var method = this[_id] || data._id ? 'put' : 'post';
      var reqUrl = this[_id] ? this[_url] : this[type + 'sUrl'];
      if (!this[_id] && data._id && method === 'put' && reqUrl.indexOf(data._id) === -1) {
        reqUrl += '/' + data._id;
      }
      Formio.cache = {};
      return this.makeRequest(type, reqUrl + this.query, method, data, opts);
    }
  }, {
    key: 'load',
    value: function load(type, query, opts) {
      var _id = type + 'Id';
      var _url = type + 'Url';
      if (query && (typeof query === 'undefined' ? 'undefined' : _typeof(query)) === 'object') {
        query = Formio.serialize(query.params);
      }
      if (query) {
        query = this.query ? this.query + '&' + query : '?' + query;
      } else {
        query = this.query;
      }
      if (!this[_id]) {
        return Promise.reject('Missing ' + _id);
      }
      return this.makeRequest(type, this[_url] + query, 'get', null, opts);
    }
  }, {
    key: 'makeRequest',
    value: function makeRequest(type, url, method, data, opts) {
      method = (method || 'GET').toUpperCase();
      if (!opts || (typeof opts === 'undefined' ? 'undefined' : _typeof(opts)) !== 'object') {
        opts = {};
      }

      var requestArgs = {
        formio: this,
        type: type,
        url: url,
        method: method,
        data: data,
        opts: opts
      };

      var request = Formio.pluginWait('preRequest', requestArgs).then(function () {
        return Formio.pluginGet('request', requestArgs).then(function (result) {
          if (result === null || result === undefined) {
            return Formio.request(url, method, data, opts.header, opts);
          }
          return result;
        });
      });

      return Formio.pluginAlter('wrapRequestPromise', request, requestArgs);
    }
  }, {
    key: 'loadProject',
    value: function loadProject(query, opts) {
      return this.load('project', query, opts);
    }
  }, {
    key: 'saveProject',
    value: function saveProject(data, opts) {
      return this.save('project', data, opts);
    }
  }, {
    key: 'deleteProject',
    value: function deleteProject(opts) {
      return this.delete('project', opts);
    }
  }, {
    key: 'loadForm',
    value: function loadForm(query, opts) {
      return this.load('form', query, opts);
    }
  }, {
    key: 'saveForm',
    value: function saveForm(data, opts) {
      return this.save('form', data, opts);
    }
  }, {
    key: 'deleteForm',
    value: function deleteForm(opts) {
      return this.delete('form', opts);
    }
  }, {
    key: 'loadForms',
    value: function loadForms(query, opts) {
      return this.index('forms', query, opts);
    }
  }, {
    key: 'loadSubmission',
    value: function loadSubmission(query, opts) {
      return this.load('submission', query, opts);
    }
  }, {
    key: 'saveSubmission',
    value: function saveSubmission(data, opts) {
      return this.save('submission', data, opts);
    }
  }, {
    key: 'deleteSubmission',
    value: function deleteSubmission(opts) {
      return this.delete('submission', opts);
    }
  }, {
    key: 'loadSubmissions',
    value: function loadSubmissions(query, opts) {
      return this.index('submissions', query, opts);
    }
  }, {
    key: 'loadAction',
    value: function loadAction(query, opts) {
      return this.load('action', query, opts);
    }
  }, {
    key: 'saveAction',
    value: function saveAction(data, opts) {
      return this.save('action', data, opts);
    }
  }, {
    key: 'deleteAction',
    value: function deleteAction(opts) {
      return this.delete('action', opts);
    }
  }, {
    key: 'loadActions',
    value: function loadActions(query, opts) {
      return this.index('actions', query, opts);
    }
  }, {
    key: 'availableActions',
    value: function availableActions() {
      return this.makeRequest('availableActions', this.formUrl + '/actions');
    }
  }, {
    key: 'actionInfo',
    value: function actionInfo(name) {
      return this.makeRequest('actionInfo', this.formUrl + '/actions/' + name);
    }

    /**
     * Returns a temporary authentication token for single purpose token generation.
     */

  }, {
    key: 'getTempToken',
    value: function getTempToken(expire, allowed) {
      var token = Formio.getToken();
      if (!token) {
        return Promise.reject('You must be authenticated to generate a temporary auth token.');
      }
      return this.makeRequest('tempToken', this.projectUrl + '/token', 'GET', null, {
        header: new Headers({
          'x-expire': expire,
          'x-allow': allowed
        })
      });
    }
  }, {
    key: 'uploadFile',
    value: function uploadFile(storage, file, fileName, dir, progressCallback, url) {
      var requestArgs = {
        provider: storage,
        method: 'upload',
        file: file,
        fileName: fileName,
        dir: dir
      };
      var request = Formio.pluginWait('preRequest', requestArgs).then(function () {
        return Formio.pluginGet('fileRequest', requestArgs).then(function (result) {
          if (storage && (result === null || result === undefined)) {
            if (Formio.providers.storage.hasOwnProperty(storage)) {
              var provider = new Formio.providers.storage[storage](this);
              return provider.uploadFile(file, fileName, dir, progressCallback, url);
            } else {
              throw 'Storage provider not found';
            }
          }
          return result || { url: '' };
        }.bind(this));
      }.bind(this));

      return Formio.pluginAlter('wrapFileRequestPromise', request, requestArgs);
    }
  }, {
    key: 'downloadFile',
    value: function downloadFile(file) {
      var requestArgs = {
        method: 'download',
        file: file
      };

      var request = Formio.pluginWait('preRequest', requestArgs).then(function () {
        return Formio.pluginGet('fileRequest', requestArgs).then(function (result) {
          if (file.storage && (result === null || result === undefined)) {
            if (Formio.providers.storage.hasOwnProperty(file.storage)) {
              var provider = new Formio.providers.storage[file.storage](this);
              return provider.downloadFile(file);
            } else {
              throw 'Storage provider not found';
            }
          }
          return result || { url: '' };
        }.bind(this));
      }.bind(this));

      return Formio.pluginAlter('wrapFileRequestPromise', request, requestArgs);
    }
  }], [{
    key: 'loadProjects',
    value: function loadProjects(query, opts) {
      query = query || '';
      if ((typeof query === 'undefined' ? 'undefined' : _typeof(query)) === 'object') {
        query = '?' + serialize(query.params);
      }
      return Formio.makeStaticRequest(Formio.baseUrl + '/project' + query);
    }
  }, {
    key: 'getUrlParts',
    value: function getUrlParts(url) {
      var regex = '^(http[s]?:\\/\\/)';
      if (this.base && url.indexOf(this.base) === 0) {
        regex += '(' + this.base.replace(/^http[s]?:\/\//, '') + ')';
      } else {
        regex += '([^/]+)';
      }
      regex += '($|\\/.*)';
      return url.match(new RegExp(regex));
    }
  }, {
    key: 'serialize',
    value: function serialize(obj) {
      var str = [];
      for (var p in obj) {
        if (obj.hasOwnProperty(p)) {
          str.push(encodeURIComponent(p) + "=" + encodeURIComponent(obj[p]));
        }
      }return str.join("&");
    }
  }, {
    key: 'makeStaticRequest',
    value: function makeStaticRequest(url, method, data, opts) {
      method = (method || 'GET').toUpperCase();
      if (!opts || (typeof opts === 'undefined' ? 'undefined' : _typeof(opts)) !== 'object') {
        opts = {};
      }
      var requestArgs = {
        url: url,
        method: method,
        data: data
      };

      var request = Formio.pluginWait('preRequest', requestArgs).then(function () {
        return Formio.pluginGet('staticRequest', requestArgs).then(function (result) {
          if (result === null || result === undefined) {
            return Formio.request(url, method, data, opts.header, opts);
          }
          return result;
        });
      });

      return Formio.pluginAlter('wrapStaticRequestPromise', request, requestArgs);
    }
  }, {
    key: 'request',
    value: function request(url, method, data, header, opts) {
      if (!url) {
        return Promise.reject('No url provided');
      }
      method = (method || 'GET').toUpperCase();

      // For reverse compatibility, if they provided the ignoreCache parameter,
      // then change it back to the options format where that is a parameter.
      if (typeof opts === 'boolean') {
        opts = { ignoreCache: opts };
      }
      if (!opts || (typeof opts === 'undefined' ? 'undefined' : _typeof(opts)) !== 'object') {
        opts = {};
      }

      var cacheKey = btoa(url);

      return new Promise(function (resolve, reject) {
        // Get the cached promise to save multiple loads.
        if (!opts.ignoreCache && method === 'GET' && Formio.cache.hasOwnProperty(cacheKey)) {
          return resolve(Formio.cache[cacheKey]);
        }

        var requestToken = '';
        resolve(new Promise(function (resolve, reject) {
          // Set up and fetch request
          var headers = header || new Headers({
            'Accept': 'application/json',
            'Content-type': 'application/json; charset=UTF-8'
          });
          var token = Formio.getToken();
          if (token && !opts.noToken) {
            headers.append('x-jwt-token', token);
          }

          var options = {
            method: method,
            headers: headers,
            mode: 'cors'
          };
          if (data) {
            options.body = JSON.stringify(data);
          }

          requestToken = headers.get('x-jwt-token');
          resolve(fetch(url, options));
        }).catch(function (err) {
          err.message = 'Could not connect to API server (' + err.message + ')';
          err.networkError = true;
          throw err;
        }).then(function (response) {
          if (!response.ok) {
            if (response.status === 440) {
              Formio.setToken(null);
              Formio.events.emit('formio.sessionExpired', response.body);
            } else if (response.status === 401) {
              Formio.events.emit('formio.unauthorized', response.body);
            }
            // Parse and return the error as a rejected promise to reject this promise
            return (response.headers.get('content-type').indexOf('application/json') !== -1 ? response.json() : response.text()).then(function (error) {
              throw error;
            });
          }

          // Handle fetch results
          var token = response.headers.get('x-jwt-token');

          // In some strange cases, the fetch library will return an x-jwt-token without sending
          // one to the server. This has even been debugged on the server to verify that no token
          // was introduced with the request, but the response contains a token. This is an Invalid
          // case where we do not send an x-jwt-token and get one in return for any GET request.
          var tokenIntroduced = false;
          if (method === 'GET' && !requestToken && token && url.indexOf('token=') === -1 && url.indexOf('x-jwt-token=' === -1)) {
            console.warn('Token was introduced in request.');
            tokenIntroduced = true;
          }

          if (response.status >= 200 && response.status < 300 && token && token !== '' && !tokenIntroduced) {
            Formio.setToken(token);
          }
          // 204 is no content. Don't try to .json() it.
          if (response.status === 204) {
            return {};
          }
          return (response.headers.get('content-type').indexOf('application/json') !== -1 ? response.json() : response.text()).then(function (result) {
            // Add some content-range metadata to the result here
            var range = response.headers.get('content-range');
            if (range && (typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object') {
              range = range.split('/');
              if (range[0] !== '*') {
                var skipLimit = range[0].split('-');
                result.skip = Number(skipLimit[0]);
                result.limit = skipLimit[1] - skipLimit[0] + 1;
              }
              result.serverCount = range[1] === '*' ? range[1] : Number(range[1]);
            }

            if (!opts.getHeaders) {
              return result;
            }

            var headers = {};
            response.headers.forEach(function (item, key) {
              headers[key] = item;
            });

            return new Promise(function (resolve, reject) {
              resolve({ result: result, headers: headers });
            });
          });
        }).catch(function (err) {
          if (err === 'Bad Token') {
            Formio.setToken(null);
            Formio.events.emit('formio.badToken', err);
          }
          if (Formio.cache.hasOwnProperty(cacheKey)) {
            // Remove failed promises from cache
            delete Formio.cache[cacheKey];
          }
          // Propagate error so client can handle accordingly
          throw err;
        }));
      }).then(function (result) {
        // Save the cache
        if (method === 'GET') {
          Formio.cache[cacheKey] = Promise.resolve(result);
        }

        // Shallow copy result so modifications don't end up in cache
        if (Array.isArray(result)) {
          var resultCopy = result.map(copy);
          resultCopy.skip = result.skip;
          resultCopy.limit = result.limit;
          resultCopy.serverCount = result.serverCount;
          return resultCopy;
        }
        return copy(result);
      });
    }
  }, {
    key: 'setToken',
    value: function setToken(token) {
      token = token || '';
      if (token === this.token) {
        return;
      }
      this.token = token;
      if (!token) {
        Formio.setUser(null);
        // iOS in private browse mode will throw an error but we can't detect ahead of time that we are in private mode.
        try {
          return localStorage.removeItem('formioToken');
        } catch (err) {
          return;
        }
      }
      // iOS in private browse mode will throw an error but we can't detect ahead of time that we are in private mode.
      try {
        localStorage.setItem('formioToken', token);
      } catch (err) {
        // Do nothing.
      }
      return Formio.currentUser(); // Run this so user is updated if null
    }
  }, {
    key: 'getToken',
    value: function getToken() {
      if (this.token) {
        return this.token;
      }
      try {
        var token = localStorage.getItem('formioToken') || '';
        this.token = token;
        return token;
      } catch (e) {
        return '';
      }
    }
  }, {
    key: 'setUser',
    value: function setUser(user) {
      if (!user) {
        this.setToken(null);
        // iOS in private browse mode will throw an error but we can't detect ahead of time that we are in private mode.
        try {
          return localStorage.removeItem('formioUser');
        } catch (err) {
          return;
        }
      }
      // iOS in private browse mode will throw an error but we can't detect ahead of time that we are in private mode.
      try {
        localStorage.setItem('formioUser', JSON.stringify(user));
      } catch (err) {
        // Do nothing.
      }
    }
  }, {
    key: 'getUser',
    value: function getUser() {
      try {
        return JSON.parse(localStorage.getItem('formioUser') || null);
      } catch (e) {
        return;
      }
    }
  }, {
    key: 'setBaseUrl',
    value: function setBaseUrl(url) {
      Formio.baseUrl = url;
      if (!Formio.projectUrlSet) {
        Formio.projectUrl = url;
      }
    }
  }, {
    key: 'getBaseUrl',
    value: function getBaseUrl() {
      return Formio.baseUrl;
    }
  }, {
    key: 'setApiUrl',
    value: function setApiUrl(url) {
      return Formio.setBaseUrl(url);
    }
  }, {
    key: 'getApiUrl',
    value: function getApiUrl() {
      return Formio.getBaseUrl();
    }
  }, {
    key: 'setAppUrl',
    value: function setAppUrl(url) {
      console.warn('Formio.setAppUrl() is deprecated. Use Formio.setProjectUrl instead.');
      Formio.projectUrl = url;
      Formio.projectUrlSet = true;
    }
  }, {
    key: 'setProjectUrl',
    value: function setProjectUrl(url) {
      Formio.projectUrl = url;
      Formio.projectUrlSet = true;
    }
  }, {
    key: 'getAppUrl',
    value: function getAppUrl() {
      console.warn('Formio.getAppUrl() is deprecated. Use Formio.getProjectUrl instead.');
      return Formio.projectUrl;
    }
  }, {
    key: 'getProjectUrl',
    value: function getProjectUrl() {
      return Formio.projectUrl;
    }
  }, {
    key: 'clearCache',
    value: function clearCache() {
      Formio.cache = {};
    }
  }, {
    key: 'noop',
    value: function noop() {}
  }, {
    key: 'identity',
    value: function identity(value) {
      return value;
    }
  }, {
    key: 'deregisterPlugin',
    value: function deregisterPlugin(plugin) {
      var beforeLength = Formio.plugins.length;
      Formio.plugins = Formio.plugins.filter(function (p) {
        if (p !== plugin && p.__name !== plugin) return true;
        (p.deregister || Formio.noop).call(p, Formio);
        return false;
      });
      return beforeLength !== Formio.plugins.length;
    }
  }, {
    key: 'registerPlugin',
    value: function registerPlugin(plugin, name) {
      Formio.plugins.push(plugin);
      Formio.plugins.sort(function (a, b) {
        return (b.priority || 0) - (a.priority || 0);
      });
      plugin.__name = name;
      (plugin.init || Formio.noop).call(plugin, Formio);
    }
  }, {
    key: 'getPlugin',
    value: function getPlugin(name) {
      return Formio.plugins.reduce(function (result, plugin) {
        if (result) return result;
        if (plugin.__name === name) return plugin;
      }, null);
    }
  }, {
    key: 'pluginWait',
    value: function pluginWait(pluginFn) {
      var args = [].slice.call(arguments, 1);
      return Promise.all(Formio.plugins.map(function (plugin) {
        return (plugin[pluginFn] || Formio.noop).apply(plugin, args);
      }));
    }
  }, {
    key: 'pluginGet',
    value: function pluginGet(pluginFn) {
      var args = [].slice.call(arguments, 0);
      var callPlugin = function callPlugin(index, pluginFn) {
        var plugin = Formio.plugins[index];
        if (!plugin) return Promise.resolve(null);
        return Promise.resolve((plugin && plugin[pluginFn] || Formio.noop).apply(plugin, [].slice.call(arguments, 2))).then(function (result) {
          if (result !== null && result !== undefined) return result;
          return callPlugin.apply(null, [index + 1].concat(args));
        });
      };
      return callPlugin.apply(null, [0].concat(args));
    }
  }, {
    key: 'pluginAlter',
    value: function pluginAlter(pluginFn, value) {
      var args = [].slice.call(arguments, 2);
      return Formio.plugins.reduce(function (value, plugin) {
        return (plugin[pluginFn] || Formio.identity).apply(plugin, [value].concat(args));
      }, value);
    }
  }, {
    key: 'currentUser',
    value: function currentUser() {
      var url = Formio.baseUrl + '/current';
      var user = this.getUser();
      if (user) {
        return Formio.pluginAlter('wrapStaticRequestPromise', Promise.resolve(user), {
          url: url,
          method: 'GET'
        });
      }
      var token = this.getToken();
      if (!token) {
        return Formio.pluginAlter('wrapStaticRequestPromise', Promise.resolve(null), {
          url: url,
          method: 'GET'
        });
      }
      return Formio.makeStaticRequest(url).then(function (response) {
        Formio.setUser(response);
        return response;
      });
    }
  }, {
    key: 'logout',
    value: function logout() {
      Formio.setToken(null);
      Formio.setUser(null);
      Formio.clearCache();
      return Formio.makeStaticRequest(Formio.baseUrl + '/logout');
    }

    /**
     * Attach an HTML form to Form.io.
     *
     * @param form
     */

  }, {
    key: 'form',
    value: function form(_form, options, done) {
      // Fix the parameters.
      if (!done && typeof options === 'function') {
        done = options;
        options = {};
      }

      done = done || function () {
        console.log(arguments);
      };
      options = options || {};

      // IF they provide a jquery object, then select the element.
      if (_form.jquery) {
        _form = _form[0];
      }
      if (!_form) {
        return done('Invalid Form');
      }

      var getAction = function getAction() {
        return options.form || _form.getAttribute('action');
      };

      /**
       * Returns the current submission object.
       * @returns {{data: {}}}
       */
      var getSubmission = function getSubmission() {
        var submission = { data: {} };
        var setValue = function setValue(path, value) {
          var isArray = path.substr(-2) === '[]';
          if (isArray) {
            path = path.replace('[]', '');
          }
          var paths = path.replace(/\[|\]\[/g, '.').replace(/\]$/g, '').split('.');
          var current = submission;
          while (path = paths.shift()) {
            if (!paths.length) {
              if (isArray) {
                if (!current[path]) {
                  current[path] = [];
                }
                current[path].push(value);
              } else {
                current[path] = value;
              }
            } else {
              if (!current[path]) {
                current[path] = {};
              }
              current = current[path];
            }
          }
        };

        // Get the form data from this form.
        var formData = new FormData(_form);
        var entries = formData.entries();
        var entry = null;
        while (entry = entries.next().value) {
          setValue(entry[0], entry[1]);
        }
        return submission;
      };

      // Submits the form.
      var submit = function submit(event) {
        if (event) {
          event.preventDefault();
        }
        var action = getAction();
        if (!action) {
          return;
        }
        new Formio(action).saveSubmission(getSubmission()).then(function (sub) {
          done(null, sub);
        }, done);
      };

      // Attach formio to the provided form.
      if (_form.attachEvent) {
        _form.attachEvent('submit', submit);
      } else {
        _form.addEventListener('submit', submit);
      }

      return {
        submit: submit,
        getAction: getAction,
        getSubmission: getSubmission
      };
    }
  }, {
    key: 'fieldData',
    value: function fieldData(data, component) {
      if (!data) {
        return '';
      }
      if (!component || !component.key) {
        return data;
      }
      if (component.key.indexOf('.') !== -1) {
        var value = data;
        var parts = component.key.split('.');
        var key = '';
        for (var i = 0; i < parts.length; i++) {
          key = parts[i];

          // Handle nested resources
          if (value.hasOwnProperty('_id')) {
            value = value.data;
          }

          // Return if the key is not found on the value.
          if (!value.hasOwnProperty(key)) {
            return;
          }

          // Convert old single field data in submissions to multiple
          if (key === parts[parts.length - 1] && component.multiple && !Array.isArray(value[key])) {
            value[key] = [value[key]];
          }

          // Set the value of this key.
          value = value[key];
        }
        return value;
      } else {
        // Convert old single field data in submissions to multiple
        if (component.multiple && !Array.isArray(data[component.key])) {
          data[component.key] = [data[component.key]];
        }
        return data[component.key];
      }
    }
  }]);

  return Formio;
}();

// Define all the static properties.


exports.Formio = Formio;
Formio.baseUrl = 'https://api.form.io';
Formio.projectUrl = Formio.baseUrl;
Formio.projectUrlSet = false;
Formio.plugins = [];
Formio.cache = {};
Formio.providers = _dereq_('./providers');
Formio.events = new EventEmitter({
  wildcard: false,
  maxListeners: 0
});

module.exports = global.Formio = Formio;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./providers":4,"eventemitter2":2,"native-promise-only":179,"shallow-copy":180,"whatwg-fetch":182}],4:[function(_dereq_,module,exports){
'use strict';

module.exports = {
  storage: _dereq_('./storage')
};

},{"./storage":6}],5:[function(_dereq_,module,exports){
'use strict';

var Promise = _dereq_("native-promise-only");
var dropbox = function dropbox(formio) {
  return {
    uploadFile: function uploadFile(file, fileName, dir, progressCallback) {
      return new Promise(function (resolve, reject) {
        // Send the file with data.
        var xhr = new XMLHttpRequest();

        if (typeof progressCallback === 'function') {
          xhr.upload.onprogress = progressCallback;
        }

        var fd = new FormData();
        fd.append('name', fileName);
        fd.append('dir', dir);
        fd.append('file', file);

        // Fire on network error.
        xhr.onerror = function (err) {
          err.networkError = true;
          reject(err);
        };

        xhr.onload = function () {
          if (xhr.status >= 200 && xhr.status < 300) {
            var response = JSON.parse(xhr.response);
            response.storage = 'dropbox';
            response.size = file.size;
            response.type = file.type;
            response.url = response.path_lower;
            resolve(response);
          } else {
            reject(xhr.response || 'Unable to upload file');
          }
        };

        xhr.onabort = function (err) {
          reject(err);
        };

        xhr.open('POST', formio.formUrl + '/storage/dropbox');
        var token = false;
        try {
          token = localStorage.getItem('formioToken');
        } catch (e) {
          // Swallow error.
        }
        if (token) {
          xhr.setRequestHeader('x-jwt-token', token);
        }
        xhr.send(fd);
      });
    },
    downloadFile: function downloadFile(file) {
      var token = false;
      try {
        token = localStorage.getItem('formioToken');
      } catch (e) {
        // Swallow error.
      }
      file.url = formio.formUrl + '/storage/dropbox?path_lower=' + file.path_lower + (token ? '&x-jwt-token=' + token : '');
      return Promise.resolve(file);
    }
  };
};

dropbox.title = 'Dropbox';
module.exports = dropbox;

},{"native-promise-only":179}],6:[function(_dereq_,module,exports){
'use strict';

module.exports = {
  dropbox: _dereq_('./dropbox.js'),
  s3: _dereq_('./s3.js'),
  url: _dereq_('./url.js')
};

},{"./dropbox.js":5,"./s3.js":7,"./url.js":8}],7:[function(_dereq_,module,exports){
'use strict';

var Promise = _dereq_("native-promise-only");
var s3 = function s3(formio) {
  return {
    uploadFile: function uploadFile(file, fileName, dir, progressCallback) {
      return new Promise(function (resolve, reject) {
        // Send the pre response to sign the upload.
        var pre = new XMLHttpRequest();

        var prefd = new FormData();
        prefd.append('name', fileName);
        prefd.append('size', file.size);
        prefd.append('type', file.type);

        // This only fires on a network error.
        pre.onerror = function (err) {
          err.networkError = true;
          reject(err);
        };

        pre.onabort = function (err) {
          reject(err);
        };

        pre.onload = function () {
          if (pre.status >= 200 && pre.status < 300) {
            var response = JSON.parse(pre.response);

            // Send the file with data.
            var xhr = new XMLHttpRequest();

            if (typeof progressCallback === 'function') {
              xhr.upload.onprogress = progressCallback;
            }

            response.data.fileName = fileName;
            response.data.key += dir + fileName;

            var fd = new FormData();
            for (var key in response.data) {
              fd.append(key, response.data[key]);
            }
            fd.append('file', file);

            // Fire on network error.
            xhr.onerror = function (err) {
              err.networkError = true;
              reject(err);
            };

            xhr.onload = function () {
              if (xhr.status >= 200 && xhr.status < 300) {
                resolve({
                  storage: 's3',
                  name: fileName,
                  bucket: response.bucket,
                  key: response.data.key,
                  url: response.url + response.data.key,
                  acl: response.data.acl,
                  size: file.size,
                  type: file.type
                });
              } else {
                reject(xhr.response || 'Unable to upload file');
              }
            };

            xhr.onabort = function (err) {
              reject(err);
            };

            xhr.open('POST', response.url);

            xhr.send(fd);
          } else {
            reject(pre.response || 'Unable to sign file');
          }
        };

        pre.open('POST', formio.formUrl + '/storage/s3');

        pre.setRequestHeader('Accept', 'application/json');
        pre.setRequestHeader('Content-Type', 'application/json; charset=UTF-8');
        var token = false;
        try {
          token = localStorage.getItem('formioToken');
        } catch (e) {
          // swallow error.
        }
        if (token) {
          pre.setRequestHeader('x-jwt-token', token);
        }

        pre.send(JSON.stringify({
          name: fileName,
          size: file.size,
          type: file.type
        }));
      });
    },
    downloadFile: function downloadFile(file) {
      if (file.acl !== 'public-read') {
        return formio.makeRequest('file', formio.formUrl + '/storage/s3?bucket=' + file.bucket + '&key=' + file.key, 'GET');
      } else {
        return Promise.resolve(file);
      }
    }
  };
};

s3.title = 'S3';
module.exports = s3;

},{"native-promise-only":179}],8:[function(_dereq_,module,exports){
'use strict';

var Promise = _dereq_("native-promise-only");
var url = function url(formio) {
  return {
    title: 'Url',
    name: 'url',
    uploadFile: function uploadFile(file, fileName, dir, progressCallback, url) {
      return new Promise(function (resolve, reject) {
        var data = {
          dir: dir,
          name: fileName,
          file: file
        };

        // Send the file with data.
        var xhr = new XMLHttpRequest();

        if (typeof progressCallback === 'function') {
          xhr.upload.onprogress = progressCallback;
        }

        var fd = new FormData();
        for (var key in data) {
          fd.append(key, data[key]);
        }

        xhr.onload = function () {
          if (xhr.status >= 200 && xhr.status < 300) {
            // Need to test if xhr.response is decoded or not.
            var respData = {};
            try {
              respData = typeof xhr.response === 'string' ? JSON.parse(xhr.response) : {};
              respData = respData && respData.data ? respData.data : {};
            } catch (err) {
              respData = {};
            }

            resolve({
              storage: 'url',
              name: fileName,
              url: xhr.responseURL + '/' + fileName,
              size: file.size,
              type: file.type,
              data: respData
            });
          } else {
            reject(xhr.response || 'Unable to upload file');
          }
        };

        // Fire on network error.
        xhr.onerror = function () {
          reject(xhr);
        };

        xhr.onabort = function () {
          reject(xhr);
        };

        xhr.open('POST', url);
        var token = localStorage.getItem('formioToken');
        if (token) {
          xhr.setRequestHeader('x-jwt-token', token);
        }
        xhr.send(fd);
      });
    },
    downloadFile: function downloadFile(file) {
      // Return the original as there is nothing to do.
      return Promise.resolve(file);
    }
  };
};

url.title = 'Url';
module.exports = url;

},{"native-promise-only":179}],9:[function(_dereq_,module,exports){
'use strict';

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

var _jsonLogicJs = _dereq_('json-logic-js');

var _jsonLogicJs2 = _interopRequireDefault(_jsonLogicJs);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _get = _dereq_('lodash/get');

module.exports = {
  /**
   * Determine if a component is a layout component or not.
   *
   * @param {Object} component
   *   The component to check.
   *
   * @returns {Boolean}
   *   Whether or not the component is a layout component.
   */
  isLayoutComponent: function isLayoutComponent(component) {
    return component.columns && Array.isArray(component.columns) || component.rows && Array.isArray(component.rows) || component.components && Array.isArray(component.components) ? true : false;
  },

  /**
   * Iterate through each component within a form.
   *
   * @param {Object} components
   *   The components to iterate.
   * @param {Function} fn
   *   The iteration function to invoke for each component.
   * @param {Boolean} includeAll
   *   Whether or not to include layout components.
   * @param {String} path
   *   The current data path of the element. Example: data.user.firstName
   */
  eachComponent: function eachComponent(components, fn, includeAll, path) {
    if (!components) return;
    path = path || '';
    components.forEach(function (component) {
      var hasColumns = component.columns && Array.isArray(component.columns);
      var hasRows = component.rows && Array.isArray(component.rows);
      var hasComps = component.components && Array.isArray(component.components);
      var noRecurse = false;
      var newPath = component.key ? path ? path + '.' + component.key : component.key : '';

      if (includeAll || component.tree || !hasColumns && !hasRows && !hasComps) {
        noRecurse = fn(component, newPath);
      }

      var subPath = function subPath() {
        if (component.key && (component.type === 'datagrid' || component.type === 'container')) {
          return newPath;
        }
        return path;
      };

      if (!noRecurse) {
        if (hasColumns) {
          component.columns.forEach(function (column) {
            eachComponent(column.components, fn, includeAll, subPath());
          });
        } else if (hasRows) {
          [].concat.apply([], component.rows).forEach(function (row) {
            eachComponent(row.components, fn, includeAll, subPath());
          });
        } else if (hasComps) {
          eachComponent(component.components, fn, includeAll, subPath());
        }
      }
    });
  },

  /**
   * Get a component by its key
   *
   * @param {Object} components
   *   The components to iterate.
   * @param {String} key
   *   The key of the component to get.
   *
   * @returns {Object}
   *   The component that matches the given key, or undefined if not found.
   */
  getComponent: function getComponent(components, key) {
    var result;
    module.exports.eachComponent(components, function (component) {
      if (component.key === key) {
        result = component;
      }
    });
    return result;
  },

  /**
   * Flatten the form components for data manipulation.
   *
   * @param {Object} components
   *   The components to iterate.
   * @param {Boolean} includeAll
   *   Whether or not to include layout components.
   *
   * @returns {Object}
   *   The flattened components map.
   */
  flattenComponents: function flattenComponents(components, includeAll) {
    var flattened = {};
    module.exports.eachComponent(components, function (component, path) {
      flattened[path] = component;
    }, includeAll);
    return flattened;
  },

  /**
   * Returns if this component has a conditional statement.
   *
   * @param component - The component JSON schema.
   *
   * @returns {boolean} - TRUE - This component has a conditional, FALSE - No conditional provided.
   */
  hasCondition: function hasCondition(component) {
    return component.hasOwnProperty('customConditional') && component.customConditional || component.hasOwnProperty('conditional') && component.conditional && component.conditional.when || component.hasOwnProperty('conditional') && component.conditional && component.conditional.json;
  },

  /**
   * Checks the conditions for a provided component and data.
   *
   * @param component
   *   The component to check for the condition.
   * @param row
   *   The data within a row
   * @param data
   *   The full submission data.
   *
   * @returns {boolean}
   */
  checkCondition: function checkCondition(component, row, data) {
    if (component.hasOwnProperty('customConditional') && component.customConditional) {
      try {
        var script = '(function() { var show = true;';
        script += component.customConditional.toString();
        script += '; return show; })()';
        var result = eval(script);
        return result.toString() === 'true';
      } catch (e) {
        console.warn('An error occurred in a custom conditional statement for component ' + component.key, e);
        return true;
      }
    } else if (component.hasOwnProperty('conditional') && component.conditional && component.conditional.when) {
      var cond = component.conditional;
      var value = null;
      if (row) {
        value = this.getValue({ data: row }, cond.when);
      }
      if (data && (value === null || typeof value === 'undefined')) {
        value = this.getValue({ data: data }, cond.when);
      }
      // FOR-400 - Fix issue where falsey values were being evaluated as show=true
      if (value === null || typeof value === 'undefined') {
        return false;
      }
      // Special check for selectboxes component.
      if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.hasOwnProperty(cond.eq)) {
        return value[cond.eq].toString() === cond.show.toString();
      }
      // FOR-179 - Check for multiple values.
      if (value instanceof Array && value.indexOf(cond.eq) !== -1) {
        return cond.show.toString() === 'true';
      }

      return value.toString() === cond.eq.toString() === (cond.show.toString() === 'true');
    } else if (component.hasOwnProperty('conditional') && component.conditional && component.conditional.json) {
      return _jsonLogicJs2.default.apply(component.conditional.json, {
        data: data,
        row: row
      });
    }

    // Default to show.
    return true;
  },

  /**
   * Get the value for a component key, in the given submission.
   *
   * @param {Object} submission
   *   A submission object to search.
   * @param {String} key
   *   A for components API key to search for.
   */
  getValue: function getValue(submission, key) {
    var data = submission.data || {};

    var search = function search(data) {
      var i;
      var value;

      if (!data) {
        return null;
      }

      if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object' && !(data instanceof Array)) {
        if (data.hasOwnProperty(key)) {
          return data[key];
        }

        var keys = Object.keys(data);
        for (i = 0; i < keys.length; i++) {
          if (_typeof(data[keys[i]]) === 'object') {
            value = search(data[keys[i]]);
          }

          if (value) {
            return value;
          }
        }
      }
    };

    return search(data);
  },

  /**
   * Interpolate a string and add data replacements.
   *
   * @param string
   * @param data
   * @returns {XML|string|*|void}
   */
  interpolate: function interpolate(string, data) {
    return string.replace(/\{\{\s*([^\s]*)\s*\}\}/g, function (match, token) {
      return _get(data, token);
    });
  }
};

},{"json-logic-js":11,"lodash/get":157}],10:[function(_dereq_,module,exports){
'use strict';

module.exports = _dereq_('./build/utils');

},{"./build/utils":9}],11:[function(_dereq_,module,exports){
/* globals define,module */
/*
Using a Universal Module Loader that should be browser, require, and AMD friendly
http://ricostacruz.com/cheatsheets/umdjs.html
*/
;(function(root, factory) {
  if (typeof define === "function" && define.amd) {
    define(factory);
  } else if (typeof exports === "object") {
    module.exports = factory();
  } else {
    root.jsonLogic = factory();
  }
}(this, function() {
  "use strict";
  /* globals console:false */

  if ( ! Array.isArray) {
    Array.isArray = function(arg) {
      return Object.prototype.toString.call(arg) === "[object Array]";
    };
  }

  function arrayUnique(array) {
    var a = [];
    for (var i=0, l=array.length; i<l; i++) {
      if (a.indexOf(array[i]) === -1) {
        a.push(array[i]);
      }
    }
    return a;
  }

  var jsonLogic = {};
  var operations = {
    "==": function(a, b) {
      return a == b;
    },
    "===": function(a, b) {
      return a === b;
    },
    "!=": function(a, b) {
      return a != b;
    },
    "!==": function(a, b) {
      return a !== b;
    },
    ">": function(a, b) {
      return a > b;
    },
    ">=": function(a, b) {
      return a >= b;
    },
    "<": function(a, b, c) {
      return (c === undefined) ? a < b : (a < b) && (b < c);
    },
    "<=": function(a, b, c) {
      return (c === undefined) ? a <= b : (a <= b) && (b <= c);
    },
    "!!": function(a) {
      return jsonLogic.truthy(a);
    },
    "!": function(a) {
      return !jsonLogic.truthy(a);
    },
    "%": function(a, b) {
      return a % b;
    },
    "log": function(a) {
      console.log(a); return a;
    },
    "in": function(a, b) {
      if(typeof b.indexOf === "undefined") return false;
      return (b.indexOf(a) !== -1);
    },
    "cat": function() {
      return Array.prototype.join.call(arguments, "");
    },
    "+": function() {
      return Array.prototype.reduce.call(arguments, function(a, b) {
        return parseFloat(a, 10) + parseFloat(b, 10);
      }, 0);
    },
    "*": function() {
      return Array.prototype.reduce.call(arguments, function(a, b) {
        return parseFloat(a, 10) * parseFloat(b, 10);
      });
    },
    "-": function(a, b) {
      if(b === undefined) {
        return -a;
      }else{
        return a - b;
      }
    },
    "/": function(a, b) { return a / b; },
    "min": function() {
      return Math.min.apply(this, arguments);
    },
    "max": function() {
      return Math.max.apply(this, arguments);
    },
    "merge": function() {
      return Array.prototype.reduce.call(arguments, function(a, b) {
        return a.concat(b);
      }, []);
    },
    "var": function(a, b) {
      var not_found = (b === undefined) ? null : b;
      var sub_props = String(a).split(".");
      var data = this;
      for(var i = 0; i < sub_props.length; i++) {
        // Descending into data
        data = data[sub_props[i]];
        if(data === undefined) {
          return not_found;
        }
      }
      return data;
    },
    "missing": function() {
      /*
      Missing can receive many keys as many arguments, like {"missing:[1,2]}
      Missing can also receive *one* argument that is an array of keys,
      which typically happens if it's actually acting on the output of another command
      (like 'if' or 'merge')
      */

      var missing = [];
      var keys = Array.isArray(arguments[0]) ? arguments[0] : arguments;

      for(var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var value = jsonLogic.apply({"var": key}, this);
        if(value === null || value === "") {
          missing.push(key);
        }
      }

      return missing;
    },
    "missing_some": function(need_count, options) {
      // missing_some takes two arguments, how many (minimum) items must be present, and an array of keys (just like 'missing') to check for presence.
      var are_missing = jsonLogic.apply({"missing": options}, this);

      if(options.length - are_missing.length >= need_count) {
        return [];
      }else{
        return are_missing;
      }
    },
    "method": function(obj, method, args) {
      return obj[method].apply(obj, args);
    },

  };

  jsonLogic.is_logic = function(logic) {
    return (
      logic !== null && typeof logic === "object" && ! Array.isArray(logic)
    );
  };

  /*
  This helper will defer to the JsonLogic spec as a tie-breaker when different language interpreters define different behavior for the truthiness of primitives.  E.g., PHP considers empty arrays to be falsy, but Javascript considers them to be truthy. JsonLogic, as an ecosystem, needs one consistent answer.

  Literal | JS    |  PHP  |  JsonLogic
  --------+-------+-------+---------------
  []      | true  | false | false
  "0"     | true  | false | true
  */
  jsonLogic.truthy = function(value) {
    if(Array.isArray(value) && value.length === 0) {
      return false;
    }
    return !! value;
  };


  jsonLogic.get_operator = function(logic){
    return Object.keys(logic)[0];
  };

  jsonLogic.get_values = function(logic){
    return logic[ jsonLogic.get_operator(logic) ];
  };

  jsonLogic.apply = function(logic, data) {
    // Does this array contain logic? Only one way to find out.
    if(Array.isArray(logic)) {
      return logic.map(function(l) {
        return jsonLogic.apply(l, data);
      });
    }
    // You've recursed to a primitive, stop!
    if( ! jsonLogic.is_logic(logic) ) {
      return logic;
    }

    data = data || {};

    var op = jsonLogic.get_operator(logic);
    var values = logic[op];
    var i;
    var current;

    // easy syntax for unary operators, like {"var" : "x"} instead of strict {"var" : ["x"]}
    if( ! Array.isArray(values)) {
      values = [values];
    }

    // 'if', 'and', and 'or' violate the normal rule of depth-first calculating consequents, let each manage recursion as needed.
    if(op === "if" || op == "?:") {
      /* 'if' should be called with a odd number of parameters, 3 or greater
      This works on the pattern:
      if( 0 ){ 1 }else{ 2 };
      if( 0 ){ 1 }else if( 2 ){ 3 }else{ 4 };
      if( 0 ){ 1 }else if( 2 ){ 3 }else if( 4 ){ 5 }else{ 6 };

      The implementation is:
      For pairs of values (0,1 then 2,3 then 4,5 etc)
      If the first evaluates truthy, evaluate and return the second
      If the first evaluates falsy, jump to the next pair (e.g, 0,1 to 2,3)
      given one parameter, evaluate and return it. (it's an Else and all the If/ElseIf were false)
      given 0 parameters, return NULL (not great practice, but there was no Else)
      */
      for(i = 0; i < values.length - 1; i += 2) {
        if( jsonLogic.truthy( jsonLogic.apply(values[i], data) ) ) {
          return jsonLogic.apply(values[i+1], data);
        }
      }
      if(values.length === i+1) return jsonLogic.apply(values[i], data);
      return null;
    }else if(op === "and") { // Return first falsy, or last
      for(i=0; i < values.length; i+=1) {
        current = jsonLogic.apply(values[i], data);
        if( ! jsonLogic.truthy(current)) {
          return current;
        }
      }
      return current; // Last
    }else if(op === "or") {// Return first truthy, or last
      for(i=0; i < values.length; i+=1) {
        current = jsonLogic.apply(values[i], data);
        if( jsonLogic.truthy(current) ) {
          return current;
        }
      }
      return current; // Last
    }


    // Everyone else gets immediate depth-first recursion
    values = values.map(function(val) {
      return jsonLogic.apply(val, data);
    });


    // The operation is called with "data" bound to its "this" and "values" passed as arguments.
    // Structured commands like % or > can name formal arguments while flexible commands (like missing or merge) can operate on the pseudo-array arguments
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments
    if(typeof operations[op] === "function") {
      return operations[op].apply(data, values);
    }else if(op.indexOf(".") > 0) { // Contains a dot, and not in the 0th position
      var sub_ops = String(op).split(".");
      var operation = operations;
      for(i = 0; i < sub_ops.length; i++) {
        // Descending into operations
        operation = operation[sub_ops[i]];
        if(operation === undefined) {
          throw new Error("Unrecognized operation " + op +
          " (failed at " + sub_ops.slice(0, i+1).join(".") + ")");
        }
      }

      return operation.apply(data, values);
    }

    throw new Error("Unrecognized operation " + op );
  };

  jsonLogic.uses_data = function(logic) {
    var collection = [];

    if( jsonLogic.is_logic(logic) ) {
      var op = jsonLogic.get_operator(logic);
      var values = logic[op];

      if( ! Array.isArray(values)) {
        values = [values];
      }

      if(op === "var") {
        // This doesn't cover the case where the arg to var is itself a rule.
        collection.push(values[0]);
      }else{
        // Recursion!
        values.map(function(val) {
          collection.push.apply(collection, jsonLogic.uses_data(val) );
        });
      }
    }

    return arrayUnique(collection);
  };

  jsonLogic.add_operation = function(name, code) {
    operations[name] = code;
  };


  jsonLogic.rule_like = function(rule, pattern){
		//console.log("Is ". JSON.stringify(rule) . " like " . JSON.stringify(pattern) . "?");
	  if(pattern === rule){ return true; } //TODO : Deep object equivalency?
	  if(pattern === "@"){ return true; } //Wildcard!
	  if(pattern === "number"){ return (typeof rule === 'number'); }
	  if(pattern === "string"){ return (typeof rule === 'string'); }
	  if(pattern === "array"){
      //!logic test might be superfluous in JavaScript
      return Array.isArray(rule) && ! jsonLogic.is_logic(rule);
    }

	  if(jsonLogic.is_logic(pattern)){
	    if(jsonLogic.is_logic(rule)){
	      var pattern_op = jsonLogic.get_operator(pattern);
        var rule_op = jsonLogic.get_operator(rule);

	      if(pattern_op === "@" || pattern_op === rule_op){
					//echo "\nOperators match, go deeper\n";
	        return jsonLogic.rule_like(
						jsonLogic.get_values(rule, false),
						jsonLogic.get_values(pattern, false)
					);
	      }

	    }
	    return false; //pattern is logic, rule isn't, can't be eq
	  }

	  if(Array.isArray(pattern)){
	    if(Array.isArray(rule)){
	      if(pattern.length !== rule.length){ return false; }
				/*
					Note, array order MATTERS, because we're using this array test logic to consider arguments, where order can matter. (e.g., + is commutative, but '-' or 'if' or 'var' are NOT)
				*/
	      for(var i = 0 ; i < pattern.length ; i += 1){
	        //If any fail, we fail
	        if( ! jsonLogic.rule_like(rule[i], pattern[i])){ return false; }
	      }
	      return true; //If they *all* passed, we pass
	    }else{
	      return false; //Pattern is array, rule isn't
	    }

	  }

		//Not logic, not array, not a === match for rule.
		return false;
	};



  return jsonLogic;
}));

},{}],12:[function(_dereq_,module,exports){
var getNative = _dereq_('./_getNative'),
    root = _dereq_('./_root');

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;

},{"./_getNative":95,"./_root":138}],13:[function(_dereq_,module,exports){
var hashClear = _dereq_('./_hashClear'),
    hashDelete = _dereq_('./_hashDelete'),
    hashGet = _dereq_('./_hashGet'),
    hashHas = _dereq_('./_hashHas'),
    hashSet = _dereq_('./_hashSet');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;

},{"./_hashClear":103,"./_hashDelete":104,"./_hashGet":105,"./_hashHas":106,"./_hashSet":107}],14:[function(_dereq_,module,exports){
var listCacheClear = _dereq_('./_listCacheClear'),
    listCacheDelete = _dereq_('./_listCacheDelete'),
    listCacheGet = _dereq_('./_listCacheGet'),
    listCacheHas = _dereq_('./_listCacheHas'),
    listCacheSet = _dereq_('./_listCacheSet');

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;

},{"./_listCacheClear":118,"./_listCacheDelete":119,"./_listCacheGet":120,"./_listCacheHas":121,"./_listCacheSet":122}],15:[function(_dereq_,module,exports){
var getNative = _dereq_('./_getNative'),
    root = _dereq_('./_root');

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;

},{"./_getNative":95,"./_root":138}],16:[function(_dereq_,module,exports){
var mapCacheClear = _dereq_('./_mapCacheClear'),
    mapCacheDelete = _dereq_('./_mapCacheDelete'),
    mapCacheGet = _dereq_('./_mapCacheGet'),
    mapCacheHas = _dereq_('./_mapCacheHas'),
    mapCacheSet = _dereq_('./_mapCacheSet');

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;

},{"./_mapCacheClear":123,"./_mapCacheDelete":124,"./_mapCacheGet":125,"./_mapCacheHas":126,"./_mapCacheSet":127}],17:[function(_dereq_,module,exports){
var getNative = _dereq_('./_getNative'),
    root = _dereq_('./_root');

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;

},{"./_getNative":95,"./_root":138}],18:[function(_dereq_,module,exports){
var getNative = _dereq_('./_getNative'),
    root = _dereq_('./_root');

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;

},{"./_getNative":95,"./_root":138}],19:[function(_dereq_,module,exports){
var MapCache = _dereq_('./_MapCache'),
    setCacheAdd = _dereq_('./_setCacheAdd'),
    setCacheHas = _dereq_('./_setCacheHas');

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;

},{"./_MapCache":16,"./_setCacheAdd":139,"./_setCacheHas":140}],20:[function(_dereq_,module,exports){
var ListCache = _dereq_('./_ListCache'),
    stackClear = _dereq_('./_stackClear'),
    stackDelete = _dereq_('./_stackDelete'),
    stackGet = _dereq_('./_stackGet'),
    stackHas = _dereq_('./_stackHas'),
    stackSet = _dereq_('./_stackSet');

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;

},{"./_ListCache":14,"./_stackClear":144,"./_stackDelete":145,"./_stackGet":146,"./_stackHas":147,"./_stackSet":148}],21:[function(_dereq_,module,exports){
var root = _dereq_('./_root');

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;

},{"./_root":138}],22:[function(_dereq_,module,exports){
var root = _dereq_('./_root');

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;

},{"./_root":138}],23:[function(_dereq_,module,exports){
var getNative = _dereq_('./_getNative'),
    root = _dereq_('./_root');

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;

},{"./_getNative":95,"./_root":138}],24:[function(_dereq_,module,exports){
/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */
function addMapEntry(map, pair) {
  // Don't return `map.set` because it's not chainable in IE 11.
  map.set(pair[0], pair[1]);
  return map;
}

module.exports = addMapEntry;

},{}],25:[function(_dereq_,module,exports){
/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */
function addSetEntry(set, value) {
  // Don't return `set.add` because it's not chainable in IE 11.
  set.add(value);
  return set;
}

module.exports = addSetEntry;

},{}],26:[function(_dereq_,module,exports){
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;

},{}],27:[function(_dereq_,module,exports){
/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;

},{}],28:[function(_dereq_,module,exports){
/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;

},{}],29:[function(_dereq_,module,exports){
var baseTimes = _dereq_('./_baseTimes'),
    isArguments = _dereq_('./isArguments'),
    isArray = _dereq_('./isArray'),
    isBuffer = _dereq_('./isBuffer'),
    isIndex = _dereq_('./_isIndex'),
    isTypedArray = _dereq_('./isTypedArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;

},{"./_baseTimes":65,"./_isIndex":111,"./isArguments":160,"./isArray":161,"./isBuffer":163,"./isTypedArray":170}],30:[function(_dereq_,module,exports){
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;

},{}],31:[function(_dereq_,module,exports){
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;

},{}],32:[function(_dereq_,module,exports){
/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

module.exports = arrayReduce;

},{}],33:[function(_dereq_,module,exports){
/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;

},{}],34:[function(_dereq_,module,exports){
var baseAssignValue = _dereq_('./_baseAssignValue'),
    eq = _dereq_('./eq');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;

},{"./_baseAssignValue":38,"./eq":155}],35:[function(_dereq_,module,exports){
var eq = _dereq_('./eq');

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;

},{"./eq":155}],36:[function(_dereq_,module,exports){
var copyObject = _dereq_('./_copyObject'),
    keys = _dereq_('./keys');

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;

},{"./_copyObject":79,"./keys":171}],37:[function(_dereq_,module,exports){
var copyObject = _dereq_('./_copyObject'),
    keysIn = _dereq_('./keysIn');

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;

},{"./_copyObject":79,"./keysIn":172}],38:[function(_dereq_,module,exports){
var defineProperty = _dereq_('./_defineProperty');

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;

},{"./_defineProperty":86}],39:[function(_dereq_,module,exports){
var Stack = _dereq_('./_Stack'),
    arrayEach = _dereq_('./_arrayEach'),
    assignValue = _dereq_('./_assignValue'),
    baseAssign = _dereq_('./_baseAssign'),
    baseAssignIn = _dereq_('./_baseAssignIn'),
    cloneBuffer = _dereq_('./_cloneBuffer'),
    copyArray = _dereq_('./_copyArray'),
    copySymbols = _dereq_('./_copySymbols'),
    copySymbolsIn = _dereq_('./_copySymbolsIn'),
    getAllKeys = _dereq_('./_getAllKeys'),
    getAllKeysIn = _dereq_('./_getAllKeysIn'),
    getTag = _dereq_('./_getTag'),
    initCloneArray = _dereq_('./_initCloneArray'),
    initCloneByTag = _dereq_('./_initCloneByTag'),
    initCloneObject = _dereq_('./_initCloneObject'),
    isArray = _dereq_('./isArray'),
    isBuffer = _dereq_('./isBuffer'),
    isObject = _dereq_('./isObject'),
    keys = _dereq_('./keys');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, baseClone, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;

},{"./_Stack":20,"./_arrayEach":27,"./_assignValue":34,"./_baseAssign":36,"./_baseAssignIn":37,"./_cloneBuffer":71,"./_copyArray":78,"./_copySymbols":80,"./_copySymbolsIn":81,"./_getAllKeys":91,"./_getAllKeysIn":92,"./_getTag":100,"./_initCloneArray":108,"./_initCloneByTag":109,"./_initCloneObject":110,"./isArray":161,"./isBuffer":163,"./isObject":167,"./keys":171}],40:[function(_dereq_,module,exports){
var isObject = _dereq_('./isObject');

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;

},{"./isObject":167}],41:[function(_dereq_,module,exports){
var baseForOwn = _dereq_('./_baseForOwn'),
    createBaseEach = _dereq_('./_createBaseEach');

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

module.exports = baseEach;

},{"./_baseForOwn":44,"./_createBaseEach":84}],42:[function(_dereq_,module,exports){
var baseEach = _dereq_('./_baseEach');

/**
 * The base implementation of `_.filter` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function baseFilter(collection, predicate) {
  var result = [];
  baseEach(collection, function(value, index, collection) {
    if (predicate(value, index, collection)) {
      result.push(value);
    }
  });
  return result;
}

module.exports = baseFilter;

},{"./_baseEach":41}],43:[function(_dereq_,module,exports){
var createBaseFor = _dereq_('./_createBaseFor');

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;

},{"./_createBaseFor":85}],44:[function(_dereq_,module,exports){
var baseFor = _dereq_('./_baseFor'),
    keys = _dereq_('./keys');

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;

},{"./_baseFor":43,"./keys":171}],45:[function(_dereq_,module,exports){
var castPath = _dereq_('./_castPath'),
    toKey = _dereq_('./_toKey');

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;

},{"./_castPath":69,"./_toKey":150}],46:[function(_dereq_,module,exports){
var arrayPush = _dereq_('./_arrayPush'),
    isArray = _dereq_('./isArray');

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;

},{"./_arrayPush":31,"./isArray":161}],47:[function(_dereq_,module,exports){
var Symbol = _dereq_('./_Symbol'),
    getRawTag = _dereq_('./_getRawTag'),
    objectToString = _dereq_('./_objectToString');

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;

},{"./_Symbol":21,"./_getRawTag":97,"./_objectToString":135}],48:[function(_dereq_,module,exports){
/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;

},{}],49:[function(_dereq_,module,exports){
var baseGetTag = _dereq_('./_baseGetTag'),
    isObjectLike = _dereq_('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

},{"./_baseGetTag":47,"./isObjectLike":168}],50:[function(_dereq_,module,exports){
var baseIsEqualDeep = _dereq_('./_baseIsEqualDeep'),
    isObjectLike = _dereq_('./isObjectLike');

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;

},{"./_baseIsEqualDeep":51,"./isObjectLike":168}],51:[function(_dereq_,module,exports){
var Stack = _dereq_('./_Stack'),
    equalArrays = _dereq_('./_equalArrays'),
    equalByTag = _dereq_('./_equalByTag'),
    equalObjects = _dereq_('./_equalObjects'),
    getTag = _dereq_('./_getTag'),
    isArray = _dereq_('./isArray'),
    isBuffer = _dereq_('./isBuffer'),
    isTypedArray = _dereq_('./isTypedArray');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;

},{"./_Stack":20,"./_equalArrays":87,"./_equalByTag":88,"./_equalObjects":89,"./_getTag":100,"./isArray":161,"./isBuffer":163,"./isTypedArray":170}],52:[function(_dereq_,module,exports){
var Stack = _dereq_('./_Stack'),
    baseIsEqual = _dereq_('./_baseIsEqual');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;

},{"./_Stack":20,"./_baseIsEqual":50}],53:[function(_dereq_,module,exports){
var isFunction = _dereq_('./isFunction'),
    isMasked = _dereq_('./_isMasked'),
    isObject = _dereq_('./isObject'),
    toSource = _dereq_('./_toSource');

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

},{"./_isMasked":115,"./_toSource":151,"./isFunction":165,"./isObject":167}],54:[function(_dereq_,module,exports){
var baseGetTag = _dereq_('./_baseGetTag'),
    isLength = _dereq_('./isLength'),
    isObjectLike = _dereq_('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

},{"./_baseGetTag":47,"./isLength":166,"./isObjectLike":168}],55:[function(_dereq_,module,exports){
var baseMatches = _dereq_('./_baseMatches'),
    baseMatchesProperty = _dereq_('./_baseMatchesProperty'),
    identity = _dereq_('./identity'),
    isArray = _dereq_('./isArray'),
    property = _dereq_('./property');

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;

},{"./_baseMatches":58,"./_baseMatchesProperty":59,"./identity":159,"./isArray":161,"./property":174}],56:[function(_dereq_,module,exports){
var isPrototype = _dereq_('./_isPrototype'),
    nativeKeys = _dereq_('./_nativeKeys');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;

},{"./_isPrototype":116,"./_nativeKeys":132}],57:[function(_dereq_,module,exports){
var isObject = _dereq_('./isObject'),
    isPrototype = _dereq_('./_isPrototype'),
    nativeKeysIn = _dereq_('./_nativeKeysIn');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;

},{"./_isPrototype":116,"./_nativeKeysIn":133,"./isObject":167}],58:[function(_dereq_,module,exports){
var baseIsMatch = _dereq_('./_baseIsMatch'),
    getMatchData = _dereq_('./_getMatchData'),
    matchesStrictComparable = _dereq_('./_matchesStrictComparable');

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;

},{"./_baseIsMatch":52,"./_getMatchData":94,"./_matchesStrictComparable":129}],59:[function(_dereq_,module,exports){
var baseIsEqual = _dereq_('./_baseIsEqual'),
    get = _dereq_('./get'),
    hasIn = _dereq_('./hasIn'),
    isKey = _dereq_('./_isKey'),
    isStrictComparable = _dereq_('./_isStrictComparable'),
    matchesStrictComparable = _dereq_('./_matchesStrictComparable'),
    toKey = _dereq_('./_toKey');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;

},{"./_baseIsEqual":50,"./_isKey":113,"./_isStrictComparable":117,"./_matchesStrictComparable":129,"./_toKey":150,"./get":157,"./hasIn":158}],60:[function(_dereq_,module,exports){
/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;

},{}],61:[function(_dereq_,module,exports){
var baseGet = _dereq_('./_baseGet');

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;

},{"./_baseGet":45}],62:[function(_dereq_,module,exports){
var identity = _dereq_('./identity'),
    overRest = _dereq_('./_overRest'),
    setToString = _dereq_('./_setToString');

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;

},{"./_overRest":137,"./_setToString":142,"./identity":159}],63:[function(_dereq_,module,exports){
var assignValue = _dereq_('./_assignValue'),
    castPath = _dereq_('./_castPath'),
    isIndex = _dereq_('./_isIndex'),
    isObject = _dereq_('./isObject'),
    toKey = _dereq_('./_toKey');

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject(objValue)
          ? objValue
          : (isIndex(path[index + 1]) ? [] : {});
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

module.exports = baseSet;

},{"./_assignValue":34,"./_castPath":69,"./_isIndex":111,"./_toKey":150,"./isObject":167}],64:[function(_dereq_,module,exports){
var constant = _dereq_('./constant'),
    defineProperty = _dereq_('./_defineProperty'),
    identity = _dereq_('./identity');

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;

},{"./_defineProperty":86,"./constant":154,"./identity":159}],65:[function(_dereq_,module,exports){
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;

},{}],66:[function(_dereq_,module,exports){
var Symbol = _dereq_('./_Symbol'),
    arrayMap = _dereq_('./_arrayMap'),
    isArray = _dereq_('./isArray'),
    isSymbol = _dereq_('./isSymbol');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;

},{"./_Symbol":21,"./_arrayMap":30,"./isArray":161,"./isSymbol":169}],67:[function(_dereq_,module,exports){
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;

},{}],68:[function(_dereq_,module,exports){
/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;

},{}],69:[function(_dereq_,module,exports){
var isArray = _dereq_('./isArray'),
    isKey = _dereq_('./_isKey'),
    stringToPath = _dereq_('./_stringToPath'),
    toString = _dereq_('./toString');

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;

},{"./_isKey":113,"./_stringToPath":149,"./isArray":161,"./toString":178}],70:[function(_dereq_,module,exports){
var Uint8Array = _dereq_('./_Uint8Array');

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;

},{"./_Uint8Array":22}],71:[function(_dereq_,module,exports){
var root = _dereq_('./_root');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

},{"./_root":138}],72:[function(_dereq_,module,exports){
var cloneArrayBuffer = _dereq_('./_cloneArrayBuffer');

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;

},{"./_cloneArrayBuffer":70}],73:[function(_dereq_,module,exports){
var addMapEntry = _dereq_('./_addMapEntry'),
    arrayReduce = _dereq_('./_arrayReduce'),
    mapToArray = _dereq_('./_mapToArray');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1;

/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */
function cloneMap(map, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(mapToArray(map), CLONE_DEEP_FLAG) : mapToArray(map);
  return arrayReduce(array, addMapEntry, new map.constructor);
}

module.exports = cloneMap;

},{"./_addMapEntry":24,"./_arrayReduce":32,"./_mapToArray":128}],74:[function(_dereq_,module,exports){
/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;

},{}],75:[function(_dereq_,module,exports){
var addSetEntry = _dereq_('./_addSetEntry'),
    arrayReduce = _dereq_('./_arrayReduce'),
    setToArray = _dereq_('./_setToArray');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1;

/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */
function cloneSet(set, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(setToArray(set), CLONE_DEEP_FLAG) : setToArray(set);
  return arrayReduce(array, addSetEntry, new set.constructor);
}

module.exports = cloneSet;

},{"./_addSetEntry":25,"./_arrayReduce":32,"./_setToArray":141}],76:[function(_dereq_,module,exports){
var Symbol = _dereq_('./_Symbol');

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;

},{"./_Symbol":21}],77:[function(_dereq_,module,exports){
var cloneArrayBuffer = _dereq_('./_cloneArrayBuffer');

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;

},{"./_cloneArrayBuffer":70}],78:[function(_dereq_,module,exports){
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;

},{}],79:[function(_dereq_,module,exports){
var assignValue = _dereq_('./_assignValue'),
    baseAssignValue = _dereq_('./_baseAssignValue');

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;

},{"./_assignValue":34,"./_baseAssignValue":38}],80:[function(_dereq_,module,exports){
var copyObject = _dereq_('./_copyObject'),
    getSymbols = _dereq_('./_getSymbols');

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;

},{"./_copyObject":79,"./_getSymbols":98}],81:[function(_dereq_,module,exports){
var copyObject = _dereq_('./_copyObject'),
    getSymbolsIn = _dereq_('./_getSymbolsIn');

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;

},{"./_copyObject":79,"./_getSymbolsIn":99}],82:[function(_dereq_,module,exports){
var root = _dereq_('./_root');

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;

},{"./_root":138}],83:[function(_dereq_,module,exports){
var baseRest = _dereq_('./_baseRest'),
    isIterateeCall = _dereq_('./_isIterateeCall');

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;

},{"./_baseRest":62,"./_isIterateeCall":112}],84:[function(_dereq_,module,exports){
var isArrayLike = _dereq_('./isArrayLike');

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

module.exports = createBaseEach;

},{"./isArrayLike":162}],85:[function(_dereq_,module,exports){
/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;

},{}],86:[function(_dereq_,module,exports){
var getNative = _dereq_('./_getNative');

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;

},{"./_getNative":95}],87:[function(_dereq_,module,exports){
var SetCache = _dereq_('./_SetCache'),
    arraySome = _dereq_('./_arraySome'),
    cacheHas = _dereq_('./_cacheHas');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;

},{"./_SetCache":19,"./_arraySome":33,"./_cacheHas":68}],88:[function(_dereq_,module,exports){
var Symbol = _dereq_('./_Symbol'),
    Uint8Array = _dereq_('./_Uint8Array'),
    eq = _dereq_('./eq'),
    equalArrays = _dereq_('./_equalArrays'),
    mapToArray = _dereq_('./_mapToArray'),
    setToArray = _dereq_('./_setToArray');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;

},{"./_Symbol":21,"./_Uint8Array":22,"./_equalArrays":87,"./_mapToArray":128,"./_setToArray":141,"./eq":155}],89:[function(_dereq_,module,exports){
var getAllKeys = _dereq_('./_getAllKeys');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;

},{"./_getAllKeys":91}],90:[function(_dereq_,module,exports){
(function (global){
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],91:[function(_dereq_,module,exports){
var baseGetAllKeys = _dereq_('./_baseGetAllKeys'),
    getSymbols = _dereq_('./_getSymbols'),
    keys = _dereq_('./keys');

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;

},{"./_baseGetAllKeys":46,"./_getSymbols":98,"./keys":171}],92:[function(_dereq_,module,exports){
var baseGetAllKeys = _dereq_('./_baseGetAllKeys'),
    getSymbolsIn = _dereq_('./_getSymbolsIn'),
    keysIn = _dereq_('./keysIn');

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;

},{"./_baseGetAllKeys":46,"./_getSymbolsIn":99,"./keysIn":172}],93:[function(_dereq_,module,exports){
var isKeyable = _dereq_('./_isKeyable');

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;

},{"./_isKeyable":114}],94:[function(_dereq_,module,exports){
var isStrictComparable = _dereq_('./_isStrictComparable'),
    keys = _dereq_('./keys');

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

module.exports = getMatchData;

},{"./_isStrictComparable":117,"./keys":171}],95:[function(_dereq_,module,exports){
var baseIsNative = _dereq_('./_baseIsNative'),
    getValue = _dereq_('./_getValue');

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

},{"./_baseIsNative":53,"./_getValue":101}],96:[function(_dereq_,module,exports){
var overArg = _dereq_('./_overArg');

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;

},{"./_overArg":136}],97:[function(_dereq_,module,exports){
var Symbol = _dereq_('./_Symbol');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;

},{"./_Symbol":21}],98:[function(_dereq_,module,exports){
var arrayFilter = _dereq_('./_arrayFilter'),
    stubArray = _dereq_('./stubArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;

},{"./_arrayFilter":28,"./stubArray":176}],99:[function(_dereq_,module,exports){
var arrayPush = _dereq_('./_arrayPush'),
    getPrototype = _dereq_('./_getPrototype'),
    getSymbols = _dereq_('./_getSymbols'),
    stubArray = _dereq_('./stubArray');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;

},{"./_arrayPush":31,"./_getPrototype":96,"./_getSymbols":98,"./stubArray":176}],100:[function(_dereq_,module,exports){
var DataView = _dereq_('./_DataView'),
    Map = _dereq_('./_Map'),
    Promise = _dereq_('./_Promise'),
    Set = _dereq_('./_Set'),
    WeakMap = _dereq_('./_WeakMap'),
    baseGetTag = _dereq_('./_baseGetTag'),
    toSource = _dereq_('./_toSource');

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;

},{"./_DataView":12,"./_Map":15,"./_Promise":17,"./_Set":18,"./_WeakMap":23,"./_baseGetTag":47,"./_toSource":151}],101:[function(_dereq_,module,exports){
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

},{}],102:[function(_dereq_,module,exports){
var castPath = _dereq_('./_castPath'),
    isArguments = _dereq_('./isArguments'),
    isArray = _dereq_('./isArray'),
    isIndex = _dereq_('./_isIndex'),
    isLength = _dereq_('./isLength'),
    toKey = _dereq_('./_toKey');

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;

},{"./_castPath":69,"./_isIndex":111,"./_toKey":150,"./isArguments":160,"./isArray":161,"./isLength":166}],103:[function(_dereq_,module,exports){
var nativeCreate = _dereq_('./_nativeCreate');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

},{"./_nativeCreate":131}],104:[function(_dereq_,module,exports){
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

},{}],105:[function(_dereq_,module,exports){
var nativeCreate = _dereq_('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

},{"./_nativeCreate":131}],106:[function(_dereq_,module,exports){
var nativeCreate = _dereq_('./_nativeCreate');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

},{"./_nativeCreate":131}],107:[function(_dereq_,module,exports){
var nativeCreate = _dereq_('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

},{"./_nativeCreate":131}],108:[function(_dereq_,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;

},{}],109:[function(_dereq_,module,exports){
var cloneArrayBuffer = _dereq_('./_cloneArrayBuffer'),
    cloneDataView = _dereq_('./_cloneDataView'),
    cloneMap = _dereq_('./_cloneMap'),
    cloneRegExp = _dereq_('./_cloneRegExp'),
    cloneSet = _dereq_('./_cloneSet'),
    cloneSymbol = _dereq_('./_cloneSymbol'),
    cloneTypedArray = _dereq_('./_cloneTypedArray');

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, cloneFunc, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return cloneMap(object, isDeep, cloneFunc);

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return cloneSet(object, isDeep, cloneFunc);

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;

},{"./_cloneArrayBuffer":70,"./_cloneDataView":72,"./_cloneMap":73,"./_cloneRegExp":74,"./_cloneSet":75,"./_cloneSymbol":76,"./_cloneTypedArray":77}],110:[function(_dereq_,module,exports){
var baseCreate = _dereq_('./_baseCreate'),
    getPrototype = _dereq_('./_getPrototype'),
    isPrototype = _dereq_('./_isPrototype');

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;

},{"./_baseCreate":40,"./_getPrototype":96,"./_isPrototype":116}],111:[function(_dereq_,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;

},{}],112:[function(_dereq_,module,exports){
var eq = _dereq_('./eq'),
    isArrayLike = _dereq_('./isArrayLike'),
    isIndex = _dereq_('./_isIndex'),
    isObject = _dereq_('./isObject');

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;

},{"./_isIndex":111,"./eq":155,"./isArrayLike":162,"./isObject":167}],113:[function(_dereq_,module,exports){
var isArray = _dereq_('./isArray'),
    isSymbol = _dereq_('./isSymbol');

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;

},{"./isArray":161,"./isSymbol":169}],114:[function(_dereq_,module,exports){
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;

},{}],115:[function(_dereq_,module,exports){
var coreJsData = _dereq_('./_coreJsData');

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;

},{"./_coreJsData":82}],116:[function(_dereq_,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;

},{}],117:[function(_dereq_,module,exports){
var isObject = _dereq_('./isObject');

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;

},{"./isObject":167}],118:[function(_dereq_,module,exports){
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

},{}],119:[function(_dereq_,module,exports){
var assocIndexOf = _dereq_('./_assocIndexOf');

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;

},{"./_assocIndexOf":35}],120:[function(_dereq_,module,exports){
var assocIndexOf = _dereq_('./_assocIndexOf');

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

},{"./_assocIndexOf":35}],121:[function(_dereq_,module,exports){
var assocIndexOf = _dereq_('./_assocIndexOf');

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

},{"./_assocIndexOf":35}],122:[function(_dereq_,module,exports){
var assocIndexOf = _dereq_('./_assocIndexOf');

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;

},{"./_assocIndexOf":35}],123:[function(_dereq_,module,exports){
var Hash = _dereq_('./_Hash'),
    ListCache = _dereq_('./_ListCache'),
    Map = _dereq_('./_Map');

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;

},{"./_Hash":13,"./_ListCache":14,"./_Map":15}],124:[function(_dereq_,module,exports){
var getMapData = _dereq_('./_getMapData');

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

},{"./_getMapData":93}],125:[function(_dereq_,module,exports){
var getMapData = _dereq_('./_getMapData');

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

},{"./_getMapData":93}],126:[function(_dereq_,module,exports){
var getMapData = _dereq_('./_getMapData');

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

},{"./_getMapData":93}],127:[function(_dereq_,module,exports){
var getMapData = _dereq_('./_getMapData');

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

},{"./_getMapData":93}],128:[function(_dereq_,module,exports){
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;

},{}],129:[function(_dereq_,module,exports){
/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

module.exports = matchesStrictComparable;

},{}],130:[function(_dereq_,module,exports){
var memoize = _dereq_('./memoize');

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;

},{"./memoize":173}],131:[function(_dereq_,module,exports){
var getNative = _dereq_('./_getNative');

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;

},{"./_getNative":95}],132:[function(_dereq_,module,exports){
var overArg = _dereq_('./_overArg');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;

},{"./_overArg":136}],133:[function(_dereq_,module,exports){
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;

},{}],134:[function(_dereq_,module,exports){
var freeGlobal = _dereq_('./_freeGlobal');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

},{"./_freeGlobal":90}],135:[function(_dereq_,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

},{}],136:[function(_dereq_,module,exports){
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

},{}],137:[function(_dereq_,module,exports){
var apply = _dereq_('./_apply');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;

},{"./_apply":26}],138:[function(_dereq_,module,exports){
var freeGlobal = _dereq_('./_freeGlobal');

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;

},{"./_freeGlobal":90}],139:[function(_dereq_,module,exports){
/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;

},{}],140:[function(_dereq_,module,exports){
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;

},{}],141:[function(_dereq_,module,exports){
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;

},{}],142:[function(_dereq_,module,exports){
var baseSetToString = _dereq_('./_baseSetToString'),
    shortOut = _dereq_('./_shortOut');

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;

},{"./_baseSetToString":64,"./_shortOut":143}],143:[function(_dereq_,module,exports){
/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;

},{}],144:[function(_dereq_,module,exports){
var ListCache = _dereq_('./_ListCache');

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;

},{"./_ListCache":14}],145:[function(_dereq_,module,exports){
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;

},{}],146:[function(_dereq_,module,exports){
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

},{}],147:[function(_dereq_,module,exports){
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

},{}],148:[function(_dereq_,module,exports){
var ListCache = _dereq_('./_ListCache'),
    Map = _dereq_('./_Map'),
    MapCache = _dereq_('./_MapCache');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

},{"./_ListCache":14,"./_Map":15,"./_MapCache":16}],149:[function(_dereq_,module,exports){
var memoizeCapped = _dereq_('./_memoizeCapped');

/** Used to match property names within property paths. */
var reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;

},{"./_memoizeCapped":130}],150:[function(_dereq_,module,exports){
var isSymbol = _dereq_('./isSymbol');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;

},{"./isSymbol":169}],151:[function(_dereq_,module,exports){
/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;

},{}],152:[function(_dereq_,module,exports){
var assignValue = _dereq_('./_assignValue'),
    copyObject = _dereq_('./_copyObject'),
    createAssigner = _dereq_('./_createAssigner'),
    isArrayLike = _dereq_('./isArrayLike'),
    isPrototype = _dereq_('./_isPrototype'),
    keys = _dereq_('./keys');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns own enumerable string keyed properties of source objects to the
 * destination object. Source objects are applied from left to right.
 * Subsequent sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object` and is loosely based on
 * [`Object.assign`](https://mdn.io/Object/assign).
 *
 * @static
 * @memberOf _
 * @since 0.10.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.assignIn
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * function Bar() {
 *   this.c = 3;
 * }
 *
 * Foo.prototype.b = 2;
 * Bar.prototype.d = 4;
 *
 * _.assign({ 'a': 0 }, new Foo, new Bar);
 * // => { 'a': 1, 'c': 3 }
 */
var assign = createAssigner(function(object, source) {
  if (isPrototype(source) || isArrayLike(source)) {
    copyObject(source, keys(source), object);
    return;
  }
  for (var key in source) {
    if (hasOwnProperty.call(source, key)) {
      assignValue(object, key, source[key]);
    }
  }
});

module.exports = assign;

},{"./_assignValue":34,"./_copyObject":79,"./_createAssigner":83,"./_isPrototype":116,"./isArrayLike":162,"./keys":171}],153:[function(_dereq_,module,exports){
var baseClone = _dereq_('./_baseClone');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;

},{"./_baseClone":39}],154:[function(_dereq_,module,exports){
/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;

},{}],155:[function(_dereq_,module,exports){
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;

},{}],156:[function(_dereq_,module,exports){
var arrayFilter = _dereq_('./_arrayFilter'),
    baseFilter = _dereq_('./_baseFilter'),
    baseIteratee = _dereq_('./_baseIteratee'),
    isArray = _dereq_('./isArray');

/**
 * Iterates over elements of `collection`, returning an array of all elements
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * **Note:** Unlike `_.remove`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 * @see _.reject
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': true },
 *   { 'user': 'fred',   'age': 40, 'active': false }
 * ];
 *
 * _.filter(users, function(o) { return !o.active; });
 * // => objects for ['fred']
 *
 * // The `_.matches` iteratee shorthand.
 * _.filter(users, { 'age': 36, 'active': true });
 * // => objects for ['barney']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.filter(users, ['active', false]);
 * // => objects for ['fred']
 *
 * // The `_.property` iteratee shorthand.
 * _.filter(users, 'active');
 * // => objects for ['barney']
 */
function filter(collection, predicate) {
  var func = isArray(collection) ? arrayFilter : baseFilter;
  return func(collection, baseIteratee(predicate, 3));
}

module.exports = filter;

},{"./_arrayFilter":28,"./_baseFilter":42,"./_baseIteratee":55,"./isArray":161}],157:[function(_dereq_,module,exports){
var baseGet = _dereq_('./_baseGet');

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;

},{"./_baseGet":45}],158:[function(_dereq_,module,exports){
var baseHasIn = _dereq_('./_baseHasIn'),
    hasPath = _dereq_('./_hasPath');

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;

},{"./_baseHasIn":48,"./_hasPath":102}],159:[function(_dereq_,module,exports){
/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

},{}],160:[function(_dereq_,module,exports){
var baseIsArguments = _dereq_('./_baseIsArguments'),
    isObjectLike = _dereq_('./isObjectLike');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;

},{"./_baseIsArguments":49,"./isObjectLike":168}],161:[function(_dereq_,module,exports){
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

},{}],162:[function(_dereq_,module,exports){
var isFunction = _dereq_('./isFunction'),
    isLength = _dereq_('./isLength');

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

},{"./isFunction":165,"./isLength":166}],163:[function(_dereq_,module,exports){
var root = _dereq_('./_root'),
    stubFalse = _dereq_('./stubFalse');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

},{"./_root":138,"./stubFalse":177}],164:[function(_dereq_,module,exports){
var baseIsEqual = _dereq_('./_baseIsEqual');

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

module.exports = isEqual;

},{"./_baseIsEqual":50}],165:[function(_dereq_,module,exports){
var baseGetTag = _dereq_('./_baseGetTag'),
    isObject = _dereq_('./isObject');

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

},{"./_baseGetTag":47,"./isObject":167}],166:[function(_dereq_,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

},{}],167:[function(_dereq_,module,exports){
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

},{}],168:[function(_dereq_,module,exports){
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],169:[function(_dereq_,module,exports){
var baseGetTag = _dereq_('./_baseGetTag'),
    isObjectLike = _dereq_('./isObjectLike');

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;

},{"./_baseGetTag":47,"./isObjectLike":168}],170:[function(_dereq_,module,exports){
var baseIsTypedArray = _dereq_('./_baseIsTypedArray'),
    baseUnary = _dereq_('./_baseUnary'),
    nodeUtil = _dereq_('./_nodeUtil');

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;

},{"./_baseIsTypedArray":54,"./_baseUnary":67,"./_nodeUtil":134}],171:[function(_dereq_,module,exports){
var arrayLikeKeys = _dereq_('./_arrayLikeKeys'),
    baseKeys = _dereq_('./_baseKeys'),
    isArrayLike = _dereq_('./isArrayLike');

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

},{"./_arrayLikeKeys":29,"./_baseKeys":56,"./isArrayLike":162}],172:[function(_dereq_,module,exports){
var arrayLikeKeys = _dereq_('./_arrayLikeKeys'),
    baseKeysIn = _dereq_('./_baseKeysIn'),
    isArrayLike = _dereq_('./isArrayLike');

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;

},{"./_arrayLikeKeys":29,"./_baseKeysIn":57,"./isArrayLike":162}],173:[function(_dereq_,module,exports){
var MapCache = _dereq_('./_MapCache');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;

},{"./_MapCache":16}],174:[function(_dereq_,module,exports){
var baseProperty = _dereq_('./_baseProperty'),
    basePropertyDeep = _dereq_('./_basePropertyDeep'),
    isKey = _dereq_('./_isKey'),
    toKey = _dereq_('./_toKey');

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;

},{"./_baseProperty":60,"./_basePropertyDeep":61,"./_isKey":113,"./_toKey":150}],175:[function(_dereq_,module,exports){
var baseSet = _dereq_('./_baseSet');

/**
 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
 * it's created. Arrays are created for missing index properties while objects
 * are created for all other missing properties. Use `_.setWith` to customize
 * `path` creation.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.set(object, 'a[0].b.c', 4);
 * console.log(object.a[0].b.c);
 * // => 4
 *
 * _.set(object, ['x', '0', 'y', 'z'], 5);
 * console.log(object.x[0].y.z);
 * // => 5
 */
function set(object, path, value) {
  return object == null ? object : baseSet(object, path, value);
}

module.exports = set;

},{"./_baseSet":63}],176:[function(_dereq_,module,exports){
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;

},{}],177:[function(_dereq_,module,exports){
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

},{}],178:[function(_dereq_,module,exports){
var baseToString = _dereq_('./_baseToString');

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;

},{"./_baseToString":66}],179:[function(_dereq_,module,exports){
(function (global){
/*! Native Promise Only
    v0.8.1 (c) Kyle Simpson
    MIT License: http://getify.mit-license.org
*/

(function UMD(name,context,definition){
	// special form of UMD for polyfilling across evironments
	context[name] = context[name] || definition();
	if (typeof module != "undefined" && module.exports) { module.exports = context[name]; }
	else if (typeof define == "function" && define.amd) { define(function $AMD$(){ return context[name]; }); }
})("Promise",typeof global != "undefined" ? global : this,function DEF(){
	/*jshint validthis:true */
	"use strict";

	var builtInProp, cycle, scheduling_queue,
		ToString = Object.prototype.toString,
		timer = (typeof setImmediate != "undefined") ?
			function timer(fn) { return setImmediate(fn); } :
			setTimeout
	;

	// dammit, IE8.
	try {
		Object.defineProperty({},"x",{});
		builtInProp = function builtInProp(obj,name,val,config) {
			return Object.defineProperty(obj,name,{
				value: val,
				writable: true,
				configurable: config !== false
			});
		};
	}
	catch (err) {
		builtInProp = function builtInProp(obj,name,val) {
			obj[name] = val;
			return obj;
		};
	}

	// Note: using a queue instead of array for efficiency
	scheduling_queue = (function Queue() {
		var first, last, item;

		function Item(fn,self) {
			this.fn = fn;
			this.self = self;
			this.next = void 0;
		}

		return {
			add: function add(fn,self) {
				item = new Item(fn,self);
				if (last) {
					last.next = item;
				}
				else {
					first = item;
				}
				last = item;
				item = void 0;
			},
			drain: function drain() {
				var f = first;
				first = last = cycle = void 0;

				while (f) {
					f.fn.call(f.self);
					f = f.next;
				}
			}
		};
	})();

	function schedule(fn,self) {
		scheduling_queue.add(fn,self);
		if (!cycle) {
			cycle = timer(scheduling_queue.drain);
		}
	}

	// promise duck typing
	function isThenable(o) {
		var _then, o_type = typeof o;

		if (o != null &&
			(
				o_type == "object" || o_type == "function"
			)
		) {
			_then = o.then;
		}
		return typeof _then == "function" ? _then : false;
	}

	function notify() {
		for (var i=0; i<this.chain.length; i++) {
			notifyIsolated(
				this,
				(this.state === 1) ? this.chain[i].success : this.chain[i].failure,
				this.chain[i]
			);
		}
		this.chain.length = 0;
	}

	// NOTE: This is a separate function to isolate
	// the `try..catch` so that other code can be
	// optimized better
	function notifyIsolated(self,cb,chain) {
		var ret, _then;
		try {
			if (cb === false) {
				chain.reject(self.msg);
			}
			else {
				if (cb === true) {
					ret = self.msg;
				}
				else {
					ret = cb.call(void 0,self.msg);
				}

				if (ret === chain.promise) {
					chain.reject(TypeError("Promise-chain cycle"));
				}
				else if (_then = isThenable(ret)) {
					_then.call(ret,chain.resolve,chain.reject);
				}
				else {
					chain.resolve(ret);
				}
			}
		}
		catch (err) {
			chain.reject(err);
		}
	}

	function resolve(msg) {
		var _then, self = this;

		// already triggered?
		if (self.triggered) { return; }

		self.triggered = true;

		// unwrap
		if (self.def) {
			self = self.def;
		}

		try {
			if (_then = isThenable(msg)) {
				schedule(function(){
					var def_wrapper = new MakeDefWrapper(self);
					try {
						_then.call(msg,
							function $resolve$(){ resolve.apply(def_wrapper,arguments); },
							function $reject$(){ reject.apply(def_wrapper,arguments); }
						);
					}
					catch (err) {
						reject.call(def_wrapper,err);
					}
				})
			}
			else {
				self.msg = msg;
				self.state = 1;
				if (self.chain.length > 0) {
					schedule(notify,self);
				}
			}
		}
		catch (err) {
			reject.call(new MakeDefWrapper(self),err);
		}
	}

	function reject(msg) {
		var self = this;

		// already triggered?
		if (self.triggered) { return; }

		self.triggered = true;

		// unwrap
		if (self.def) {
			self = self.def;
		}

		self.msg = msg;
		self.state = 2;
		if (self.chain.length > 0) {
			schedule(notify,self);
		}
	}

	function iteratePromises(Constructor,arr,resolver,rejecter) {
		for (var idx=0; idx<arr.length; idx++) {
			(function IIFE(idx){
				Constructor.resolve(arr[idx])
				.then(
					function $resolver$(msg){
						resolver(idx,msg);
					},
					rejecter
				);
			})(idx);
		}
	}

	function MakeDefWrapper(self) {
		this.def = self;
		this.triggered = false;
	}

	function MakeDef(self) {
		this.promise = self;
		this.state = 0;
		this.triggered = false;
		this.chain = [];
		this.msg = void 0;
	}

	function Promise(executor) {
		if (typeof executor != "function") {
			throw TypeError("Not a function");
		}

		if (this.__NPO__ !== 0) {
			throw TypeError("Not a promise");
		}

		// instance shadowing the inherited "brand"
		// to signal an already "initialized" promise
		this.__NPO__ = 1;

		var def = new MakeDef(this);

		this["then"] = function then(success,failure) {
			var o = {
				success: typeof success == "function" ? success : true,
				failure: typeof failure == "function" ? failure : false
			};
			// Note: `then(..)` itself can be borrowed to be used against
			// a different promise constructor for making the chained promise,
			// by substituting a different `this` binding.
			o.promise = new this.constructor(function extractChain(resolve,reject) {
				if (typeof resolve != "function" || typeof reject != "function") {
					throw TypeError("Not a function");
				}

				o.resolve = resolve;
				o.reject = reject;
			});
			def.chain.push(o);

			if (def.state !== 0) {
				schedule(notify,def);
			}

			return o.promise;
		};
		this["catch"] = function $catch$(failure) {
			return this.then(void 0,failure);
		};

		try {
			executor.call(
				void 0,
				function publicResolve(msg){
					resolve.call(def,msg);
				},
				function publicReject(msg) {
					reject.call(def,msg);
				}
			);
		}
		catch (err) {
			reject.call(def,err);
		}
	}

	var PromisePrototype = builtInProp({},"constructor",Promise,
		/*configurable=*/false
	);

	// Note: Android 4 cannot use `Object.defineProperty(..)` here
	Promise.prototype = PromisePrototype;

	// built-in "brand" to signal an "uninitialized" promise
	builtInProp(PromisePrototype,"__NPO__",0,
		/*configurable=*/false
	);

	builtInProp(Promise,"resolve",function Promise$resolve(msg) {
		var Constructor = this;

		// spec mandated checks
		// note: best "isPromise" check that's practical for now
		if (msg && typeof msg == "object" && msg.__NPO__ === 1) {
			return msg;
		}

		return new Constructor(function executor(resolve,reject){
			if (typeof resolve != "function" || typeof reject != "function") {
				throw TypeError("Not a function");
			}

			resolve(msg);
		});
	});

	builtInProp(Promise,"reject",function Promise$reject(msg) {
		return new this(function executor(resolve,reject){
			if (typeof resolve != "function" || typeof reject != "function") {
				throw TypeError("Not a function");
			}

			reject(msg);
		});
	});

	builtInProp(Promise,"all",function Promise$all(arr) {
		var Constructor = this;

		// spec mandated checks
		if (ToString.call(arr) != "[object Array]") {
			return Constructor.reject(TypeError("Not an array"));
		}
		if (arr.length === 0) {
			return Constructor.resolve([]);
		}

		return new Constructor(function executor(resolve,reject){
			if (typeof resolve != "function" || typeof reject != "function") {
				throw TypeError("Not a function");
			}

			var len = arr.length, msgs = Array(len), count = 0;

			iteratePromises(Constructor,arr,function resolver(idx,msg) {
				msgs[idx] = msg;
				if (++count === len) {
					resolve(msgs);
				}
			},reject);
		});
	});

	builtInProp(Promise,"race",function Promise$race(arr) {
		var Constructor = this;

		// spec mandated checks
		if (ToString.call(arr) != "[object Array]") {
			return Constructor.reject(TypeError("Not an array"));
		}

		return new Constructor(function executor(resolve,reject){
			if (typeof resolve != "function" || typeof reject != "function") {
				throw TypeError("Not a function");
			}

			iteratePromises(Constructor,arr,function resolver(idx,msg){
				resolve(msg);
			},reject);
		});
	});

	return Promise;
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],180:[function(_dereq_,module,exports){
module.exports = function (obj) {
    if (!obj || typeof obj !== 'object') return obj;
    
    var copy;
    
    if (isArray(obj)) {
        var len = obj.length;
        copy = Array(len);
        for (var i = 0; i < len; i++) {
            copy[i] = obj[i];
        }
    }
    else {
        var keys = objectKeys(obj);
        copy = {};
        
        for (var i = 0, l = keys.length; i < l; i++) {
            var key = keys[i];
            copy[key] = obj[key];
        }
    }
    return copy;
};

var objectKeys = Object.keys || function (obj) {
    var keys = [];
    for (var key in obj) {
        if ({}.hasOwnProperty.call(obj, key)) keys.push(key);
    }
    return keys;
};

var isArray = Array.isArray || function (xs) {
    return {}.toString.call(xs) === '[object Array]';
};

},{}],181:[function(_dereq_,module,exports){
/*!
 * Signature Pad v1.6.0
 * https://github.com/szimek/signature_pad
 *
 * Copyright 2017 Szymon Nowak
 * Released under the MIT license
 *
 * The main idea and some parts of the code (e.g. drawing variable width Bzier curve) are taken from:
 * http://corner.squareup.com/2012/07/smoother-signatures.html
 *
 * Implementation of interpolation using cubic Bzier curves is taken from:
 * http://benknowscode.wordpress.com/2012/09/14/path-interpolation-using-cubic-bezier-and-control-point-estimation-in-javascript
 *
 * Algorithm for approximated length of a Bzier curve is taken from:
 * http://www.lemoda.net/maths/bezier-length/index.html
 *
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.SignaturePad = factory());
}(this, (function () { 'use strict';

function Point(x, y, time) {
  this.x = x;
  this.y = y;
  this.time = time || new Date().getTime();
}

Point.prototype.velocityFrom = function (start) {
  return this.time !== start.time ? this.distanceTo(start) / (this.time - start.time) : 1;
};

Point.prototype.distanceTo = function (start) {
  return Math.sqrt(Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2));
};

function Bezier(startPoint, control1, control2, endPoint) {
  this.startPoint = startPoint;
  this.control1 = control1;
  this.control2 = control2;
  this.endPoint = endPoint;
}

// Returns approximated length.
Bezier.prototype.length = function () {
  var steps = 10;
  var length = 0;
  var px = void 0;
  var py = void 0;

  for (var i = 0; i <= steps; i += 1) {
    var t = i / steps;
    var cx = this._point(t, this.startPoint.x, this.control1.x, this.control2.x, this.endPoint.x);
    var cy = this._point(t, this.startPoint.y, this.control1.y, this.control2.y, this.endPoint.y);
    if (i > 0) {
      var xdiff = cx - px;
      var ydiff = cy - py;
      length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);
    }
    px = cx;
    py = cy;
  }

  return length;
};

/* eslint-disable no-multi-spaces, space-in-parens */
Bezier.prototype._point = function (t, start, c1, c2, end) {
  return start * (1.0 - t) * (1.0 - t) * (1.0 - t) + 3.0 * c1 * (1.0 - t) * (1.0 - t) * t + 3.0 * c2 * (1.0 - t) * t * t + end * t * t * t;
};

function SignaturePad(canvas, options) {
  var self = this;
  var opts = options || {};

  this.velocityFilterWeight = opts.velocityFilterWeight || 0.7;
  this.minWidth = opts.minWidth || 0.5;
  this.maxWidth = opts.maxWidth || 2.5;
  this.dotSize = opts.dotSize || function () {
    return (this.minWidth + this.maxWidth) / 2;
  };
  this.penColor = opts.penColor || 'black';
  this.backgroundColor = opts.backgroundColor || 'rgba(0,0,0,0)';
  this.onBegin = opts.onBegin;
  this.onEnd = opts.onEnd;

  this._canvas = canvas;
  this._ctx = canvas.getContext('2d');
  this.clear();

  // We need add these inline so they are available to unbind while still having
  // access to 'self' we could use _.bind but it's not worth adding a dependency.
  this._handleMouseDown = function (event) {
    if (event.which === 1) {
      self._mouseButtonDown = true;
      self._strokeBegin(event);
    }
  };

  this._handleMouseMove = function (event) {
    if (self._mouseButtonDown) {
      self._strokeUpdate(event);
    }
  };

  this._handleMouseUp = function (event) {
    if (event.which === 1 && self._mouseButtonDown) {
      self._mouseButtonDown = false;
      self._strokeEnd(event);
    }
  };

  this._handleTouchStart = function (event) {
    if (event.targetTouches.length === 1) {
      var touch = event.changedTouches[0];
      self._strokeBegin(touch);
    }
  };

  this._handleTouchMove = function (event) {
    // Prevent scrolling.
    event.preventDefault();

    var touch = event.targetTouches[0];
    self._strokeUpdate(touch);
  };

  this._handleTouchEnd = function (event) {
    var wasCanvasTouched = event.target === self._canvas;
    if (wasCanvasTouched) {
      event.preventDefault();
      self._strokeEnd(event);
    }
  };

  // Enable mouse and touch event handlers
  this.on();
}

// Public methods
SignaturePad.prototype.clear = function () {
  var ctx = this._ctx;
  var canvas = this._canvas;

  ctx.fillStyle = this.backgroundColor;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  this._data = [];
  this._reset();
  this._isEmpty = true;
};

SignaturePad.prototype.fromDataURL = function (dataUrl) {
  var _this = this;

  var image = new Image();
  var ratio = window.devicePixelRatio || 1;
  var width = this._canvas.width / ratio;
  var height = this._canvas.height / ratio;

  this._reset();
  image.src = dataUrl;
  image.onload = function () {
    _this._ctx.drawImage(image, 0, 0, width, height);
  };
  this._isEmpty = false;
};

SignaturePad.prototype.toDataURL = function (type) {
  var _canvas;

  switch (type) {
    case 'image/svg+xml':
      return this._toSVG();
    default:
      for (var _len = arguments.length, options = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        options[_key - 1] = arguments[_key];
      }

      return (_canvas = this._canvas).toDataURL.apply(_canvas, [type].concat(options));
  }
};

SignaturePad.prototype.on = function () {
  this._handleMouseEvents();
  this._handleTouchEvents();
};

SignaturePad.prototype.off = function () {
  this._canvas.removeEventListener('mousedown', this._handleMouseDown);
  this._canvas.removeEventListener('mousemove', this._handleMouseMove);
  document.removeEventListener('mouseup', this._handleMouseUp);

  this._canvas.removeEventListener('touchstart', this._handleTouchStart);
  this._canvas.removeEventListener('touchmove', this._handleTouchMove);
  this._canvas.removeEventListener('touchend', this._handleTouchEnd);
};

SignaturePad.prototype.isEmpty = function () {
  return this._isEmpty;
};

// Private methods
SignaturePad.prototype._strokeBegin = function (event) {
  this._data.push([]);
  this._reset();
  this._strokeUpdate(event);

  if (typeof this.onBegin === 'function') {
    this.onBegin(event);
  }
};

SignaturePad.prototype._strokeUpdate = function (event) {
  var x = event.clientX;
  var y = event.clientY;

  var point = this._createPoint(x, y);

  var _addPoint = this._addPoint(point),
      curve = _addPoint.curve,
      widths = _addPoint.widths;

  if (curve && widths) {
    this._drawCurve(curve, widths.start, widths.end);
  }

  this._data[this._data.length - 1].push({
    x: point.x,
    y: point.y,
    time: point.time
  });
};

SignaturePad.prototype._strokeEnd = function (event) {
  var canDrawCurve = this.points.length > 2;
  var point = this.points[0];

  if (!canDrawCurve && point) {
    this._drawDot(point);
  }

  if (typeof this.onEnd === 'function') {
    this.onEnd(event);
  }
};

SignaturePad.prototype._handleMouseEvents = function () {
  this._mouseButtonDown = false;

  this._canvas.addEventListener('mousedown', this._handleMouseDown);
  this._canvas.addEventListener('mousemove', this._handleMouseMove);
  document.addEventListener('mouseup', this._handleMouseUp);
};

SignaturePad.prototype._handleTouchEvents = function () {
  // Pass touch events to canvas element on mobile IE11 and Edge.
  this._canvas.style.msTouchAction = 'none';
  this._canvas.style.touchAction = 'none';

  this._canvas.addEventListener('touchstart', this._handleTouchStart);
  this._canvas.addEventListener('touchmove', this._handleTouchMove);
  this._canvas.addEventListener('touchend', this._handleTouchEnd);
};

SignaturePad.prototype._reset = function () {
  this.points = [];
  this._lastVelocity = 0;
  this._lastWidth = (this.minWidth + this.maxWidth) / 2;
  this._ctx.fillStyle = this.penColor;
};

SignaturePad.prototype._createPoint = function (x, y, time) {
  var rect = this._canvas.getBoundingClientRect();

  return new Point(x - rect.left, y - rect.top, time || new Date().getTime());
};

SignaturePad.prototype._addPoint = function (point) {
  var points = this.points;
  var tmp = void 0;

  points.push(point);

  if (points.length > 2) {
    // To reduce the initial lag make it work with 3 points
    // by copying the first point to the beginning.
    if (points.length === 3) points.unshift(points[0]);

    tmp = this._calculateCurveControlPoints(points[0], points[1], points[2]);
    var c2 = tmp.c2;
    tmp = this._calculateCurveControlPoints(points[1], points[2], points[3]);
    var c3 = tmp.c1;
    var curve = new Bezier(points[1], c2, c3, points[2]);
    var widths = this._calculateCurveWidths(curve);

    // Remove the first element from the list,
    // so that we always have no more than 4 points in points array.
    points.shift();

    return { curve: curve, widths: widths };
  }

  return {};
};

SignaturePad.prototype._calculateCurveControlPoints = function (s1, s2, s3) {
  var dx1 = s1.x - s2.x;
  var dy1 = s1.y - s2.y;
  var dx2 = s2.x - s3.x;
  var dy2 = s2.y - s3.y;

  var m1 = { x: (s1.x + s2.x) / 2.0, y: (s1.y + s2.y) / 2.0 };
  var m2 = { x: (s2.x + s3.x) / 2.0, y: (s2.y + s3.y) / 2.0 };

  var l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
  var l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);

  var dxm = m1.x - m2.x;
  var dym = m1.y - m2.y;

  var k = l2 / (l1 + l2);
  var cm = { x: m2.x + dxm * k, y: m2.y + dym * k };

  var tx = s2.x - cm.x;
  var ty = s2.y - cm.y;

  return {
    c1: new Point(m1.x + tx, m1.y + ty),
    c2: new Point(m2.x + tx, m2.y + ty)
  };
};

SignaturePad.prototype._calculateCurveWidths = function (curve) {
  var startPoint = curve.startPoint;
  var endPoint = curve.endPoint;
  var widths = { start: null, end: null };

  var velocity = this.velocityFilterWeight * endPoint.velocityFrom(startPoint) + (1 - this.velocityFilterWeight) * this._lastVelocity;

  var newWidth = this._strokeWidth(velocity);

  widths.start = this._lastWidth;
  widths.end = newWidth;

  this._lastVelocity = velocity;
  this._lastWidth = newWidth;

  return widths;
};

SignaturePad.prototype._strokeWidth = function (velocity) {
  return Math.max(this.maxWidth / (velocity + 1), this.minWidth);
};

SignaturePad.prototype._drawPoint = function (x, y, size) {
  var ctx = this._ctx;

  ctx.moveTo(x, y);
  ctx.arc(x, y, size, 0, 2 * Math.PI, false);
  this._isEmpty = false;
};

SignaturePad.prototype._drawCurve = function (curve, startWidth, endWidth) {
  var ctx = this._ctx;
  var widthDelta = endWidth - startWidth;
  var drawSteps = Math.floor(curve.length());

  ctx.beginPath();

  for (var i = 0; i < drawSteps; i += 1) {
    // Calculate the Bezier (x, y) coordinate for this step.
    var t = i / drawSteps;
    var tt = t * t;
    var ttt = tt * t;
    var u = 1 - t;
    var uu = u * u;
    var uuu = uu * u;

    var x = uuu * curve.startPoint.x;
    x += 3 * uu * t * curve.control1.x;
    x += 3 * u * tt * curve.control2.x;
    x += ttt * curve.endPoint.x;

    var y = uuu * curve.startPoint.y;
    y += 3 * uu * t * curve.control1.y;
    y += 3 * u * tt * curve.control2.y;
    y += ttt * curve.endPoint.y;

    var width = startWidth + ttt * widthDelta;
    this._drawPoint(x, y, width);
  }

  ctx.closePath();
  ctx.fill();
};

SignaturePad.prototype._drawDot = function (point) {
  var ctx = this._ctx;
  var width = typeof this.dotSize === 'function' ? this.dotSize() : this.dotSize;

  ctx.beginPath();
  this._drawPoint(point.x, point.y, width);
  ctx.closePath();
  ctx.fill();
};

SignaturePad.prototype._fromData = function (pointGroups, drawCurve, drawDot) {
  for (var i = 0; i < pointGroups.length; i += 1) {
    var group = pointGroups[i];

    if (group.length > 1) {
      for (var j = 0; j < group.length; j += 1) {
        var rawPoint = group[j];
        var point = new Point(rawPoint.x, rawPoint.y, rawPoint.time);

        if (j === 0) {
          // First point in a group. Nothing to draw yet.
          this._reset();
          this._addPoint(point);
        } else if (j !== group.length - 1) {
          // Middle point in a group.
          var _addPoint2 = this._addPoint(point),
              curve = _addPoint2.curve,
              widths = _addPoint2.widths;

          if (curve && widths) {
            drawCurve(curve, widths);
          }
        } else {
          // Last point in a group. Do nothing.
        }
      }
    } else {
      this._reset();
      var _rawPoint = group[0];
      drawDot(_rawPoint);
    }
  }
};

SignaturePad.prototype._toSVG = function () {
  var _this2 = this;

  var pointGroups = this._data;
  var canvas = this._canvas;
  var ratio = Math.max(window.devicePixelRatio || 1, 1);
  var minX = 0;
  var minY = 0;
  var maxX = canvas.width / ratio;
  var maxY = canvas.height / ratio;
  var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');

  svg.setAttributeNS(null, 'width', canvas.width);
  svg.setAttributeNS(null, 'height', canvas.height);

  this._fromData(pointGroups, function (curve, widths) {
    var path = document.createElement('path');

    // Need to check curve for NaN values, these pop up when drawing
    // lines on the canvas that are not continuous. E.g. Sharp corners
    // or stopping mid-stroke and than continuing without lifting mouse.
    if (!isNaN(curve.control1.x) && !isNaN(curve.control1.y) && !isNaN(curve.control2.x) && !isNaN(curve.control2.y)) {
      var attr = 'M ' + curve.startPoint.x.toFixed(3) + ',' + curve.startPoint.y.toFixed(3) + ' ' + ('C ' + curve.control1.x.toFixed(3) + ',' + curve.control1.y.toFixed(3) + ' ') + (curve.control2.x.toFixed(3) + ',' + curve.control2.y.toFixed(3) + ' ') + (curve.endPoint.x.toFixed(3) + ',' + curve.endPoint.y.toFixed(3));

      path.setAttribute('d', attr);
      path.setAttribute('stroke-width', (widths.end * 2.25).toFixed(3));
      path.setAttribute('stroke', _this2.penColor);
      path.setAttribute('fill', 'none');
      path.setAttribute('stroke-linecap', 'round');

      svg.appendChild(path);
    }
  }, function (rawPoint) {
    var circle = document.createElement('circle');
    var dotSize = typeof _this2.dotSize === 'function' ? _this2.dotSize() : _this2.dotSize;
    circle.setAttribute('r', dotSize);
    circle.setAttribute('cx', rawPoint.x);
    circle.setAttribute('cy', rawPoint.y);
    circle.setAttribute('fill', _this2.penColor);

    svg.appendChild(circle);
  });

  var prefix = 'data:image/svg+xml;base64,';
  var header = '<svg' + ' xmlns="http://www.w3.org/2000/svg"' + ' xmlns:xlink="http://www.w3.org/1999/xlink"' + (' viewBox="' + minX + ' ' + minY + ' ' + maxX + ' ' + maxY + '"') + (' width="' + maxX + '"') + (' height="' + maxY + '"') + '>';
  var body = svg.innerHTML;

  // IE hack for missing innerHTML property on SVGElement
  if (body === undefined) {
    var dummy = document.createElement('dummy');
    var nodes = svg.childNodes;
    dummy.innerHTML = '';

    for (var i = 0; i < nodes.length; i += 1) {
      dummy.appendChild(nodes[i].cloneNode(true));
    }

    body = dummy.innerHTML;
  }

  var footer = '</svg>';
  var data = header + body + footer;

  return prefix + btoa(data);
};

SignaturePad.prototype.fromData = function (pointGroups) {
  var _this3 = this;

  this.clear();

  this._fromData(pointGroups, function (curve, widths) {
    return _this3._drawCurve(curve, widths.start, widths.end);
  }, function (rawPoint) {
    return _this3._drawDot(rawPoint);
  });
};

SignaturePad.prototype.toData = function () {
  return this._data;
};

return SignaturePad;

})));

},{}],182:[function(_dereq_,module,exports){
(function(self) {
  'use strict';

  if (self.fetch) {
    return
  }

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob()
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ]

    var isDataView = function(obj) {
      return obj && DataView.prototype.isPrototypeOf(obj)
    }

    var isArrayBufferView = ArrayBuffer.isView || function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    }
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name)
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value)
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift()
        return {done: value === undefined, value: value}
      }
    }

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      }
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {}

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value)
      }, this)
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1])
      }, this)
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name])
      }, this)
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name)
    value = normalizeValue(value)
    var oldValue = this.map[name]
    this.map[name] = oldValue ? oldValue+','+value : value
  }

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)]
  }

  Headers.prototype.get = function(name) {
    name = normalizeName(name)
    return this.has(name) ? this.map[name] : null
  }

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  }

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value)
  }

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this)
      }
    }
  }

  Headers.prototype.keys = function() {
    var items = []
    this.forEach(function(value, name) { items.push(name) })
    return iteratorFor(items)
  }

  Headers.prototype.values = function() {
    var items = []
    this.forEach(function(value) { items.push(value) })
    return iteratorFor(items)
  }

  Headers.prototype.entries = function() {
    var items = []
    this.forEach(function(value, name) { items.push([name, value]) })
    return iteratorFor(items)
  }

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result)
      }
      reader.onerror = function() {
        reject(reader.error)
      }
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader()
    var promise = fileReaderReady(reader)
    reader.readAsArrayBuffer(blob)
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader()
    var promise = fileReaderReady(reader)
    reader.readAsText(blob)
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf)
    var chars = new Array(view.length)

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i])
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength)
      view.set(new Uint8Array(buf))
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false

    this._initBody = function(body) {
      this._bodyInit = body
      if (!body) {
        this._bodyText = ''
      } else if (typeof body === 'string') {
        this._bodyText = body
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString()
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer)
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer])
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body)
      } else {
        throw new Error('unsupported BodyInit type')
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8')
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type)
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
        }
      }
    }

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      }

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      }
    }

    this.text = function() {
      var rejected = consumed(this)
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    }

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      }
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    }

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

  function normalizeMethod(method) {
    var upcased = method.toUpperCase()
    return (methods.indexOf(upcased) > -1) ? upcased : method
  }

  function Request(input, options) {
    options = options || {}
    var body = options.body

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url
      this.credentials = input.credentials
      if (!options.headers) {
        this.headers = new Headers(input.headers)
      }
      this.method = input.method
      this.mode = input.mode
      if (!body && input._bodyInit != null) {
        body = input._bodyInit
        input.bodyUsed = true
      }
    } else {
      this.url = String(input)
    }

    this.credentials = options.credentials || this.credentials || 'omit'
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers)
    }
    this.method = normalizeMethod(options.method || this.method || 'GET')
    this.mode = options.mode || this.mode || null
    this.referrer = null

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body)
  }

  Request.prototype.clone = function() {
    return new Request(this, { body: this._bodyInit })
  }

  function decode(body) {
    var form = new FormData()
    body.trim().split('&').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers()
    rawHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':')
      var key = parts.shift().trim()
      if (key) {
        var value = parts.join(':').trim()
        headers.append(key, value)
      }
    })
    return headers
  }

  Body.call(Request.prototype)

  function Response(bodyInit, options) {
    if (!options) {
      options = {}
    }

    this.type = 'default'
    this.status = 'status' in options ? options.status : 200
    this.ok = this.status >= 200 && this.status < 300
    this.statusText = 'statusText' in options ? options.statusText : 'OK'
    this.headers = new Headers(options.headers)
    this.url = options.url || ''
    this._initBody(bodyInit)
  }

  Body.call(Response.prototype)

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  }

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''})
    response.type = 'error'
    return response
  }

  var redirectStatuses = [301, 302, 303, 307, 308]

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  }

  self.Headers = Headers
  self.Request = Request
  self.Response = Response

  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init)
      var xhr = new XMLHttpRequest()

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        }
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
        var body = 'response' in xhr ? xhr.response : xhr.responseText
        resolve(new Response(body, options))
      }

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.open(request.method, request.url, true)

      if (request.credentials === 'include') {
        xhr.withCredentials = true
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob'
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value)
      })

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
    })
  }
  self.fetch.polyfill = true
})(typeof self !== 'undefined' ? self : this);

},{}],183:[function(_dereq_,module,exports){
"use strict";

module.exports = function(app) {
  /*jshint camelcase: false */
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('address', {
        title: 'Address',
        template: function($scope) {
          return $scope.component.multiple ? 'formio/components/address-multiple.html' : 'formio/components/address.html';
        },
        controller: ['$scope', '$http', function($scope, $http) {
          if ($scope.builder) return;
          $scope.address = {};
          $scope.addresses = [];
          $scope.refreshAddress = function(address) {
            var params = {
              address: address,
              sensor: false
            };
            if (!address) {
              return;
            }
            if ($scope.component.map && $scope.component.map.region) {
              params.region = $scope.component.map.region;
            }
            if ($scope.component.map && $scope.component.map.key) {
              params.key = $scope.component.map.key;
            }
            return $http.get(
              'https://maps.googleapis.com/maps/api/geocode/json',
              {
                disableJWT: true,
                params: params,
                headers: {
                  Authorization: undefined,
                  Pragma: undefined,
                  'Cache-Control': undefined
                }
              }
            ).then(function(response) {
              $scope.addresses = response.data.results;
            });
          };
        }],
        tableView: function(data) {
          return data ? data.formatted_address : '';
        },
        group: 'advanced',
        settings: {
          input: true,
          tableView: true,
          label: '',
          key: 'addressField',
          placeholder: '',
          multiple: false,
          protected: false,
          clearOnHide: true,
          unique: false,
          persistent: true,
          hidden: false,
          map: {
            region: '',
            key: ''
          },
          validate: {
            required: false
          }
        }
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/components/address.html',
        "<label ng-if=\"component.label && !component.hideLabel\" for=\"{{ componentId }}\" ng-class=\"{'field-required': isRequired(component)}\">{{ component.label | formioTranslate:null:builder }}</label>\r\n<span ng-if=\"!component.label && isRequired(component)\" class=\"glyphicon glyphicon-asterisk form-control-feedback field-required-inline\" aria-hidden=\"true\"></span>\r\n<ui-select ng-model=\"data[component.key]\" safe-multiple-to-single ng-disabled=\"readOnly\" ng-required=\"isRequired(component)\" id=\"{{ componentId }}\" name=\"{{ componentId }}\" tabindex=\"{{ component.tabindex || 0 }}\" theme=\"bootstrap\">\r\n  <ui-select-match class=\"ui-select-match\" placeholder=\"{{ component.placeholder | formioTranslate:null:builder }}\">{{$item.formatted_address || $select.selected.formatted_address}}</ui-select-match>\r\n  <ui-select-choices class=\"ui-select-choices\" repeat=\"address in addresses\" refresh=\"refreshAddress($select.search)\" refresh-delay=\"500\">\r\n    <div ng-bind-html=\"address.formatted_address | highlight: $select.search\"></div>\r\n  </ui-select-choices>\r\n</ui-select>\r\n<formio-errors ng-if=\"::!builder\"></formio-errors>\r\n"
      );

      // Change the ui-select to ui-select multiple.
      $templateCache.put('formio/components/address-multiple.html',
        $templateCache.get('formio/components/address.html').replace('<ui-select', '<ui-select multiple')
      );
    }
  ]);
};

},{}],184:[function(_dereq_,module,exports){
"use strict";

module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('button', {
        title: 'Button',
        template: 'formio/components/button.html',
        settings: {
          input: true,
          label: 'Submit',
          tableView: false,
          key: 'submit',
          size: 'md',
          leftIcon: '',
          rightIcon: '',
          block: false,
          action: 'submit',
          disableOnInvalid: false,
          theme: 'primary'
        },
        controller: ['$scope', function($scope) {
          if ($scope.builder) return;
          var settings = $scope.component;
          $scope.getButtonType = function() {
            switch (settings.action) {
              case 'submit':
                return 'submit';
              case 'reset':
                return 'reset';
              case 'event':
              case 'oauth':
              default:
                return 'button';
            }
          };

          var onClick = function() {
            switch (settings.action) {
              case 'submit':
                return;
              case 'event':
                $scope.$emit($scope.component.event, $scope.data);
                break;
              case 'reset':
                $scope.resetForm();
                break;
              case 'oauth':
                if (!settings.oauth) {
                  $scope.showAlerts({
                    type: 'danger',
                    message: 'You must assign this button to an OAuth action before it will work.'
                  });
                  break;
                }
                if (settings.oauth.error) {
                  $scope.showAlerts({
                    type: 'danger',
                    message: settings.oauth.error
                  });
                  break;
                }
                $scope.openOAuth(settings.oauth);
                break;
            }
          };

          $scope.$on('buttonClick', function(event, component, componentId) {
            // Ensure the componentId's match (even though they always should).
            if (componentId !== $scope.componentId) {
              return;
            }
            onClick();
          });

          $scope.openOAuth = function(settings) {
            /*eslint-disable camelcase */
            var params = {
              response_type: 'code',
              client_id: settings.clientId,
              redirect_uri: window.location.origin || window.location.protocol + '//' + window.location.host,
              state: settings.state,
              scope: settings.scope
            };
            /*eslint-enable camelcase */

            // Make display optional.
            if (settings.display) {
              params.display = settings.display;
            }
            params = Object.keys(params).map(function(key) {
              return key + '=' + encodeURIComponent(params[key]);
            }).join('&');

            var url = settings.authURI + '?' + params;

            // TODO: make window options from oauth settings, have better defaults
            var popup = window.open(url, settings.provider, 'width=1020,height=618');
            var interval = setInterval(function() {
              try {
                var popupHost = popup.location.host;
                var currentHost = window.location.host;
                if (popup && !popup.closed && popupHost === currentHost && popup.location.search) {
                  popup.close();
                  var params = popup.location.search.substr(1).split('&').reduce(function(params, param) {
                    var split = param.split('=');
                    params[split[0]] = split[1];
                    return params;
                  }, {});
                  if (params.error) {
                    $scope.showAlerts({
                      type: 'danger',
                      message: params.error_description || params.error
                    });
                    return;
                  }
                  // TODO: check for error response here
                  if (settings.state !== params.state) {
                    $scope.showAlerts({
                      type: 'danger',
                      message: 'OAuth state does not match. Please try logging in again.'
                    });
                    return;
                  }
                  var submission = {data: {}, oauth: {}};
                  submission.oauth[settings.provider] = params;
                  submission.oauth[settings.provider].redirectURI = window.location.origin || window.location.protocol + '//' + window.location.host;
                  $scope.formioForm.submitting = true;
                  $scope.formio.saveSubmission(submission)
                  .then(function(submission) {
                    // Trigger the form submission.
                    $scope.$emit('formSubmission', submission);
                  })
                  .catch(function(error) {
                    $scope.showAlerts({
                      type: 'danger',
                      message: error.message || error
                    });
                  })
                  .finally(function() {
                    $scope.formioForm.submitting = false;
                  });
                }
              }
              catch (error) {
                if (error.name !== 'SecurityError') {
                  $scope.showAlerts({
                    type: 'danger',
                    message: error.message || error
                  });
                }
              }
              if (!popup || popup.closed || popup.closed === undefined) {
                clearInterval(interval);
              }
            }, 100);
          };
        }],
        viewTemplate: 'formio/componentsView/button.html'
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/components/button.html',
        "<button ng-attr-type=\"{{ getButtonType() }}\"\r\n  id=\"{{ componentId }}\"\r\n  name=\"{{ componentId }}\"\r\n  ng-class=\"{'btn-block': component.block}\"\r\n  class=\"btn btn-{{ component.theme }} btn-{{ component.size }}\"\r\n  ng-disabled=\"readOnly || formioForm.submitting || (component.disableOnInvalid && formioForm.$invalid)\"\r\n  tabindex=\"{{ component.tabindex || 0 }}\"\r\n  ng-click=\"$emit('buttonClick', component, componentId)\">\r\n  <span ng-if=\"component.leftIcon\" class=\"{{ component.leftIcon }}\" aria-hidden=\"true\"></span>\r\n  <span ng-if=\"component.leftIcon && component.label\">&nbsp;</span>{{ component.label | formioTranslate:null:builder }}<span ng-if=\"component.rightIcon && component.label\">&nbsp;</span>\r\n  <span ng-if=\"component.rightIcon\" class=\"{{ component.rightIcon }}\" aria-hidden=\"true\"></span>\r\n   <i ng-if=\"component.action == 'submit' && formioForm.submitting\" class=\"glyphicon glyphicon-refresh glyphicon-spin\"></i>\r\n</button>\r\n"
      );

      $templateCache.put('formio/componentsView/button.html',
        ""
      );
    }
  ]);
};

},{}],185:[function(_dereq_,module,exports){
"use strict";

module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('checkbox', {
        title: 'Check Box',
        template: 'formio/components/checkbox.html',
        tableView: function(data) {
          return data ? 'Yes' : 'No';
        },
        controller: ['$scope', '$timeout', function($scope, $timeout) {
          if ($scope.builder) return;
          var boolean = {
            true: true,
            false: false
          };
          var defaultValue = $scope.component.hasOwnProperty('defaultValue')
            ? boolean[$scope.component.defaultValue] || false
            : false;

          // FOR-440 - Only use the default value if the data isn't defined.
          // On the first load, attempt to set the default value.
          $scope.data[$scope.component.key] = $scope.data.hasOwnProperty($scope.component.key) && boolean.hasOwnProperty($scope.data[$scope.component.key])
            ? boolean[$scope.data[$scope.component.key]]
            : defaultValue;

          // FA-850 - Ensure the checked value is always a boolean object when loaded, then unbind the watch.
          if ($scope.component.inputType === 'checkbox') {
            $scope.$watch('data.' + $scope.component.key, function() {
              if (!$scope.data || !$scope.component.key) return;

              // If the component is required, and its current value is false, delete the entry.
              if (
                $scope.component.validate
                && $scope.component.validate.required
                && (boolean[$scope.data[$scope.component.key]] || false) === false
              ) {
                $timeout(function() {
                  delete $scope.data[$scope.component.key];
                });
              }
            });
          }
        }],
        settings: {
          input: true,
          inputType: 'checkbox',
          tableView: true,
          // This hides the default label layout so we can use a special inline label
          hideLabel: true,
          label: '',
          datagridLabel: true,
          key: 'checkboxField',
          defaultValue: false,
          protected: false,
          persistent: true,
          hidden: false,
          name: '',
          value: '',
          clearOnHide: true,
          validate: {
            required: false
          }
        }
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/components/checkbox.html',
        "<div class=\"checkbox\">\r\n  <label for=\"{{ componentId }}\" ng-class=\"{'field-required': isRequired(component)}\">\r\n    <input\r\n      ng-if=\"component.name\"\r\n      type=\"{{ component.inputType }}\"\r\n      id=\"{{ componentId }}\"\r\n      name=\"{{ component.name }}\"\r\n      value=\"{{ component.value }}\"\r\n      tabindex=\"{{ component.tabindex || 0 }}\"\r\n      ng-disabled=\"readOnly\"\r\n      ng-model=\"data[component.name]\"\r\n      ng-required=\"component.validate.required\"\r\n    >\r\n    <input\r\n      ng-if=\"!component.name\"\r\n      type=\"{{ component.inputType }}\"\r\n      id=\"{{ componentId }}\"\r\n      tabindex=\"{{ component.tabindex || 0 }}\"\r\n      ng-disabled=\"readOnly\"\r\n      ng-model=\"data[component.key]\"\r\n      ng-required=\"isRequired(component)\"\r\n      custom-validator=\"component.validate.custom\"\r\n    >\r\n    <span ng-if=\"!(component.hideLabel && component.datagridLabel === false)\">{{ component.label | formioTranslate:null:builder }}</span>\r\n  </label>\r\n</div>\r\n<div ng-if=\"!!component.description\" class=\"help-block\">\r\n  <span>{{ component.description }}</span>\r\n</div>\r\n"
      );
    }
  ]);
};

},{}],186:[function(_dereq_,module,exports){
"use strict";

var GridUtils = _dereq_('../factories/GridUtils')();

module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('columns', {
        title: 'Columns',
        template: 'formio/components/columns.html',
        group: 'layout',
        settings: {
          input: false,
          tableView: true,
          key: 'columns',
          columns: [{components: [], width: 6, offset: 0, push: 0, pull: 0},
                    {components: [], width: 6, offset: 0, push: 0, pull: 0}]
        },
        controller: ['$scope', function($scope) {
          // Adjust column component setting from before width, offset...
          if ($scope.component.columns.length   === 2
          &&  $scope.component.columns[0].width === undefined
          &&  $scope.component.columns[1].width === undefined) {
              $scope.component.columns[0].width   = 6;
              $scope.component.columns[0].offset  = 0;
              $scope.component.columns[0].push    = 0;
              $scope.component.columns[0].pull    = 0;
              $scope.component.columns[1].width   = 6;
              $scope.component.columns[1].offset  = 0;
              $scope.component.columns[1].push    = 0;
              $scope.component.columns[1].pull    = 0;
          }
        }],
        viewTemplate: 'formio/componentsView/columns.html',
        tableView: function(data, component, $interpolate, componentInfo, tableChild) {
          var view = '<table class="table table-striped table-bordered table-child">';
          if (!tableChild) {
            view += '<thead><tr>';
          }

          var maxRows = 0;
          angular.forEach(component.columns, function(column, index) {
            // Get the maximum number of rows based on the number of components.
            maxRows = Math.max(maxRows, (column.components.length || 0));

            if (!tableChild) {
              // Add a header for each column.
              view += '<th>Column ' + (index + 1) + ' (' + component.key + ')</th>';
            }
          });

          if (!tableChild) {
            view += '</tr></thead>';
          }

          view += '<tbody>';
          for (var index = 0; index < maxRows; index++) {
            view += '<tr>';
            for (var col = 0; col < component.columns.length; col++) {
              view += GridUtils.columnForComponent(data, component.columns[col].components[index] || undefined, $interpolate, componentInfo, true);
            }
            view += '</tr>';
          }
          view += '</tbody></table>';
          return view;
        }
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/components/columns.html',
        "<div class=\"row\">\r\n  <div ng-show=\"column.width\" ng-class=\"'col-sm-' + column.width + ' col-sm-offset-' + column.offset + ' col-sm-push-' + column.push + ' col-sm-pull-' + column.pull\" ng-repeat=\"column in component.columns track by $index\">\r\n    <formio-component\r\n      ng-repeat=\"_component in column.components track by $index\"\r\n      component=\"_component\"\r\n      data=\"data\"\r\n      formio=\"formio\"\r\n      submission=\"submission\"\r\n      hide-components=\"hideComponents\"\r\n      ng-if=\"builder ? '::true' : isVisible(_component, data)\"\r\n      formio-form=\"formioForm\"\r\n      read-only=\"isDisabled(_component, data)\"\r\n      grid-row=\"gridRow\"\r\n      grid-col=\"gridCol\"\r\n      builder=\"builder\"\r\n    ></formio-component>\r\n  </div>\r\n</div>\r\n"
      );

      $templateCache.put('formio/componentsView/columns.html',
        "<div class=\"row\">\r\n  <div ng-show=\"column.width\" ng-class=\"'col-sm-' + column.width + ' col-sm-offset-' + column.offset + ' col-sm-push-' + column.push + ' col-sm-pull-' + column.pull\" ng-repeat=\"column in component.columns track by $index\">\r\n    <formio-component-view\r\n      ng-repeat=\"_component in column.components track by $index\"\r\n      component=\"_component\"\r\n      data=\"data\"\r\n      form=\"form\"\r\n      submission=\"submission\"\r\n      ignore=\"ignore\"\r\n      ng-if=\"builder ? '::true' : isVisible(_component, data)\"\r\n      builder=\"builder\"\r\n    ></formio-component-view>\r\n  </div>\r\n</div>\r\n"
      );
    }
  ]);
};

},{"../factories/GridUtils":229}],187:[function(_dereq_,module,exports){
"use strict";
module.exports = function(app) {
  app.provider('formioComponents', function() {
    var components = {};
    var groups = {
      __component: {
        title: 'Basic Components'
      },
      advanced: {
        title: 'Special Components'
      },
      layout: {
        title: 'Layout Components'
      }
    };
    return {
      addGroup: function(name, group) {
        groups[name] = group;
      },
      register: function(type, component, group) {
        if (!components[type]) {
          components[type] = component;
        }
        else {
          angular.extend(components[type], component);
        }

        // Set the type for this component.
        if (!components[type].group) {
          components[type].group = group || '__component';
        }
        components[type].settings.type = type;
      },
      $get: function() {
        return {
          components: components,
          groups: groups
        };
      }
    };
  });

  app.directive('safeMultipleToSingle', [function() {
    return {
      require: 'ngModel',
      restrict: 'A',
      link: function($scope, el, attrs, ngModel) {
        ngModel.$formatters.push(function(modelValue) {
          if (!$scope.component.multiple && Array.isArray(modelValue)) {
            return modelValue[0] || '';
          }

          return modelValue;
        });
      }
    };
  }]);
};

},{}],188:[function(_dereq_,module,exports){
"use strict";

var GridUtils = _dereq_('../factories/GridUtils')();

module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('container', {
        title: 'Container',
        template: 'formio/components/container.html',
        viewTemplate: 'formio/componentsView/container.html',
        group: 'advanced',
        icon: 'fa fa-folder-open',
        tableView: function(data, component, $interpolate, componentInfo, tableChild) {
          var view = '<table class="table table-striped table-bordered table-child">';

          if (!tableChild) {
            view += '<thead><tr>';
            view += '<th>' + (component.label || '') + ' (' + component.key + ')</th>';
            view += '</tr></thead>';
          }

          view += '<tbody>';

          // Render a value for each column item.
          angular.forEach(component.components, function(component) {
            view += '<tr>' + GridUtils.columnForComponent(data, component, $interpolate, componentInfo, true) + '</tr>';
          });

          view += '</tbody></table>';
          return view;
        },
        settings: {
          input: true,
          tree: true,
          components: [],
          tableView: true,
          label: '',
          key: 'container',
          protected: false,
          persistent: true,
          clearOnHide: true
        }
      });
    }
  ]);
  app.controller('formioContainerComponent', [
    '$scope',
    function($scope) {
      $scope.data[$scope.component.key] = $scope.data[$scope.component.key] || {};
      $scope.parentKey = $scope.component.key;
    }
  ]);
  app.run([
    '$templateCache',
    'FormioUtils',
    function($templateCache, FormioUtils) {
      $templateCache.put('formio/components/container.html', FormioUtils.fieldWrap(
        "<div ng-controller=\"formioContainerComponent\" class=\"formio-container-component\">\r\n  <formio-component\r\n    ng-repeat=\"_component in component.components track by $index\"\r\n    component=\"_component\"\r\n    data=\"data[parentKey]\"\r\n    formio=\"formio\"\r\n    submission=\"submission\"\r\n    hide-components=\"hideComponents\"\r\n    ng-if=\"builder ? '::true' : isVisible(_component, data[parentKey])\"\r\n    formio-form=\"formioForm\"\r\n    read-only=\"isDisabled(_component, data[parentKey])\"\r\n    grid-row=\"gridRow\"\r\n    grid-col=\"gridCol\"\r\n    builder=\"builder\"\r\n  ></formio-component>\r\n</div>\r\n"
      ));
    }
  ]);
};

},{"../factories/GridUtils":229}],189:[function(_dereq_,module,exports){
"use strict";

module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('content', {
        title: 'Content',
        template: 'formio/components/content.html',
        settings: {
          key: 'content',
          input: false,
          html: ''
        },
        viewTemplate: 'formio/components/content.html'
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/components/content.html',
        "<div ng-bind-html=\"component.html | safehtml | formioTranslate:component.key:builder\" id=\"{{ component.key }}\"></div>\r\n"
      );
    }
  ]);
};

},{}],190:[function(_dereq_,module,exports){
"use strict";


module.exports = function(app) {
  app.directive('currencyInput', function() {
    // May be better way than adding to prototype.
    var splice = function(string, idx, rem, s) {
      return (string.slice(0, idx) + s + string.slice(idx + Math.abs(rem)));
    };
    return {
      restrict: 'A',
      link: function(scope, element) {
        if (scope.builder) return;
        element.bind('keyup', function() {
          var data = scope.data[scope.component.key];

          //clearing left side zeros
          while (data.charAt(0) === '0') {
            data = data.substr(1);
          }

          data = data.replace(/[^\d.\',']/g, '');

          var point = data.indexOf('.');
          if (point >= 0) {
            data = data.slice(0, point + 3);
          }

          var decimalSplit = data.split('.');
          var intPart = decimalSplit[0];
          var decPart = decimalSplit[1];

          intPart = intPart.replace(/[^\d]/g, '');
          if (intPart.length > 3) {
            var intDiv = Math.floor(intPart.length / 3);
            while (intDiv > 0) {
              var lastComma = intPart.indexOf(',');
              if (lastComma < 0) {
                lastComma = intPart.length;
              }

              if (lastComma - 3 > 0) {
                intPart = splice(intPart, lastComma - 3, 0, ',');
              }
              intDiv--;
            }
          }

          if (decPart === undefined) {
            decPart = '';
          }
          else {
            decPart = '.' + decPart;
          }
          var res = intPart + decPart;
          scope.$apply(function() {
            scope.data[scope.component.key] = res;
          });
        });
      }
    };
  });
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('currency', {
        title: 'Currency',
        template: 'formio/components/currency.html',
        group: 'advanced',
        settings: {
          input: true,
          tableView: true,
          inputType: 'text',
          inputMask: '',
          label: '',
          key: 'currencyField',
          placeholder: '',
          prefix: '',
          suffix: '',
          defaultValue: '',
          protected: false,
          persistent: true,
          hidden: false,
          clearOnHide: true,
          validate: {
            required: false,
            multiple: '',
            custom: ''
          },
          conditional: {
            show: null,
            when: null,
            eq: ''
          }
        }
      });
    }
  ]);

  app.run([
    '$templateCache',
    'FormioUtils',
    function($templateCache, FormioUtils) {
      $templateCache.put('formio/components/currency.html', FormioUtils.fieldWrap(
        "<input\r\n  type=\"{{ component.inputType }}\"\r\n  class=\"form-control\"\r\n  id=\"{{ componentId }}\"\r\n  name=\"{{ componentId }}\"\r\n  tabindex=\"{{ component.tabindex || 0 }}\"\r\n  ng-model=\"data[component.key]\"\r\n  ng-required=\"isRequired(component)\"\r\n  ng-disabled=\"readOnly\"\r\n  safe-multiple-to-single\r\n  ng-attr-placeholder=\"{{ component.placeholder }}\"\r\n  custom-validator=\"component.validate.custom\"\r\n  currency-input\r\n  ui-mask-placeholder=\"\"\r\n  ui-options=\"uiMaskOptions\"\r\n>\r\n"
      ));
    }
  ]);
};

},{}],191:[function(_dereq_,module,exports){
"use strict";

var GridUtils = _dereq_('../factories/GridUtils')();

module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('custom', {
        title: 'Custom',
        template: 'formio/components/custom.html',
        group: 'advanced',
        settings: {},
        tableView: GridUtils.generic
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/components/custom.html',
        "<div class=\"panel panel-default\">\r\n  <div class=\"panel-body text-muted text-center\">\r\n    Custom Component ({{ component.type }})\r\n  </div>\r\n</div>\r\n"
      );
    }
  ]);
};

},{"../factories/GridUtils":229}],192:[function(_dereq_,module,exports){
"use strict";

var formioUtils = _dereq_('formiojs/utils');

module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('datagrid', {
        title: 'Data Grid',
        template: 'formio/components/datagrid.html',
        group: 'advanced',
        tableView: function(data, component, $interpolate, componentInfo, tableChild) {
          var view = '<table class="table table-striped table-bordered table-child">';

          if (!tableChild) {
            view += '<thead><tr>';
            angular.forEach(component.components, function(component) {
              view += '<th>' + (component.label || '') + ' (' + component.key + ')</th>';
            });
            view += '</tr></thead>';
          }

          view += '<tbody>';
          angular.forEach(data, function(row) {
            view += '<tr>';
            formioUtils.eachComponent(component.components, function(component) {
              // Don't render disabled fields, or fields with undefined data.
              if (!component.tableView || row[component.key] === undefined) {
                return;
              }

              // If the component has a defined tableView, use that, otherwise try and use the raw data as a string.
              var info = componentInfo.components.hasOwnProperty(component.type) ? componentInfo.components[component.type] : {};
              if (info.tableView) {
                // Reset the tableChild value for datagrids, so that components have headers.
                view += '<td>' + info.tableView(row[component.key] || '', component, $interpolate, componentInfo, false) + '</td>';
              }
              else {
                view += '<td>';
                if (component.prefix) {
                  view += component.prefix;
                }
                view += row[component.key] || '';
                if (component.suffix) {
                  view += ' ' + component.suffix;
                }
                view += '</td>';
              }
            });
            view += '</tr>';
          });
          view += '</tbody></table>';
          return view;
        },
        settings: {
          input: true,
          tree: true,
          components: [],
          tableView: true,
          label: '',
          key: 'datagrid',
          protected: false,
          persistent: true,
          hidden: false,
          clearOnHide: true
        }
      });
    }
  ]);
  app.controller('formioDataGrid', [
    '$scope',
    'FormioUtils',
    function($scope, FormioUtils) {
      if ($scope.builder) return;
      // Ensure each data grid has a valid data model.
      $scope.data = $scope.data || {};
      $scope.data[$scope.component.key] = $scope.data[$scope.component.key] || [{}];

      // Determine if any component is visible.
      $scope.anyVisible = function(component) {
        var data = $scope.data[$scope.component.key];
        var visible = false;
        angular.forEach(data, function(rowData) {
          visible = (visible || FormioUtils.isVisible(component, rowData, $scope.data, $scope.hideComponents));
        });
        return visible;
      };

      // Pull out the rows and cols for easy iteration.
      $scope.rows = $scope.data[$scope.component.key];
      // If less than minLength, add that many rows.
      if ($scope.component.validate && $scope.component.validate.hasOwnProperty('minLength') && $scope.rows.length < $scope.component.validate.minLength) {
        var toAdd = $scope.component.validate.minLength - $scope.rows.length;
        for (var i = 0; i < toAdd; i++) {
          $scope.rows.push({});
        }
      }
      // If more than maxLength, remove extra rows.
      if ($scope.component.validate && $scope.component.validate.hasOwnProperty('maxLength') && $scope.rows.length < $scope.component.validate.maxLength) {
        $scope.rows = $scope.rows.slice(0, $scope.component.validate.maxLength);
      }
      $scope.cols = $scope.component.components;
      $scope.localKeys = $scope.component.components.map(function(component) {
        return component.key;
      });

      // Add a row the to grid.
      $scope.addRow = function() {
        if (!Array.isArray($scope.rows)) {
          $scope.rows = [];
        }
        $scope.rows.push({});
      };

      // Remove a row from the grid.
      $scope.removeRow = function(index) {
        $scope.rows.splice(index, 1);
      };
    }
  ]);
  app.run([
    '$templateCache',
    'FormioUtils',
    function($templateCache, FormioUtils) {
      $templateCache.put('formio/components/datagrid.html', FormioUtils.fieldWrap(
        "<div class=\"formio-data-grid\" ng-controller=\"formioDataGrid\">\r\n  <table ng-class=\"{'table-striped': component.striped, 'table-bordered': component.bordered, 'table-hover': component.hover, 'table-condensed': component.condensed}\" class=\"table datagrid-table\">\r\n    <tr>\r\n      <th\r\n        ng-repeat=\"col in cols track by $index\"\r\n        ng-class=\"{'field-required': col.validate.required}\"\r\n        ng-if=\"builder ? '::true' : anyVisible(col)\"\r\n      >{{ col.label | formioTranslate:null:builder }}</th>\r\n    </tr>\r\n    <tr ng-repeat=\"row in rows track by $index\" ng-init=\"rowIndex = $index\">\r\n      <td ng-repeat=\"col in cols track by $index\" ng-init=\"col.hideLabel = true; colIndex = $index\" class=\"formio-data-grid-row\" ng-if=\"builder ? '::true' : anyVisible(col)\">\r\n        <formio-component\r\n          component=\"col\"\r\n          data=\"rows[rowIndex]\"\r\n          formio-form=\"formioForm\"\r\n          formio=\"formio\"\r\n          submission=\"submission\"\r\n          hide-components=\"hideComponents\"\r\n          ng-if=\"builder ? '::true' : isVisible(col, row)\"\r\n          read-only=\"isDisabled(col, row)\"\r\n          grid-row=\"rowIndex\"\r\n          grid-col=\"colIndex\"\r\n          builder=\"builder\"\r\n        ></formio-component>\r\n      </td>\r\n      <td ng-if=\"!component.hasOwnProperty('validate') || !component.validate.hasOwnProperty('minLength') || rows.length > component.validate.minLength\">\r\n        <a ng-click=\"removeRow(rowIndex)\" class=\"btn btn-default\">\r\n          <span class=\"glyphicon glyphicon-remove-circle\"></span>\r\n        </a>\r\n      </td>\r\n    </tr>\r\n  </table>\r\n  <div class=\"datagrid-add\" ng-if=\"!component.hasOwnProperty('validate') || !component.validate.hasOwnProperty('maxLength') || rows.length < component.validate.maxLength\">\r\n    <a ng-click=\"addRow()\" class=\"btn btn-primary\">\r\n      <span class=\"glyphicon glyphicon-plus\" aria-hidden=\"true\"></span> {{ component.addAnother || \"Add Another\" | formioTranslate:null:builder }}\r\n    </a>\r\n  </div>\r\n</div>\r\n"
      ));
    }
  ]);
};

},{"formiojs/utils":10}],193:[function(_dereq_,module,exports){
"use strict";

module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('datetime', {
        title: 'Date / Time',
        template: 'formio/components/datetime.html',
        tableView: function(data, component, $interpolate) {
          return $interpolate('<span>{{ "' + data + '" | date: "' + component.format + '" }}</span>')();
        },
        group: 'advanced',
        controller: ['$scope', '$timeout', function($scope, $timeout) {
          // Close calendar pop up when tabbing off button
          $scope.onKeyDown = function(event) {
            return event.keyCode === 9 ? false : $scope.calendarOpen;
          };

          var dateValue = function() {
            // If the date is set, then return the true date value.
            if ($scope.data[$scope.component.key]) {
              return ($scope.data[$scope.component.key] instanceof Date) ? $scope.data[$scope.component.key] : new Date($scope.data[$scope.component.key]);
            }

            // See if a default date is set.
            if ($scope.component.defaultDate) {
              var defaultDate = new Date($scope.component.defaultDate);
              if (!defaultDate || isNaN(defaultDate.getDate())) {
                try {
                  defaultDate = new Date(eval($scope.component.defaultDate));
                }
                catch (e) {
                  defaultDate = '';
                }
              }

              if (defaultDate && !isNaN(defaultDate.getDate())) {
                return defaultDate;
              }
            }

            // Default to empty.
            return '';
          };

          // Ensure the date value is always a date object when loaded, then unbind the watch.
          $scope.$watch('data.' + $scope.component.key, function() {
            var newValue = dateValue();
            if (newValue) {
              $scope.data[$scope.component.key] = newValue;
            }
          });

          // Watch for changes to the meridian settings to synchronize the submissionGrid and component view.
          $scope.$watch('component.timePicker.showMeridian', function(update) {
            // Remove any meridian reference, because were not in 12 hr.
            if (!$scope.component.enableTime || !update) {
              $scope.component.format = $scope.component.format.replace(/ a/, '');
              return;
            }

            // If we're missing the meridian string and were in 12 hr, add it.
            if (update && $scope.component.format.indexOf(' a') === -1) {
              $scope.component.format += ' a';
            }
          });

          if (!$scope.component.datePicker.maxDate) {
            delete $scope.component.datePicker.maxDate;
          }
          else {
            var maxDate = new Date($scope.component.datePicker.maxDate);
            $scope.component.datePicker.maxDate = new Date(
              maxDate.getUTCFullYear(),
              maxDate.getUTCMonth(),
              maxDate.getUTCDate(),
              23,
              59,
              59,
              999
            );
          }

          if (!$scope.component.datePicker.minDate) {
            delete $scope.component.datePicker.minDate;
          }
          else {
            var minDate = new Date($scope.component.datePicker.minDate);
            $scope.component.datePicker.minDate = new Date(
              minDate.getUTCFullYear(),
              minDate.getUTCMonth(),
              minDate.getUTCDate(),
              0,
              0,
              0,
              0
            );
          }

          $scope.autoOpen = true;
          $scope.onClosed = function() {
            $scope.autoOpen = false;
            $timeout(function() {
              $scope.autoOpen = true;
            }, 250);
          };
        }],
        settings: {
          input: true,
          tableView: true,
          label: '',
          key: 'datetimeField',
          placeholder: '',
          format: 'yyyy-MM-dd HH:mm a',
          enableDate: true,
          enableTime: true,
          defaultDate: '',
          datepickerMode: 'day',
          datePicker: {
            showWeeks: true,
            startingDay: 0,
            initDate: '',
            minMode: 'day',
            maxMode: 'year',
            yearRows: 4,
            yearColumns: 5,
            minDate: null,
            maxDate: null
          },
          timePicker: {
            hourStep: 1,
            minuteStep: 1,
            showMeridian: true,
            readonlyInput: false,
            mousewheel: true,
            arrowkeys: true
          },
          protected: false,
          persistent: true,
          hidden: false,
          clearOnHide: true,
          validate: {
            required: false,
            custom: ''
          }
        }
      });
    }
  ]);
  app.run([
    '$templateCache',
    'FormioUtils',
    function($templateCache, FormioUtils) {
      $templateCache.put('formio/components/datetime.html', FormioUtils.fieldWrap(
        "<div class=\"input-group\">\r\n  <input\r\n    type=\"text\"\r\n    class=\"form-control\"\r\n    name=\"{{ componentId }}\"\r\n    id=\"{{ componentId }}\"\r\n    ng-focus=\"calendarOpen = autoOpen\"\r\n    ng-click=\"calendarOpen = true\"\r\n    ng-init=\"calendarOpen = false\"\r\n    ng-disabled=\"readOnly\"\r\n    ng-required=\"isRequired(component)\"\r\n    is-open=\"calendarOpen\"\r\n    datetime-picker=\"{{ component.format }}\"\r\n    datepicker-mode=\"component.datepickerMode\"\r\n    when-closed=\"onClosed()\"\r\n    custom-validator=\"component.validate.custom\"\r\n    enable-date=\"component.enableDate\"\r\n    enable-time=\"component.enableTime\"\r\n    ng-model=\"data[component.key]\"\r\n    tabindex=\"{{ component.tabindex || 0 }}\"\r\n    ng-attr-placeholder=\"{{ component.placeholder | formioTranslate:null:builder }}\"\r\n    datepicker-options=\"component.datePicker\"\r\n    timepicker-options=\"component.timePicker\"\r\n  />\r\n  <span class=\"input-group-btn\">\r\n    <button type=\"button\" ng-disabled=\"readOnly\" class=\"btn btn-default\" ng-click=\"calendarOpen = true\" ng-keydown=\"calendarOpen = onKeyDown($event)\">\r\n      <i ng-if=\"component.enableDate\" class=\"glyphicon glyphicon-calendar\"></i>\r\n      <i ng-if=\"!component.enableDate\" class=\"glyphicon glyphicon-time\"></i>\r\n    </button>\r\n  </span>\r\n</div>\r\n"
      ));
    }
  ]);
};

},{}],194:[function(_dereq_,module,exports){
"use strict";

module.exports = function(app) {
  app.directive('dayPart', function() {
    return {
      restrict: 'A',
      replace: true,
      require: 'ngModel',
      link: function(scope, elem, attrs, ngModel) {
        if (scope.builder) return;
        var limitLength = attrs.characters || 2;
        scope.$watch(attrs.ngModel, function() {
          if (!ngModel.$viewValue) {
            return;
          }
          var render = false;
          if (ngModel.$viewValue.length > limitLength) {
            ngModel.$setViewValue(ngModel.$viewValue.substring(0, limitLength));
            render = true;
          }
          if (isNaN(ngModel.$viewValue)) {
            ngModel.$setViewValue(ngModel.$viewValue.replace(/\D/g,''));
            render = true;
          }
          if (
            parseInt(ngModel.$viewValue) < parseInt(attrs.min) ||
            parseInt(ngModel.$viewValue) > parseInt(attrs.max)
          ) {
            ngModel.$setViewValue(ngModel.$viewValue.substring(0, limitLength - 1));
            render = true;
          }
          if (render) {
            ngModel.$render();
          }
        });
      }
    };
  });
  app.directive('dayInput', function() {
    return {
      restrict: 'E',
      replace: true,
      require: 'ngModel',
      scope: {
        component: '=',
        componentId: '=',
        readOnly: '=',
        ngModel: '=',
        gridRow: '=',
        gridCol: '=',
        builder: '=?'
      },
      templateUrl: 'formio/components/day-input.html',
      controller: ['$scope', function($scope) {
        if ($scope.builder) return;
        $scope.months = [
          {value: '', label: $scope.component.fields.month.placeholder},
          {value: '01', label: 'January'},
          {value: '02', label: 'February'},
          {value: '03', label: 'March'},
          {value: '04', label: 'April'},
          {value: '05', label: 'May'},
          {value: '06', label: 'June'},
          {value: '07', label: 'July'},
          {value: '08', label: 'August'},
          {value: '09', label: 'September'},
          {value: '10', label: 'October'},
          {value: '11', label: 'November'},
          {value: '12', label: 'December'}
        ];

        $scope.date = {
          day: '',
          month: '',
          year: ''
        };
      }],
      link: function(scope, elem, attrs, ngModel) {
        if (scope.builder) return;
        // Set the scope values based on the current model.
        scope.$watch('ngModel', function() {
          // Only update on load.
          if (ngModel.$viewValue && !ngModel.$dirty) {
            var parts = typeof ngModel.$viewValue === 'string'
              ? ngModel.$viewValue.split('/')
              : ngModel.$viewValue;
            if ((parts instanceof Array) && parts.length === 3) {
              scope.date.day = parts[(scope.component.dayFirst ? 0 : 1)];
              scope.date.month = parts[(scope.component.dayFirst ? 1 : 0)];
              scope.date.year = parts[2];
            }
          }
        });

        var padLeft = function padLeft(nr, n, str) {
          nr = nr.toString();
          if (nr.length > n) {
            return nr.substr(0, n);
          }

          return Array((n - nr.length) + 1).join(str || '0') + nr;
        };

        scope.onChange = function() {
          var day = padLeft(scope.date.day, 2);
          var month = padLeft(scope.date.month, 2);
          var year = padLeft(scope.date.year, 4);
          var value = scope.component.dayFirst ? day : month;
          value += '/';
          value += scope.component.dayFirst ? month : day;
          value += '/' + year;
          ngModel.$setViewValue(value);
        };

        ngModel.$validators.day = function(modelValue, viewValue) {
          var value = modelValue || viewValue;
          var required = scope.component.fields.day.required || scope.component.fields.month.required || scope.component.fields.year.required;

          if (!required) {
            return true;
          }
          if (!value && required) {
            return false;
          }
          var parts = value.split('/');
          if (scope.component.fields.day.required) {
            if (parts[(scope.component.dayFirst ? 0 : 1)] === '00') {
              return false;
            }
          }
          if (scope.component.fields.month.required) {
            if (parts[(scope.component.dayFirst ? 1 : 0)] === '00') {
              return false;
            }
          }
          if (scope.component.fields.year.required) {
            if (parts[2] === '0000') {
              return false;
            }
          }
          return true;
        };
      }
    };
  });
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('day', {
        title: 'Day',
        template: 'formio/components/day.html',
        group: 'advanced',
        settings: {
          input: true,
          tableView: true,
          label: '',
          key: 'dayField',
          fields: {
            day: {
              type: 'text',
              placeholder: '',
              required: false
            },
            month: {
              type: 'select',
              placeholder: '',
              required: false
            },
            year: {
              type: 'text',
              placeholder: '',
              required: false
            }
          },
          dayFirst: false,
          protected: false,
          persistent: true,
          hidden: false,
          clearOnHide: true,
          validate: {
            custom: ''
          }
        }
      });
    }
  ]);
  app.run([
    '$templateCache',
    'FormioUtils',
    function($templateCache, FormioUtils) {
      $templateCache.put('formio/components/day.html', FormioUtils.fieldWrap(
        "<div class=\"day-input\">\r\n  <day-input\r\n    name=\"{{componentId}}\"\r\n    component-id=\"componentId\"\r\n    read-only=\"isDisabled(component, data)\"\r\n    component=\"component\"\r\n    ng-required=\"isRequired(component)\"\r\n    custom-validator=\"component.validate.custom\"\r\n    ng-model=\"data[component.key]\"\r\n    tabindex=\"{{ component.tabindex || 0 }}\"\r\n    builder=\"builder\"\r\n  ></day-input>\r\n</div>\r\n"
      ));
      $templateCache.put('formio/components/day-input.html',
        "<div class=\"daySelect form row\">\r\n  <div class=\"form-group col-xs-3\" ng-if=\"component.dayFirst && !component.fields.day.hide\">\r\n    <label for=\"{{componentId}}-day\" ng-class=\"{'field-required': component.fields.day.required}\">{{ \"Day\" | formioTranslate:null:builder }}</label>\r\n    <input\r\n      class=\"form-control\"\r\n      type=\"text\"\r\n      id=\"{{componentId}}-day\"\r\n      ng-model=\"date.day\"\r\n      ng-change=\"onChange()\"\r\n      style=\"padding-right: 10px;\"\r\n      ng-attr-placeholder=\"{{component.fields.day.placeholder}}\"\r\n      day-part\r\n      characters=\"2\"\r\n      min=\"0\"\r\n      max=\"31\"\r\n      ng-disabled=\"readOnly\"\r\n    />\r\n  </div>\r\n  <div class=\"form-group col-xs-4\" ng-if=\"!component.fields.month.hide\">\r\n    <label for=\"{{componentId}}-month\" ng-class=\"{'field-required': component.fields.month.required}\">{{ \"Month\" | formioTranslate:null:builder }}</label>\r\n    <select\r\n      class=\"form-control\"\r\n      type=\"text\"\r\n      id=\"{{componentId}}-month\"\r\n      ng-model=\"date.month\"\r\n      ng-change=\"onChange()\"\r\n      ng-disabled=\"readOnly\"\r\n      ng-options=\"month.value as month.label | formioTranslate:null:builder for month in months\"\r\n    ></select>\r\n  </div>\r\n  <div class=\"form-group col-xs-3\" ng-if=\"!component.dayFirst && !component.fields.day.hide\">\r\n    <label for=\"{{componentId}}-day\" ng-class=\"{'field-required': component.fields.day.required}\">{{ \"Day\" | formioTranslate:null:builder }}</label>\r\n    <input\r\n      class=\"form-control\"\r\n      type=\"text\"\r\n      id=\"{{componentId}}-day1\"\r\n      ng-model=\"date.day\"\r\n      ng-change=\"onChange()\"\r\n      style=\"padding-right: 10px;\"\r\n      ng-attr-placeholder=\"{{component.fields.day.placeholder}}\"\r\n      day-part\r\n      characters=\"2\"\r\n      min=\"0\"\r\n      max=\"31\"\r\n      ng-disabled=\"readOnly\"\r\n    />\r\n  </div>\r\n  <div class=\"form-group col-xs-5\" ng-if=\"!component.fields.year.hide\">\r\n    <label for=\"{{componentId}}-year\" ng-class=\"{'field-required': component.fields.year.required}\">{{ \"Year\" | formioTranslate:null:builder }}</label>\r\n    <input\r\n      class=\"form-control\"\r\n      type=\"text\"\r\n      id=\"{{componentId}}-year\"\r\n      ng-model=\"date.year\"\r\n      ng-change=\"onChange()\"\r\n      style=\"padding-right: 10px;\"\r\n      ng-attr-placeholder=\"{{component.fields.year.placeholder}}\"\r\n      characters=\"4\"\r\n      min=\"0\"\r\n      max=\"2100\"\r\n      ng-disabled=\"readOnly\"\r\n    />\r\n  </div>\r\n</div>\r\n"
      );
    }
  ]);
};

},{}],195:[function(_dereq_,module,exports){
"use strict";
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('email', {
        title: 'Email',
        template: 'formio/components/textfield.html',
        group: 'advanced',
        settings: {
          input: true,
          tableView: true,
          inputType: 'email',
          label: '',
          key: 'emailField',
          placeholder: '',
          prefix: '',
          suffix: '',
          defaultValue: '',
          protected: false,
          unique: false,
          persistent: true,
          hidden: false,
          clearOnHide: true,
          kickbox: {
            enabled: false
          }
        }
      });
    }
  ]);
};

},{}],196:[function(_dereq_,module,exports){
"use strict";

var GridUtils = _dereq_('../factories/GridUtils')();

module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('fieldset', {
        title: 'Field Set',
        template: 'formio/components/fieldset.html',
        group: 'layout',
        settings: {
          key: 'fieldset',
          input: false,
          tableView: true,
          legend: '',
          components: []
        },
        viewTemplate: 'formio/componentsView/fieldset.html',
        tableView: function(data, component, $interpolate, componentInfo, tableChild) {
          var view = '<table class="table table-striped table-bordered table-child">';

          if (!tableChild) {
            view += '<thead><tr>';
            view += '<th>Field Set (' + component.key + ')</th>';
            view += '</tr></thead>';
          }
          view += '<tbody>';
          angular.forEach(component.components, function(component) {
            view += '<tr>' + GridUtils.columnForComponent(data, component, $interpolate, componentInfo, true) + '</tr>';
          });

          view += '</tbody></table>';
          return view;
        }
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/components/fieldset.html',
        "<fieldset id=\"{{ component.key }}\">\r\n  <legend ng-if=\"component.legend\">{{ component.legend | formioTranslate:null:builder }}</legend>\r\n  <formio-component\r\n    ng-repeat=\"_component in component.components track by $index\"\r\n    component=\"_component\"\r\n    data=\"data\"\r\n    formio=\"formio\"\r\n    submission=\"submission\"\r\n    hide-components=\"hideComponents\"\r\n    ng-if=\"builder ? '::true' : isVisible(_component, data)\"\r\n    read-only=\"isDisabled(_component, data)\"\r\n    formio-form=\"formioForm\"\r\n    grid-row=\"gridRow\"\r\n    grid-col=\"gridCol\"\r\n    builder=\"builder\"\r\n  ></formio-component>\r\n</fieldset>\r\n"
      );

      $templateCache.put('formio/componentsView/fieldset.html',
        "<fieldset id=\"{{ component.key }}\">\r\n  <legend ng-if=\"component.legend\">{{ component.legend }}</legend>\r\n  <formio-component-view\r\n    ng-repeat=\"_component in component.components track by $index\"\r\n    component=\"_component\"\r\n    data=\"data\"\r\n    submission=\"submission\"\r\n    form=\"form\"\r\n    ignore=\"ignore\"\r\n    ng-if=\"builder ? '::true' : isVisible(_component, data)\"\r\n    builder=\"builder\"\r\n  ></formio-component-view>\r\n</fieldset>\r\n"
      );
    }
  ]);
};

},{"../factories/GridUtils":229}],197:[function(_dereq_,module,exports){
"use strict";

module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('file', {
        title: 'File',
        template: 'formio/components/file.html',
        group: 'advanced',
        settings: {
          input: true,
          tableView: true,
          label: '',
          key: 'file',
          image: false,
          imageSize: '200',
          placeholder: '',
          multiple: false,
          defaultValue: '',
          protected: false,
          persistent: true,
          hidden: false,
          clearOnHide: true
        },
        viewTemplate: 'formio/componentsView/file.html'
      });
    }
  ]);

  app.directive('formioFileList', [function() {
    return {
      restrict: 'E',
      replace: true,
      scope: {
        files: '=',
        form: '=',
        readOnly: '='
      },
      templateUrl: 'formio/components/formio-file-list.html',
      controller: [
        '$scope',
        function($scope) {
          if ($scope.builder) return;
          $scope.removeFile = function(event, index) {
            var component = $scope.$parent.component;
            if (component.storage === 'url') {
              $scope.$parent.formio.makeRequest('', component.url + '/' + $scope.files[index].name, 'delete');
            }
            event.preventDefault();
            $scope.files.splice(index, 1);
          };

          $scope.fileSize = function(a, b, c, d, e) {
            return (b = Math, c = b.log, d = 1024, e = c(a) / c(d) | 0, a / b.pow(d, e)).toFixed(2) + ' ' + (e ? 'kMGTPEZY'[--e] + 'B' : 'Bytes');
          };
        }
      ]
    };
  }]);

  app.directive('formioImageList', [function() {
    return {
      restrict: 'E',
      replace: true,
      scope: {
        files: '=',
        form: '=',
        width: '=',
        readOnly: '='
      },
      templateUrl: 'formio/components/formio-image-list.html',
      controller: [
        '$scope',
        function($scope) {
          if ($scope.builder) return;
          $scope.removeFile = function(event, index) {
            var component = $scope.$parent.component;
            if (component.storage === 'url') {
              $scope.$parent.formio.makeRequest('', component.url + '/' + $scope.files[index].name, 'delete');
            }
            event.preventDefault();
            $scope.files.splice(index, 1);
          };
        }
      ]
    };
  }]);

  app.directive('formioFile', [function() {
    return {
      restrict: 'E',
      replace: true,
      scope: {
        file: '=',
        form: '='
      },
      template: '<a href="{{ file.url }}" ng-click="getFile($event)" target="_blank">{{ file.name }}</a>',
      controller: [
        '$window',
        '$rootScope',
        '$scope',
        'Formio',
        function(
          $window,
          $rootScope,
          $scope,
          Formio
        ) {
          if ($scope.builder) return;
          $scope.getFile = function(evt) {
            evt.preventDefault();
            $scope.form = $scope.form || $rootScope.filePath;
            var formio = new Formio($scope.form);
            formio
              .downloadFile($scope.file).then(function(file) {
                if (file) {
                  $window.open(file.url, '_blank');
                }
              })
              .catch(function(response) {
                // Is alert the best way to do this?
                // User is expecting an immediate notification due to attempting to download a file.
                alert(response);
              });
          };
        }
      ]
    };
  }]);

  app.directive('formioImage', [function() {
    return {
      restrict: 'E',
      replace: true,
      scope: {
        file: '=',
        form: '=',
        width: '='
      },
      template: '<img ng-src="{{ file.imageSrc }}" alt="{{ file.name }}" ng-style="{width: width}" />',
      controller: [
        '$rootScope',
        '$scope',
        'Formio',
        function(
          $rootScope,
          $scope,
          Formio
        ) {
          if ($scope.builder) return;
          $scope.form = $scope.form || $rootScope.filePath;
          var formio = new Formio($scope.form);
          formio.downloadFile($scope.file)
            .then(function(result) {
              $scope.file.imageSrc = result.url;
              $scope.$apply();
            });
        }
      ]
    };
  }]);

  app.controller('formioFileUpload', [
    '$scope',
    '$interpolate',
    'FormioUtils',
    function(
      $scope,
      $interpolate,
      FormioUtils
    ) {
      if ($scope.builder) return;
      $scope.fileUploads = {};
      $scope.removeUpload = function(index) {
        delete $scope.fileUploads[index];
      };

      // This fixes new fields having an empty space in the array.
      if ($scope.data && $scope.data[$scope.component.key] === '') {
        $scope.data[$scope.component.key] = [];
      }
      if ($scope.data && $scope.data[$scope.component.key] === undefined) {
        $scope.data[$scope.component.key] = [];
      }
      if ($scope.data && $scope.data[$scope.component.key] && $scope.data[$scope.component.key][0] === '') {
        $scope.data[$scope.component.key].splice(0, 1);
      }

      $scope.upload = function(files) {
        if ($scope.component.storage && files && files.length) {
          angular.forEach(files, function(file) {
            // Get a unique name for this file to keep file collisions from occurring.
            var fileName = FormioUtils.uniqueName(file.name);
            $scope.fileUploads[fileName] = {
              name: fileName,
              size: file.size,
              status: 'info',
              message: 'Starting upload'
            };
            var dir = $scope.component.dir || '';
            dir = $interpolate(dir)({data: $scope.data, row: $scope.row});
            var formio = null;
            if ($scope.formio) {
              formio = $scope.formio;
            }
            else {
              $scope.fileUploads[fileName].status = 'error';
              $scope.fileUploads[fileName].message = 'File Upload URL not provided.';
            }

            if (formio) {
              formio.uploadFile($scope.component.storage, file, fileName, dir, function processNotify(evt) {
                $scope.fileUploads[fileName].status = 'progress';
                $scope.fileUploads[fileName].progress = parseInt(100.0 * evt.loaded / evt.total);
                delete $scope.fileUploads[fileName].message;
                $scope.$apply();
              }, $scope.component.url)
                .then(function(fileInfo) {
                  delete $scope.fileUploads[fileName];
                  // Ensure that the file component is an array.
                  if (
                    !$scope.data[$scope.component.key] ||
                    !($scope.data[$scope.component.key] instanceof Array)
                  ) {
                    $scope.data[$scope.component.key] = [];
                  }
                  $scope.data[$scope.component.key].push(fileInfo);
                  $scope.$apply();
                })
                .catch(function(response) {
                  $scope.fileUploads[fileName].status = 'error';
                  $scope.fileUploads[fileName].message = response.data;
                  delete $scope.fileUploads[fileName].progress;
                  $scope.$apply();
                });
            }
          });
        }
      };
    }
  ]);
  app.run([
    '$templateCache',
    function(
      $templateCache
    ) {
      $templateCache.put('formio/components/formio-image-list.html',
        "<div>\r\n  <span ng-repeat=\"file in files track by $index\" ng-if=\"file\">\r\n    <formio-image file=\"file\" form=\"form\" width=\"width\"></formio-image>\r\n    <span ng-if=\"!readOnly\" style=\"width:1%;white-space:nowrap;\">\r\n      <a href=\"#\" ng-click=\"removeFile($event, $index)\" style=\"padding: 2px 4px;\" class=\"btn btn-sm btn-default\"><span class=\"glyphicon glyphicon-remove\"></span></a>\r\n    </span>\r\n  </span>\r\n</div>\r\n"
      );

      $templateCache.put('formio/components/formio-file-list.html',
        "<table class=\"table table-striped table-bordered\">\r\n  <thead>\r\n    <tr>\r\n      <td ng-if=\"!readOnly\" style=\"width:1%;white-space:nowrap;\"></td>\r\n      <th>File Name</th>\r\n      <th>Size</th>\r\n    </tr>\r\n  </thead>\r\n  <tbody>\r\n    <tr ng-repeat=\"file in files track by $index\">\r\n      <td ng-if=\"!readOnly\" style=\"width:1%;white-space:nowrap;\"><a ng-if=\"!readOnly\" href=\"#\" ng-click=\"removeFile($event, $index)\" style=\"padding: 2px 4px;\" class=\"btn btn-sm btn-default\"><span class=\"glyphicon glyphicon-remove\"></span></a></td>\r\n      <td><formio-file file=\"file\" form=\"form\"></formio-file></td>\r\n      <td>{{ fileSize(file.size) }}</td>\r\n    </tr>\r\n  </tbody>\r\n</table>\r\n"
      );

      $templateCache.put('formio/components/file.html',
        "<label ng-if=\"component.label && !component.hideLabel\" for=\"{{ componentId }}\" class=\"control-label\" ng-class=\"{'field-required': isRequired(component)}\">{{ component.label | formioTranslate:null:builder }}</label>\r\n<span ng-if=\"!component.label && isRequired(component)\" class=\"glyphicon glyphicon-asterisk form-control-feedback field-required-inline\" aria-hidden=\"true\"></span>\r\n<div ng-controller=\"formioFileUpload\">\r\n  <formio-file-list files=\"data[component.key]\" form=\"formio.formUrl\" ng-if=\"!component.image\"></formio-file-list>\r\n  <formio-image-list files=\"data[component.key]\" form=\"formio.formUrl\" width=\"component.imageSize\" ng-if=\"component.image\"></formio-image-list>\r\n  <div ng-if=\"!readOnly && (component.multiple || (!component.multiple && !data[component.key].length))\">\r\n    <div ngf-drop=\"upload($files)\" class=\"fileSelector\" ngf-drag-over-class=\"'fileDragOver'\" ngf-multiple=\"component.multiple\" id=\"{{ componentId }}\" name=\"{{ componentId }}\"><span class=\"glyphicon glyphicon-cloud-upload\"></span>Drop files to attach, or <a style=\"cursor: pointer;\" ngf-select=\"upload($files)\" tabindex=\"{{ component.tabindex || 0 }}\" ngf-multiple=\"component.multiple\">browse</a>.</div>\r\n    <div ng-if=\"!component.storage\" class=\"alert alert-warning\">No storage has been set for this field. File uploads are disabled until storage is set up.</div>\r\n    <div ngf-no-file-drop>File Drag/Drop is not supported for this browser</div>\r\n  </div>\r\n  <div ng-repeat=\"fileUpload in fileUploads track by $index\" ng-class=\"{'has-error': fileUpload.status === 'error'}\" class=\"file\">\r\n    <div class=\"row\">\r\n      <div class=\"fileName control-label col-sm-10\">{{ fileUpload.name }} <span ng-click=\"removeUpload(fileUpload.name)\" class=\"glyphicon glyphicon-remove\"></span></div>\r\n      <div class=\"fileSize control-label col-sm-2 text-right\">{{ fileSize(fileUpload.size) }}</div>\r\n    </div>\r\n    <div class=\"row\">\r\n      <div class=\"col-sm-12\">\r\n        <span ng-if=\"fileUpload.status === 'progress'\">\r\n          <div class=\"progress\">\r\n            <div class=\"progress-bar\" role=\"progressbar\" aria-valuenow=\"{{fileUpload.progress}}\" aria-valuemin=\"0\" aria-valuemax=\"100\" style=\"width:{{fileUpload.progress}}%\">\r\n              <span class=\"sr-only\">{{fileUpload.progress}}% Complete</span>\r\n            </div>\r\n          </div>\r\n        </span>\r\n        <div ng-if=\"!fileUpload.status !== 'progress'\" class=\"bg-{{ fileUpload.status }} control-label\">{{ fileUpload.message }}</div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n"
      );

      $templateCache.put('formio/componentsView/file.html',
        "<label ng-if=\"component.label && !component.hideLabel\" for=\"{{ component.key }}\" class=\"control-label\" ng-class=\"{'field-required': component.validate.required}\">{{ component.label | formioTranslate:null:builder }}</label>\r\n<div ng-controller=\"formioFileUpload\">\r\n  <formio-file-list files=\"data[component.key]\" form=\"formUrl\" read-only=\"true\" ng-if=\"!component.image\"></formio-file-list>\r\n  <formio-image-list files=\"data[component.key]\" form=\"formUrl\" read-only=\"true\" width=\"component.imageSize\" ng-if=\"component.image\"></formio-image-list>\r\n</div>\r\n"
      );
    }
  ]);
};

},{}],198:[function(_dereq_,module,exports){
"use strict";

var GridUtils = _dereq_('../factories/GridUtils')();

module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('hidden', {
        title: 'Hidden',
        template: 'formio/components/hidden.html',
        group: 'advanced',
        settings: {
          input: true,
          tableView: true,
          key: 'hiddenField',
          label: '',
          protected: false,
          unique: false,
          persistent: true
        },
        tableView: GridUtils.generic
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/components/hidden.html',
        "<input type=\"hidden\" id=\"{{ componentId }}\" name=\"{{ componentId }}\" ng-model=\"data[component.key]\">\r\n"
      );
    }
  ]);
};

},{"../factories/GridUtils":229}],199:[function(_dereq_,module,exports){
"use strict";


module.exports = function(app) {
  app.directive('formioHtmlElement', [
    '$sanitize',
    '$filter',
    function($sanitize, $filter) {
      return {
        restrict: 'E',
        scope: {
          component: '='
        },
        templateUrl: 'formio/components/htmlelement-directive.html',
        link: function($scope) {
          if ($scope.builder) return;
          var displayError = function(msg) {
            $scope.parseError = 'Invalid HTML: ' + msg.toString();
          };

          $scope.$watch('component', function createElement() {
            if (!$scope.component.tag) {
              return displayError('No tag given');
            }

            var element = angular.element('<' + $scope.component.tag + '>' + '</' + $scope.component.tag + '>');
            element.html($filter('formioTranslate')($scope.component.content));

            // Add the css classes if supplied.
            if ($scope.component.className) {
              element.attr('class', $scope.component.className);
            }

            angular.forEach($scope.component.attrs, function(attr) {
              if (!attr.attr) return;
              element.attr(attr.attr, attr.value);
            });

            try {
              $scope.html = $sanitize(element.prop('outerHTML'));
              $scope.parseError = null;

              // If the sanitized html is empty, it was invalid; Create a visible error so we still render something.
              if (!$scope.html) {
                return displayError(element.prop('outerHTML'));
              }
            }
            catch (err) {
              // Isolate the message and store it.
              $scope.parseError = err.message
                .split('\n')[0]
                .replace('[$sanitize:badparse]', '');
            }
          }, true);
        }
      };
  }]);

  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('htmlelement', {
        title: 'HTML Element',
        template: 'formio/components/htmlelement.html',
        viewTemplate: 'formio/components/htmlelement.html',
        settings: {
          key: 'html',
          input: false,
          tag: 'p',
          attrs: [],
          className: '',
          content: ''
        }
      });
    }
  ]);

  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/components/htmlelement.html',
        '<formio-html-element component="component"></div>'
      );

      $templateCache.put('formio/components/htmlelement-directive.html',
        "<div id=\"{{ component.key }}\">\r\n  <div class=\"alert alert-warning\" ng-if=\"parseError\">{{ parseError }}</div>\r\n  <div ng-bind-html=\"html\"></div>\r\n</div>\r\n"
      );
    }
  ]);
};

},{}],200:[function(_dereq_,module,exports){
"use strict";
var app = angular.module('formio');

// Basic
_dereq_('./components')(app);
_dereq_('./textfield')(app);
_dereq_('./number')(app);
_dereq_('./password')(app);
_dereq_('./textarea')(app);
_dereq_('./checkbox')(app);
_dereq_('./selectboxes')(app);
_dereq_('./select')(app);
_dereq_('./radio')(app);
_dereq_('./htmlelement')(app);
_dereq_('./content')(app);
_dereq_('./button')(app);

// Special
_dereq_('./email')(app);
_dereq_('./phonenumber')(app);
_dereq_('./address')(app);
_dereq_('./datetime')(app);
_dereq_('./day')(app);
_dereq_('./currency')(app);
_dereq_('./hidden')(app);
_dereq_('./resource')(app);
_dereq_('./file')(app);
_dereq_('./signature')(app);
_dereq_('./custom')(app);
_dereq_('./container')(app);
_dereq_('./datagrid')(app);
_dereq_('./survey')(app);

// Layout
_dereq_('./columns')(app);
_dereq_('./fieldset')(app);
_dereq_('./page')(app);
_dereq_('./panel')(app);
_dereq_('./table')(app);
_dereq_('./well')(app);

},{"./address":183,"./button":184,"./checkbox":185,"./columns":186,"./components":187,"./container":188,"./content":189,"./currency":190,"./custom":191,"./datagrid":192,"./datetime":193,"./day":194,"./email":195,"./fieldset":196,"./file":197,"./hidden":198,"./htmlelement":199,"./number":201,"./page":202,"./panel":203,"./password":204,"./phonenumber":205,"./radio":206,"./resource":207,"./select":208,"./selectboxes":209,"./signature":210,"./survey":211,"./table":212,"./textarea":213,"./textfield":214,"./well":215}],201:[function(_dereq_,module,exports){
"use strict";


module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      var isNumeric = function isNumeric(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
      };
      formioComponentsProvider.register('number', {
        title: 'Number',
        template: 'formio/components/number.html',
        settings: {
          input: true,
          tableView: true,
          inputType: 'number',
          label: '',
          key: 'numberField',
          placeholder: '',
          prefix: '',
          suffix: '',
          defaultValue: '',
          protected: false,
          persistent: true,
          hidden: false,
          clearOnHide: true,
          validate: {
            required: false,
            min: '',
            max: '',
            step: 'any',
            integer: '',
            multiple: '',
            custom: ''
          }
        },
        controller: ['$scope', function($scope) {
          if ($scope.builder) return; // FOR-71 - Skip parsing input data.

          // Ensure that values are numbers.
          if (
            $scope.data &&
            $scope.data.hasOwnProperty($scope.component.key) &&
            isNumeric($scope.data[$scope.component.key])
          ) {
            $scope.data[$scope.component.key] = parseFloat($scope.data[$scope.component.key]);
          }
        }]
      });
    }
  ]);

  app.run([
    '$templateCache',
    'FormioUtils',
    function($templateCache, FormioUtils) {
      $templateCache.put('formio/components/number.html', FormioUtils.fieldWrap(
        "<input\r\n  type=\"{{ component.inputType }}\"\r\n  class=\"form-control\"\r\n  id=\"{{ componentId }}\"\r\n  name=\"{{ componentId }}\"\r\n  tabindex=\"{{ component.tabindex || 0 }}\"\r\n  ng-model=\"data[component.key]\"\r\n  ng-required=\"isRequired(component)\"\r\n  ng-disabled=\"readOnly\"\r\n  safe-multiple-to-single\r\n  min=\"{{ component.validate.min }}\"\r\n  max=\"{{ component.validate.max }}\"\r\n  step=\"{{ component.validate.step }}\"\r\n  ng-attr-placeholder=\"{{ component.placeholder | formioTranslate:null:builder }}\"\r\n  custom-validator=\"component.validate.custom\"\r\n  ui-mask=\"{{ component.inputMask }}\"\r\n  ui-mask-placeholder=\"\"\r\n  ui-options=\"uiMaskOptions\"\r\n>\r\n"
      ));
    }
  ]);
};

},{}],202:[function(_dereq_,module,exports){
"use strict";

module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('page', {
        template: 'formio/components/page.html',
        settings: {
          key: 'page',
          input: false,
          components: []
        }
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/components/page.html',
        "<formio-component\r\n  ng-repeat=\"_component in component.components track by $index\"\r\n  component=\"_component\"\r\n  data=\"data\"\r\n  formio=\"formio\"\r\n  submission=\"submission\"\r\n  hide-components=\"hideComponents\"\r\n  ng-if=\"builder ? '::true' : isVisible(_component, data)\"\r\n  read-only=\"isDisabled(_component, data)\"\r\n  formio-form=\"formioForm\"\r\n  grid-row=\"gridRow\"\r\n  grid-col=\"gridCol\"\r\n  builder=\"builder\"\r\n></formio-component>\r\n"
      );
    }
  ]);
};

},{}],203:[function(_dereq_,module,exports){
"use strict";

module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('panel', {
        title: 'Panel',
        template: 'formio/components/panel.html',
        group: 'layout',
        settings: {
          key: 'panel',
          input: false,
          title: '',
          theme: 'default',
          components: []
        },
        viewTemplate: 'formio/componentsView/panel.html'
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/components/panel.html',
        "<div class=\"panel panel-{{ component.theme }}\" id=\"{{ component.key }}\">\r\n  <div ng-if=\"component.title\" class=\"panel-heading\">\r\n    <h3 class=\"panel-title\">{{ component.title | formioTranslate:null:builder }}</h3>\r\n  </div>\r\n  <div class=\"panel-body\">\r\n    <formio-component\r\n      ng-repeat=\"_component in component.components track by $index\"\r\n      component=\"_component\"\r\n      data=\"data\"\r\n      formio=\"formio\"\r\n      submission=\"submission\"\r\n      hide-components=\"hideComponents\"\r\n      ng-if=\"builder ? '::true' : isVisible(_component, data)\"\r\n      read-only=\"isDisabled(_component, data)\"\r\n      formio-form=\"formioForm\"\r\n      grid-row=\"gridRow\"\r\n      grid-col=\"gridCol\"\r\n      builder=\"builder\"\r\n    ></formio-component>\r\n  </div>\r\n</div>\r\n"
      );

      $templateCache.put('formio/componentsView/panel.html',
        "<div class=\"panel panel-{{ component.theme }}\" id=\"{{ component.key }}\">\r\n  <div ng-if=\"component.title\" class=\"panel-heading\">\r\n    <h3 class=\"panel-title\">{{ component.title }}</h3>\r\n  </div>\r\n  <div class=\"panel-body\">\r\n    <formio-component-view\r\n      ng-repeat=\"_component in component.components track by $index\"\r\n      component=\"_component\"\r\n      data=\"data\"\r\n      submission=\"submission\"\r\n      form=\"form\"\r\n      ignore=\"ignore\"\r\n      ng-if=\"builder ? '::true' : isVisible(_component, data)\"\r\n      builder=\"builder\"\r\n    ></formio-component-view>\r\n  </div>\r\n</div>\r\n"
      );
    }
  ]);
};

},{}],204:[function(_dereq_,module,exports){
"use strict";
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('password', {
        title: 'Password',
        template: 'formio/components/textfield.html',
        tableView: function() {
          return '--- PROTECTED ---';
        },
        settings: {
          input: true,
          tableView: false,
          inputType: 'password',
          label: '',
          key: 'passwordField',
          placeholder: '',
          prefix: '',
          suffix: '',
          protected: true,
          persistent: true,
          hidden: false,
          clearOnHide: true
        }
      });
    }
  ]);
};

},{}],205:[function(_dereq_,module,exports){
"use strict";
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('phoneNumber', {
        title: 'Phone Number',
        template: 'formio/components/textfield.html',
        group: 'advanced',
        settings: {
          input: true,
          tableView: true,
          inputMask: '(999) 999-9999',
          label: '',
          key: 'phonenumberField',
          placeholder: '',
          prefix: '',
          suffix: '',
          multiple: false,
          protected: false,
          unique: false,
          persistent: true,
          hidden: false,
          defaultValue: '',
          clearOnHide: true,
          validate: {
            required: false
          }
        }
      });
    }
  ]);
};

},{}],206:[function(_dereq_,module,exports){
"use strict";


module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('radio', {
        title: 'Radio',
        template: 'formio/components/radio.html',
        tableView: function(data, component) {
          for (var i in component.values) {
            if (component.values[i].value === data) {
              return component.values[i].label;
            }
          }
          return data;
        },
        settings: {
          input: true,
          tableView: true,
          inputType: 'radio',
          label: '',
          key: 'radioField',
          values: [],
          defaultValue: '',
          protected: false,
          persistent: true,
          hidden: false,
          clearOnHide: true,
          validate: {
            required: false,
            custom: '',
            customPrivate: false
          }
        }
      });
    }
  ]);
  app.run([
    '$templateCache',
    'FormioUtils',
    function($templateCache, FormioUtils) {
      $templateCache.put('formio/components/radio.html', FormioUtils.fieldWrap(
        "<ng-form name=\"{{ componentId }}\" ng-model=\"data[component.key]\" custom-validator=\"component.validate.custom\">\r\n  <div ng-class=\"component.inline ? 'radio-inline' : 'radio'\" ng-repeat=\"v in component.values track by $index\">\r\n    <label class=\"control-label\" for=\"{{ componentId }}-{{ v.value }}\">\r\n      <input\r\n        type=\"{{ component.inputType }}\"\r\n        id=\"{{ componentId }}-{{ v.value }}\"\r\n        value=\"{{ v.value }}\"\r\n        tabindex=\"{{ component.tabindex || 0 }}\"\r\n        ng-model=\"data[component.key]\"\r\n        ng-required=\"isRequired(component)\"\r\n        custom-validator=\"component.validate.custom\"\r\n        ng-disabled=\"readOnly\"\r\n      >\r\n      {{ v.label | formioTranslate:null:builder }}\r\n    </label>\r\n  </div>\r\n</ng-form>\r\n"
      ));
    }
  ]);
};

},{}],207:[function(_dereq_,module,exports){
"use strict";

module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('resource', {
        title: 'Resource',
        tableView: function(data, component, $interpolate) {
          if ($interpolate) {
            return $interpolate(component.template)({item: data});
          }

          return data ? data._id : '';
        },
        template: function($scope) {
          return $scope.component.multiple ? 'formio/components/resource-multiple.html' : 'formio/components/resource.html';
        },
        controller: ['$scope', 'Formio', 'ngDialog', function($scope, Formio, ngDialog) {
          if ($scope.builder) return;
          var settings = $scope.component;
          var params = settings.params || {};
          $scope.selectItems = [];
          $scope.hasNextPage = false;
          $scope.resourceLoading = false;
          params.limit = 100;
          params.skip = 0;
          if (settings.multiple) {
            settings.defaultValue = [];
          }
          if (settings.resource) {
            var url = '';
            if (settings.project) {
              url += '/project/' + settings.project;
            }
            else if ($scope.formio && $scope.formio.projectUrl) {
              url += $scope.formio.projectUrl;
            }
            url += '/form/' + settings.resource;
            var formio = new Formio(url);

            // Refresh the items.
            $scope.refreshSubmissions = function(input, append) {
              if ($scope.resourceLoading) {
                return;
              }
              $scope.resourceLoading = true;
              // If they wish to return only some fields.
              if (settings.selectFields) {
                params.select = settings.selectFields;
              }
              if (settings.searchFields && input) {
                angular.forEach(settings.searchFields, function(field) {
                  params[field] = input;
                });
              }

              // Load the submissions.
              formio.loadSubmissions({
                params: params
              }).then(function(submissions) {
                submissions = submissions || [];
                if (append) {
                  $scope.selectItems = $scope.selectItems.concat(submissions);
                }
                else {
                  $scope.selectItems = submissions;
                }
                $scope.hasNextPage = (submissions.length >= params.limit) && ($scope.selectItems.length < submissions.serverCount);
              })['finally'](function() {
                $scope.resourceLoading = false;
              });
            };

            // Load more items.
            $scope.loadMoreItems = function($select, $event) {
              $event.stopPropagation();
              $event.preventDefault();
              params.skip += params.limit;
              $scope.refreshSubmissions(null, true);
            };

            $scope.refreshSubmissions();

            // Add a new resource.
            $scope.newResource = function() {
              var template  = '<br>' +
                              '<div class="row">' +
                                '<div class="col-sm-12">' +
                                  '<div class="panel panel-default">' +
                                    '<div class="panel-heading">' +
                                      '<h3 class="panel-title">{{ component.addResourceLabel || "Add Resource" | formioTranslate}}</h3>' +
                                    '</div>' +
                                    '<div class="panel-body">' +
                                      '<formio src="formUrl"></formio>' +
                                    '</div>' +
                                  '</div>' +
                                '</div>' +
                              '</div>';

              ngDialog.open({
                template: template,
                plain: true,
                scope: $scope,
                controller: ['$scope', function($scope) {
                  $scope.formUrl = $scope.formio.formsUrl + '/' + $scope.component.resource;

                  // Bind when the form is loaded.
                  $scope.$on('formLoad', function(event) {
                    event.stopPropagation(); // Don't confuse app
                  });

                  // Bind when the form is submitted.
                  $scope.$on('formSubmission', function(event, submission) {
                    var component = $scope.component;
                    var data      = $scope.data;

                    if (component.multiple) {
                      data[component.key].push(submission);
                    }
                    else {
                      data[component.key] = submission;
                    }

                    $scope.refreshSubmissions();
                    $scope.closeThisDialog(submission);
                  });
                }]
              }).closePromise.then(function(/*e*/) {
              //var cancelled = e.value === false || e.value === '$closeButton' || e.value === '$document';
              });
            };

            // Close all open dialogs on state change (using UI-Router).
            $scope.$on('$stateChangeStart', function() {
              ngDialog.closeAll(false);
            });

            // Close all open dialogs on route change (using ngRoute).
            $scope.$on('$routeChangeStart', function() {
              ngDialog.closeAll(false);
            });
          }
        }],
        group: 'advanced',
        settings: {
          input: true,
          tableView: true,
          label: '',
          key: 'resourceField',
          placeholder: '',
          resource: '',
          project: '',
          defaultValue: '',
          template: '<span>{{ item.data }}</span>',
          selectFields: '',
          searchFields: '',
          multiple: false,
          protected: false,
          persistent: true,
          hidden: false,
          clearOnHide: true,
          validate: {
            required: false
          },
          defaultPermission: ''
        }
      });
    }
  ]);

  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/components/resource.html',
        "<div ng-if=\"!component.addResource\">\r\n  <label ng-if=\"component.label && !component.hideLabel\" for=\"{{ componentId }}\" class=\"control-label\" ng-class=\"{'field-required': isRequired(component)}\">{{ component.label | formioTranslate:null:builder }}</label>\r\n  <span ng-if=\"!component.label && isRequired(component)\" class=\"glyphicon glyphicon-asterisk form-control-feedback field-required-inline\" aria-hidden=\"true\"></span>\r\n  <ui-select ui-select-required safe-multiple-to-single ui-select-open-on-focus ng-model=\"data[component.key]\" ng-disabled=\"readOnly\" ng-required=\"isRequired(component)\" id=\"{{ componentId }}\" name=\"{{ componentId }}\" theme=\"bootstrap\" tabindex=\"{{ component.tabindex || 0 }}\">\r\n    <ui-select-match class=\"ui-select-match\" placeholder=\"{{ component.placeholder | formioTranslate:null:builder }}\">\r\n      <formio-select-item template=\"component.template\" item=\"$item || $select.selected\" select=\"$select\"></formio-select-item>\r\n    </ui-select-match>\r\n    <ui-select-choices class=\"ui-select-choices\" repeat=\"item in selectItems | filter: $select.search\" refresh=\"refreshSubmissions($select.search)\" refresh-delay=\"250\">\r\n      <formio-select-item template=\"component.template\" item=\"item\" select=\"$select\"></formio-select-item>\r\n      <button ng-if=\"hasNextPage && ($index == $select.items.length-1)\" class=\"btn btn-success btn-block\" ng-click=\"loadMoreItems($select, $event)\" ng-disabled=\"resourceLoading\">Load more...</button>\r\n    </ui-select-choices>\r\n  </ui-select>\r\n  <formio-errors ng-if=\"::!builder\"></formio-errors>\r\n</div>\r\n<div ng-if=\"component.addResource\">\r\n  <table class=\"table table-bordered\">\r\n    <label ng-if=\"component.label && !component.hideLabel\" for=\"{{ componentId }}\" class=\"control-label\" ng-class=\"{'field-required': isRequired(component)}\">{{ component.label | formioTranslate:null:builder }}</label>\r\n    <span ng-if=\"!component.label && isRequired(component)\" class=\"glyphicon glyphicon-asterisk form-control-feedback field-required-inline\" aria-hidden=\"true\"></span>\r\n    <tr>\r\n      <td>\r\n        <ui-select ui-select-required safe-multiple-to-single ui-select-open-on-focus ng-model=\"data[component.key]\" ng-disabled=\"readOnly\" ng-required=\"isRequired(component)\" id=\"{{ componentId }}\" name=\"{{ componentId }}\" theme=\"bootstrap\" tabindex=\"{{ component.tabindex || 0 }}\">\r\n          <ui-select-match class=\"ui-select-match\" placeholder=\"{{ component.placeholder | formioTranslate:null:builder }}\">\r\n            <formio-select-item template=\"component.template\" item=\"$item || $select.selected\" select=\"$select\"></formio-select-item>\r\n          </ui-select-match>\r\n          <ui-select-choices class=\"ui-select-choices\" repeat=\"item in selectItems | filter: $select.search\" refresh=\"refreshSubmissions($select.search)\" refresh-delay=\"250\">\r\n            <formio-select-item template=\"component.template\" item=\"item\" select=\"$select\"></formio-select-item>\r\n            <button ng-if=\"hasNextPage && ($index == $select.items.length-1)\" class=\"btn btn-success btn-block\" ng-click=\"loadMoreItems($select, $event)\" ng-disabled=\"resourceLoading\">Load more...</button>\r\n          </ui-select-choices>\r\n        </ui-select>\r\n        <formio-errors ng-if=\"::!builder\"></formio-errors>\r\n      </td>\r\n    </tr>\r\n    <tr>\r\n      <td>\r\n        <a ng-click=\"newResource()\" class=\"btn btn-primary\">\r\n          <span class=\"glyphicon glyphicon-plus\" aria-hidden=\"true\"></span> {{ component.addResourceLabel || \"Add Resource\" | formioTranslate:null:builder}}\r\n        </a>\r\n      </td>\r\n    </tr>\r\n  </table>\r\n</div>\r\n"
      );

      // Change the ui-select to ui-select multiple.
      $templateCache.put('formio/components/resource-multiple.html',
        $templateCache.get('formio/components/resource.html').replace(/<ui-select\s/g, '<ui-select multiple ')
      );
    }
  ]);
};

},{}],208:[function(_dereq_,module,exports){
"use strict";
/*eslint max-depth: ["error", 6]*/

var _get = _dereq_('lodash/get');
var _isEqual = _dereq_('lodash/isEqual');
var _assign = _dereq_('lodash/assign');
var _set = _dereq_('lodash/set');
var _cloneDeep = _dereq_('lodash/cloneDeep');
module.exports = function(app) {
  app.directive('formioSelectItem', [
    '$compile',
    function($compile) {
      return {
        restrict: 'E',
        scope: {
          template: '=',
          item: '=',
          select: '='
        },
        link: function(scope, element) {
          if (scope.builder) return;
          if (scope.template) {
            element.append($compile(angular.element(scope.template))(scope));
          }
        }
      };
    }
  ]);

  app.directive('uiSelectRequired', function() {
    return {
      require: 'ngModel',
      link: function(scope, element, attrs, ngModel) {
        if (scope.builder) return;
        var oldIsEmpty = ngModel.$isEmpty;
        ngModel.$isEmpty = function(value) {
          return (Array.isArray(value) && value.length === 0) || oldIsEmpty(value);
        };
      }
    };
  });

  // A directive to have ui-select open on focus
  app.directive('uiSelectOpenOnFocus', [function() {
    return {
      require: 'uiSelect',
      restrict: 'A',
      link: function($scope, el, attrs, uiSelect) {
        if ($scope.builder) return;
        var focuscount = -1;

        angular.element(uiSelect.focusser).on('focus', function() {
          if (focuscount-- < 0) {
            uiSelect.activate();
          }
        });

        // Disable the auto open when this select element has been activated.
        $scope.$on('uis:activate', function() {
          focuscount = 1;
        });

        // Re-enable the auto open after the select element has been closed
        $scope.$on('uis:close', function() {
          focuscount = 1;
        });
      }
    };
  }]);

  // Configure the Select component.
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('select', {
        title: 'Select',
        template: function($scope) {
          return $scope.component.multiple ? 'formio/components/select-multiple.html' : 'formio/components/select.html';
        },
        tableView: function(data, component, $interpolate) {
          var getItem = function(data) {
            switch (component.dataSrc) {
              case 'values':
                component.data.values.forEach(function(item) {
                  if (item.value === data) {
                    data = item;
                  }
                });
                return data;
              case 'json':
                if (component.valueProperty) {
                  var selectItems;
                  try {
                    selectItems = angular.fromJson(component.data.json);
                  }
                  catch (error) {
                    selectItems = [];
                  }
                  selectItems.forEach(function(item) {
                    if (item[component.valueProperty] === data) {
                      data = item;
                    }
                  });
                }
                return data;
              // TODO: implement url and resource view.
              case 'url':
              case 'resource':
              default:
                return data;
            }
          };
          if (component.multiple && Array.isArray(data)) {
            return data.map(getItem).reduce(function(prev, item) {
              var value;
              if (typeof item === 'object') {
                value = $interpolate(component.template)({item: item});
              }
              else {
                value = item;
              }
              return (prev === '' ? '' : ', ') + value;
            }, '');
          }
          else {
            var item = getItem(data);
            var value;
            if (typeof item === 'object') {
              value = $interpolate(component.template)({item: item});
            }
            else {
              value = item;
            }
            return value;
          }
        },
        controller: [
          '$rootScope',
          '$scope',
          '$http',
          'Formio',
          '$interpolate',
          '$q',
          '$timeout',
          function(
            $rootScope,
            $scope,
            $http,
            Formio,
            $interpolate,
            $q,
            $timeout
          ) {
            // FOR-71 - Skip functionality in the builder view.
            if ($scope.builder) return;
            var settings = $scope.component;
            var options = {};
            $scope.nowrap = true;
            $scope.hasNextPage = false;
            $scope.selectItems = [];

            var initialized = $q.defer();
            initialized.promise.then(function() {
              $scope.$emit('selectLoaded', $scope.component);
            });

            var selectValues = $scope.component.selectValues;
            var valueProp = $scope.component.valueProperty;
            $scope.getSelectItem = function(item) {
              if (!item) {
                return '';
              }
              if (settings.dataSrc === 'values') {
                return item.value;
              }

              // Get the item value.
              var itemValue = valueProp ? _get(item, valueProp) : item;
              if (itemValue === undefined) {
                /* eslint-disable no-console */
                console.warn('Cannot find value property within select: ' + valueProp);
                /* eslint-enable no-console */
              }
              return itemValue;
            };

            $scope.refreshItems = function() {
              return $q.resolve([]);
            };
            $scope.$on('refreshList', function(event, url, input) {
              $scope.refreshItems(input, url);
            });

            var refreshing = false;
            var refreshValue = function() {
              if (refreshing) {
                return;
              }
              refreshing = true;
              var tempData = $scope.data[settings.key];
              $scope.data[settings.key] = settings.multiple ? [] : '';
              if (!settings.clearOnRefresh) {
                $timeout(function() {
                  $scope.data[settings.key] = tempData;
                  refreshing = false;
                  $scope.$emit('selectLoaded', $scope.component);
                });
              }
              else {
                refreshing = false;
                $scope.$emit('selectLoaded', $scope.component);
              }
            };

            // Ensures that the value is within the select items.
            var ensureValue = function() {
              var value = $scope.data[settings.key];
              if (!value || (Array.isArray(value) && value.length === 0)) {
                return;
              }
              // Iterate through the list of items and see if our value exists...
              var found = false;
              for (var i=0; i < $scope.selectItems.length; i++) {
                var item = $scope.selectItems[i];
                var selectItem = $scope.getSelectItem(item);
                if (_isEqual(selectItem, value)) {
                  found = true;
                  break;
                }
              }

              // If the item is not found in the select items array, then add it manually.
              if (!found) {
                var itemValue = value;
                if (valueProp) {
                  itemValue = {};
                  _set(itemValue, valueProp, value);
                }
                $scope.selectItems.push(itemValue);
              }
            };

            // Refresh the items when ready.
            var refreshItemsWhenReady = function() {
              initialized.promise.then(function() {
                var refreshPromise = $scope.refreshItems(true);
                if (refreshPromise) {
                  refreshPromise.then(refreshValue);
                }
                else {
                  refreshValue();
                }
              });
            };

            // Add a watch if they wish to refresh on selection of another field.
            if (settings.refreshOn) {
              if (settings.refreshOn === 'data') {
                $scope.$watch('data', refreshItemsWhenReady, true);
                return;
              }

              $scope.$watch('data.' + settings.refreshOn, refreshItemsWhenReady);
              $scope.$watch('submission.data.' + settings.refreshOn, refreshItemsWhenReady);
            }
            else {
              // Watch for the data to be set, and ensure the value is set properly.
              var dataWatch = $scope.$watch('data.' + settings.key, function(value) {
                if (value) {
                  initialized.promise.then(function() {
                    dataWatch();
                    ensureValue();
                    refreshValue();
                  });
                }
              });
            }

            var lastInput;
            switch (settings.dataSrc) {
              case 'values':
                $scope.selectItems = settings.data.values;
                initialized.resolve();
                break;
              case 'json':
                var items;

                // Set the new result.
                var setResult = function(data, append) {
                  // coerce the data into an array.
                  if (!(data instanceof Array)) {
                    data = [data];
                  }

                  if (data.length < options.params.limit) {
                    $scope.hasNextPage = false;
                  }
                  if (append) {
                    $scope.selectItems = $scope.selectItems.concat(data);
                  }
                  else {
                    $scope.selectItems = data;
                  }
                };

                try {
                  if (typeof $scope.component.data.json === 'string') {
                    items = angular.fromJson($scope.component.data.json);
                  }
                  else if (typeof $scope.component.data.json === 'object') {
                    items = $scope.component.data.json;
                  }
                  else {
                    items = [];
                  }

                  if (selectValues) {
                    // Allow dot notation in the selectValue property.
                    if (selectValues.indexOf('.') !== -1) {
                      var parts = selectValues.split('.');
                      var select = items;
                      for (var i in parts) {
                        select = select[parts[i]];
                      }
                      items = select;
                    }
                    else {
                      items = items[selectValues];
                    }
                  }
                }
                catch (error) {
                  /* eslint-disable no-console */
                  console.warn('Error parsing JSON in ' + $scope.component.key, error);
                  /* eslint-enable no-console */
                  items = [];
                }
                options.params = {
                  limit: $scope.component.limit || 20,
                  skip: 0
                };

                $scope.refreshItems = function(input, url, append) {
                  // If they typed in a search, reset skip.
                  if (lastInput !== input) {
                    lastInput = input;
                    options.params.skip = 0;
                  }
                  var selectItems = items;
                  if (input) {
                    selectItems = selectItems.filter(function(item) {
                      // Get the visible string from the interpolated item.
                      var value = $interpolate($scope.component.template)({item: item}).replace(/<(?:.|\n)*?>/gm, '');
                      switch ($scope.component.filter) {
                        case 'startsWith':
                          return value.toLowerCase().indexOf(input.toLowerCase()) !== -1;
                        case 'contains':
                        default:
                          return value.toLowerCase().lastIndexOf(input.toLowerCase(), 0) === 0;
                      }
                    });
                  }
                  options.params.skip = parseInt(options.params.skip, 10);
                  options.params.limit = parseInt(options.params.limit, 10);
                  selectItems = selectItems.slice(options.params.skip, options.params.skip + options.params.limit);
                  setResult(selectItems, append);
                  return initialized.resolve($scope.selectItems);
                };
                $scope.refreshItems();
                break;
              case 'custom':
                $scope.refreshItems = function() {
                  try {
                    /* eslint-disable no-unused-vars */
                    var data = _cloneDeep($scope.submission.data);
                    var row = _cloneDeep($scope.data);
                    /* eslint-enable no-unused-vars */
                    $scope.selectItems = eval('(function(data, row) { var values = [];' + settings.data.custom.toString() + '; return values; })(data, row)');
                  }
                  catch (error) {
                    $scope.selectItems = [];
                  }
                  return initialized.resolve($scope.selectItems);
                };
                $scope.refreshItems();
                break;
              case 'url':
              case 'resource':
                var url = '';
                if (settings.dataSrc === 'url') {
                  url = settings.data.url;
                  if (url.substr(0, 1) === '/') {
                    url = Formio.getBaseUrl() + settings.data.url;
                  }

                  // Disable auth for outgoing requests.
                  if (!settings.authenticate && url.indexOf(Formio.getBaseUrl()) === -1) {
                    options.disableJWT = true;
                    options.headers = options.headers || {};
                    options.headers.Authorization = undefined;
                    options.headers.Pragma = undefined;
                    options.headers['Cache-Control'] = undefined;
                  }
                }
                else {
                  url = Formio.getBaseUrl();
                  if (settings.data.project) {
                    url += '/project/' + settings.data.project;
                  }
                  url += '/form/' + settings.data.resource + '/submission';
                }

                options.params = {
                  limit: $scope.component.limit || 100,
                  skip: 0
                };

                $scope.loadMoreItems = function($select, $event) {
                  $event.stopPropagation();
                  $event.preventDefault();
                  options.params.skip = parseInt(options.params.skip, 10);
                  options.params.skip += parseInt(options.params.limit, 10);
                  $scope.refreshItems(true, null, true);
                };

                if (url) {
                  $scope.hasNextPage = true;
                  $scope.refreshItems = function(input, newUrl, append) {
                    if (typeof input === 'string') {
                      if (input === lastInput) {
                        return;
                      }
                      else {
                        // Since the search has changed, reset the limit and skip.
                        options.params.limit = $scope.component.limit || 100;
                        options.params.skip = 0;
                      }
                    }

                    lastInput = input;
                    newUrl = newUrl || url;
                    newUrl = $interpolate(newUrl)({
                      data: $scope.data,
                      formioBase: $rootScope.apiBase || 'https://api.form.io'
                    });
                    if (!newUrl) {
                      return;
                    }

                    // If this is a search, then add that to the filter.
                    if (
                      settings.searchField &&
                      (typeof input === 'string') &&
                      input
                    ) {
                      options.params[encodeURIComponent(settings.searchField)] = encodeURIComponent(input);
                    }
                    else {
                      delete options.params[encodeURIComponent(settings.searchField)];
                    }

                    // Add the other filter.
                    if (settings.filter) {
                      var filter = $interpolate(settings.filter)({data: $scope.data});
                      // This changes 'a=b&c=d' into an object and assigns to params.
                      _assign(options.params, JSON.parse('{"' + decodeURI(filter).replace(/"/g, '\\"').replace(/&/g, '","').replace(/=/g,'":"') + '"}'));
                    }

                    // If they wish to return only some fields.
                    if (settings.selectFields) {
                      options.params.select = settings.selectFields;
                    }

                    // Set the new result.
                    var setResult = function(data) {
                      // coerce the data into an array.
                      if (!(data instanceof Array)) {
                        data = [data];
                      }

                      if (data.length < options.params.limit) {
                        $scope.hasNextPage = false;
                      }
                      else {
                        $scope.hasNextPage = true;
                      }
                      if (append) {
                        $scope.selectItems = $scope.selectItems.concat(data);
                      }
                      else {
                        $scope.selectItems = data;
                      }

                      // Ensure the value is set to what it should be set to.
                      ensureValue();
                    };

                    var promise;
                    if (settings.dataSrc === 'resource') {
                      promise = (new Formio(newUrl)).loadSubmissions(options);
                    }
                    else {
                      // Add in headers if specified
                      if ($scope.component.data.hasOwnProperty('headers') && $scope.component.data.headers.length > 0) {
                        options.headers = _assign(options.headers, $scope.component.data.headers.reduce(function(headers, current) {
                          if (current.key) {
                            headers[current.key] = current.value;
                          }
                          return headers;
                        }, {}));
                      }
                      //If disableLimit is true and data source is 'url' then removing 'limit' and 'skip' parameters from options.
                      if (settings.dataSrc === 'url' && settings.data.disableLimit) {
                        delete options.params.limit;
                        delete options.params.skip;
                      }
                      promise = $http.get(newUrl, options).then(function(result) {
                        return result.data;
                      });
                    }

                    return promise.then(function(data) {
                      if (data) {
                        // If the selectValue prop is defined, use it.
                        if (selectValues) {
                          setResult(_get(data, selectValues, []));
                        }
                        // Attempt to default to the formio settings for a resource.
                        else if (data.hasOwnProperty('data')) {
                          setResult(data.data);
                        }
                        else if (data.hasOwnProperty('items')) {
                          setResult(data.items);
                        }
                        // Use the data itself.
                        else {
                          setResult(data);
                        }
                      }
                      return $scope.selectItems;
                    }).finally(function() {
                      initialized.resolve($scope.selectItems);
                    });
                  };
                  $scope.refreshItems(true);
                }
                ensureValue();
                break;
              default:
                $scope.selectItems = [];
                initialized.resolve($scope.selectItems);
            }
          }
        ],
        settings: {
          input: true,
          tableView: true,
          label: '',
          key: 'selectField',
          placeholder: '',
          data: {
            values: [],
            json: '',
            url: '',
            resource: '',
            custom: ''
          },
          dataSrc: 'values',
          valueProperty: '',
          defaultValue: '',
          refreshOn: '',
          filter: '',
          authenticate: false,
          template: '<span>{{ item.label }}</span>',
          multiple: false,
          protected: false,
          unique: false,
          persistent: true,
          hidden: false,
          clearOnHide: true,
          validate: {
            required: false
          }
        }
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/components/select.html',
        "<label ng-if=\"component.label && !component.hideLabel\"  for=\"{{ componentId }}\" class=\"control-label\" ng-class=\"{'field-required': isRequired(component)}\">{{ component.label | formioTranslate:null:builder }}</label>\r\n<span ng-if=\"!component.label && isRequired(component)\" class=\"glyphicon glyphicon-asterisk form-control-feedback field-required-inline\" aria-hidden=\"true\"></span>\r\n<ui-select\r\n  ui-select-required\r\n  ui-select-open-on-focus\r\n  ng-model=\"data[component.key]\"\r\n  safe-multiple-to-single\r\n  name=\"{{ componentId }}\"\r\n  ng-disabled=\"readOnly\"\r\n  ng-required=\"isRequired(component)\"\r\n  id=\"{{ componentId }}\"\r\n  theme=\"bootstrap\"\r\n  custom-validator=\"component.validate.custom\"\r\n  tabindex=\"{{ component.tabindex || 0 }}\"\r\n>\r\n  <ui-select-match class=\"ui-select-match\" placeholder=\"{{ component.placeholder | formioTranslate:null:builder }}\">\r\n    <formio-select-item template=\"component.template\" item=\"$item || $select.selected\" select=\"$select\"></formio-select-item>\r\n  </ui-select-match>\r\n  <ui-select-choices class=\"ui-select-choices\" repeat=\"getSelectItem(item) as item in selectItems | filter: $select.search\" refresh=\"refreshItems($select.search)\" refresh-delay=\"250\">\r\n    <formio-select-item template=\"component.template\" item=\"item\" select=\"$select\"></formio-select-item>\r\n    <button ng-if=\"hasNextPage && ($index == $select.items.length-1)\" class=\"btn btn-success btn-block\" ng-click=\"loadMoreItems($select, $event)\" ng-disabled=\"selectLoading\">Load more...</button>\r\n  </ui-select-choices>\r\n</ui-select>\r\n<div ng-if=\"!!component.description\" class=\"help-block\">\r\n  <span>{{ component.description }}</span>\r\n</div>\r\n<formio-errors ng-if=\"::!builder\"></formio-errors>\r\n"
      );

      // Change the ui-select to ui-select multiple.
      $templateCache.put('formio/components/select-multiple.html',
        $templateCache.get('formio/components/select.html').replace('<ui-select', '<ui-select multiple')
      );
    }
  ]);
};

},{"lodash/assign":152,"lodash/cloneDeep":153,"lodash/get":157,"lodash/isEqual":164,"lodash/set":175}],209:[function(_dereq_,module,exports){
"use strict";


module.exports = function(app) {
  app.directive('formioSelectBoxes', [function() {
    return {
      restrict: 'E',
      replace: true,
      require: 'ngModel',
      scope: {
        component: '=',
        componentId: '=',
        readOnly: '=',
        model: '=ngModel',
        gridRow: '=',
        gridCol: '=',
        builder: '=?'
      },
      templateUrl: 'formio/components/selectboxes-directive.html',
      link: function($scope, el, attrs, ngModel) {
        if ($scope.builder) return;
        // Initialize model
        var model = {};
        angular.forEach($scope.component.values, function(v) {
          model[v.value] = ngModel.$viewValue.hasOwnProperty(v.value)
            ? !!ngModel.$viewValue[v.value]
            : false;
        });
        // FA-835 - Update the view model with our defaults.
        // FA-921 - Attempt to load a current model, if present before the defaults.
        ngModel.$setViewValue($scope.model || model);

        ngModel.$setPristine(true);
        ngModel.$isEmpty = function(value) {
          if (typeof value === 'undefined') {
            return true;
          }

          return Object.keys(value).every(function(key) {
            return !value[key];
          });
        };

        $scope.toggleCheckbox = function(value) {
          var _model = angular.copy(ngModel.$viewValue || {});
          _model[value] = !_model[value];
          ngModel.$setViewValue(_model);
        };
      }
    };
  }]);

  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('selectboxes', {
        title: 'Select Boxes',
        template: 'formio/components/selectboxes.html',
        tableView: function(data, component) {
          if (!data) return '';

          return Object.keys(data)
          .filter(function(key) {
            return data[key];
          })
          .map(function(data) {
            component.values.forEach(function(item) {
              if (item.value === data) {
                data = item.label;
              }
            });
            return data;
          })
          .join(', ');
        },
        settings: {
          input: true,
          tableView: true,
          label: '',
          key: 'selectboxesField',
          values: [],
          inline: false,
          protected: false,
          persistent: true,
          hidden: false,
          clearOnHide: true,
          validate: {
            required: false
          }
        }
      });
    }
  ]);

  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/components/selectboxes-directive.html',
        "<div class=\"select-boxes\">\r\n  <div ng-class=\"component.inline ? 'checkbox-inline' : 'checkbox'\" ng-repeat=\"v in component.values track by $index\">\r\n    <label class=\"control-label\" for=\"{{ componentId }}-{{ v.value }}\">\r\n      <input type=\"checkbox\"\r\n        id=\"{{ componentId }}-{{ v.value }}\"\r\n        name=\"{{ componentId }}-{{ v.value }}\"\r\n        value=\"{{ v.value }}\"\r\n        tabindex=\"{{ component.tabindex || 0 }}\"\r\n        ng-disabled=\"readOnly\"\r\n        ng-click=\"toggleCheckbox(v.value)\"\r\n        ng-checked=\"model[v.value]\"\r\n        grid-row=\"gridRow\"\r\n        grid-col=\"gridCol\"\r\n      >\r\n      {{ v.label | formioTranslate:null:builder }}\r\n    </label>\r\n  </div>\r\n</div>\r\n"
      );
      $templateCache.put('formio/components/selectboxes.html',
        "<div class=\"select-boxes\">\r\n  <label ng-if=\"component.label && !component.hideLabel\" for=\"{{ componentId }}\" class=\"control-label\" ng-class=\"{'field-required': isRequired(component)}\">\r\n    {{ component.label }}\r\n  </label>\r\n  <formio-select-boxes\r\n    name=\"{{componentId}}\"\r\n    ng-model=\"data[component.key]\"\r\n    ng-model-options=\"{allowInvalid: true}\"\r\n    component=\"component\"\r\n    component-id=\"componentId\"\r\n    read-only=\"readOnly\"\r\n    ng-required=\"isRequired(component)\"\r\n    custom-validator=\"component.validate.custom\"\r\n    grid-row=\"gridRow\"\r\n    grid-col=\"gridCol\"\r\n    builder=\"builder\"\r\n  ></formio-select-boxes>\r\n  <div ng-if=\"!!component.description\" class=\"help-block\">\r\n    <span>{{ component.description }}</span>\r\n  </div>\r\n  <formio-errors ng-if=\"::!builder\"></formio-errors>\r\n</div>\r\n"
      );
    }
  ]);
};

},{}],210:[function(_dereq_,module,exports){
"use strict";

var SignaturePad = _dereq_('signature_pad');
module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('signature', {
        title: 'Signature',
        template: 'formio/components/signature.html',
        tableView: function(data) {
          return data ? 'Yes' : 'No';
        },
        group: 'advanced',
        settings: {
          input: true,
          tableView: true,
          label: '',
          key: 'signature',
          placeholder: '',
          footer: 'Sign above',
          width: '100%',
          height: '150',
          penColor: 'black',
          backgroundColor: 'rgb(245,245,235)',
          minWidth: '0.5',
          maxWidth: '2.5',
          protected: false,
          persistent: true,
          hidden: false,
          clearOnHide: true,
          validate: {
            required: false
          }
        },
        viewTemplate: 'formio/componentsView/signature.html'
      });
    }
  ]);
  app.directive('signature', function() {
    return {
      restrict: 'A',
      scope: {
        component: '='
      },
      require: '?ngModel',
      link: function(scope, element, attrs, ngModel) {
        if (scope.builder) return;
        if (!ngModel) {
          return;
        }

        // Sets the label of component for error display.
        scope.component.label = 'Signature';
        scope.component.hideLabel = true;

        // Sets the dimension of a width or height.
        var setDimension = function(dim) {
          var param = (dim === 'width') ? 'clientWidth' : 'clientHeight';
          if (scope.component[dim].slice(-1) === '%') {
            var percent = parseFloat(scope.component[dim].slice(0, -1)) / 100;
            element[0][dim] = element.parent().eq(0)[0][param] * percent;
          }
          else {
            element[0][dim] = parseInt(scope.component[dim], 10);
            scope.component[dim] = element[0][dim] + 'px';
          }
        };

        // Set the width and height of the canvas.
        // Reset size if element changes visibility.
        scope.$watch('component.display', function() {
          setDimension('width');
          setDimension('height');
        });

        // Create the signature pad.
        var signaturePad = new SignaturePad(element[0], {
          minWidth: scope.component.minWidth,
          maxWidth: scope.component.maxWidth,
          penColor: scope.component.penColor,
          backgroundColor: scope.component.backgroundColor
        });

        scope.$watch('component.penColor', function(newValue) {
          signaturePad.penColor = newValue;
        });

        scope.$watch('component.backgroundColor', function(newValue) {
          signaturePad.backgroundColor = newValue;
          signaturePad.clear();
        });

        // Clear the signature.
        scope.component.clearSignature = function() {
          signaturePad.clear();
          readSignature();
        };

        // Set some CSS properties.
        element.css({
          'border-radius': '4px',
          'box-shadow': '0 0 5px rgba(0, 0, 0, 0.02) inset',
          'border': '1px solid #f4f4f4'
        });

        function readSignature() {
          if (scope.$parent.isRequired(scope.component) && signaturePad.isEmpty()) {
            ngModel.$setViewValue('');
          }
          else {
            ngModel.$setViewValue(signaturePad.toDataURL());
          }
        }

        ngModel.$render = function() {
          signaturePad.fromDataURL(ngModel.$viewValue);
        };
        signaturePad.onEnd = function() {
          scope.$evalAsync(readSignature);
        };
      }
    };
  });
  app.run([
    '$templateCache',
    'FormioUtils',
    function($templateCache,
              FormioUtils) {
      $templateCache.put('formio/components/signature.html', FormioUtils.fieldWrap(
        "<div ng-if=\"readOnly\">\r\n  <div ng-if=\"data[component.key] === 'YES'\">\r\n    [ Signature is hidden ]\r\n  </div>\r\n  <div ng-if=\"data[component.key] !== 'YES'\">\r\n    <img class=\"signature\" ng-attr-src=\"{{data[component.key]}}\" src=\"\" />\r\n  </div>\r\n</div>\r\n<div ng-if=\"!readOnly\" style=\"width: {{ component.width }}; height: 100%\">\r\n  <a class=\"btn btn-xs btn-default\" style=\"position:absolute; left: 0; top: 0; z-index: 1000\" ng-click=\"component.clearSignature()\">\r\n    <span class=\"glyphicon glyphicon-refresh\"></span>\r\n  </a>\r\n  <canvas signature component=\"component\" name=\"{{ componentId }}\" ng-model=\"data[component.key]\" ng-required=\"isRequired(component)\"></canvas>\r\n  <div class=\"formio-signature-footer\" style=\"text-align: center;color:#C3C3C3;\" ng-class=\"{'field-required': isRequired(component)}\">{{ component.footer | formioTranslate:null:builder }}</div>\r\n</div>\r\n"
      ));

      $templateCache.put('formio/componentsView/signature.html', FormioUtils.fieldWrap(
        "<div ng-if=\"data[component.key] === 'YES'\">\r\n  [ Signature is hidden ]\r\n</div>\r\n<div ng-if=\"data[component.key] && (data[component.key] !== 'YES')\">\r\n  <img class=\"signature\" ng-attr-src=\"{{ data[component.key] }}\" src=\"\" />\r\n</div>\r\n<div class=\"well text-center\" ng-if=\"!data[component.key] || (data[component.key] === 'NO')\">\r\n  <strong>No signature provided</strong>\r\n</div>\r\n"
      ));
    }
  ]);
};

},{"signature_pad":181}],211:[function(_dereq_,module,exports){
"use strict";


module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('survey', {
        title: 'Survey',
        template: 'formio/components/survey.html',
        group: 'advanced',
        tableView: function(data, component) {
          var view = '<table class="table table-striped table-bordered"><thead>';
          var values = {};
          angular.forEach(component.values, function(v) {
            values[v.value] = v.label;
          });
          angular.forEach(component.questions, function(question) {
            view += '<tr>';
            view += '<th>' + question.label + '</th>';
            view += '<td>' + values[data[question.value]] + '</td>';
            view += '</tr>';
          });
          view += '</tbody></table>';
          return view;
        },
        settings: {
          input: true,
          tableView: true,
          label: '',
          key: 'survey',
          questions: [],
          values: [],
          defaultValue: '',
          protected: false,
          persistent: true,
          hidden: false,
          clearOnHide: true,
          validate: {
            required: false,
            custom: '',
            customPrivate: false
          }
        }
      });
    }
  ]);
  app.run([
    '$templateCache',
    'FormioUtils',
    function($templateCache, FormioUtils) {
      $templateCache.put('formio/components/survey.html', FormioUtils.fieldWrap(
        "<table class=\"table table-striped table-bordered\">\r\n  <thead>\r\n    <tr>\r\n      <td></td>\r\n      <th ng-repeat=\"v in component.values track by $index\" style=\"text-align: center;\">{{ v.label }}</th>\r\n    </tr>\r\n  </thead>\r\n  <tr ng-repeat=\"question in component.questions\">\r\n    <td>{{ question.label }}</td>\r\n    <td ng-repeat=\"v in component.values track by $index\" style=\"text-align: center;\">\r\n      <input\r\n        type=\"radio\"\r\n        id=\"{{ componentId }}-{{ question.value }}-{{ v.value }}\" name=\"{{ componentId }}-{{ question.value }}\"\r\n        tabindex=\"{{ component.tabindex || 0 }}\"\r\n        ng-value=\"v.value\"\r\n        ng-model=\"data[component.key][question.value]\"\r\n        ng-required=\"isRequired(component)\"\r\n        ng-disabled=\"readOnly\"\r\n        custom-validator=\"component.validate.custom\"\r\n      >\r\n    </td>\r\n  </tr>\r\n</table>\r\n"
      ));
    }
  ]);
};

},{}],212:[function(_dereq_,module,exports){
"use strict";

var GridUtils = _dereq_('../factories/GridUtils')();

module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('table', {
        title: 'Table',
        template: 'formio/components/table.html',
        group: 'layout',
        settings: {
          input: false,
          key: 'table',
          numRows: 3,
          numCols: 3,
          rows: [[{components: []}, {components: []}, {components: []}], [{components: []}, {components: []}, {components: []}], [{components: []}, {components: []}, {components: []}]],
          header: [],
          caption: '',
          striped: false,
          bordered: false,
          hover: false,
          condensed: false,
          tableView: true
        },
        tableView: function(data, component, $interpolate, componentInfo, tableChild) {
          var view = '<table class="table table-striped table-bordered table-child">';

          if (!tableChild) {
            view += '<thead>';
            view += '<tr><th>Table (' + component.key + ')</th></tr>';
            view += '</thead>';
          }

          view += '<tbody>';

          for (var row = 0; row < this.settings.numRows; row++) {
            view += '<tr>';
            for (var col = 0; col < this.settings.numCols; col++) {
              view += '<td>';
              // Each column is its own table.
              view += '<table class="table table-striped table-bordered table-child">';
              view += '<tbody>';
              angular.forEach(component.rows[row][col].components, function(component) {
                view += '<tr>' + GridUtils.columnForComponent(data, component, $interpolate, componentInfo) + '</tr>';
              });

              view += '</tbody></table>';
              view += '</td>';
            }
            view += '</tr>';
          }

          view += '</tbody></table>';
          return view;
        }
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      var tableClasses = "{'table-striped': component.striped, ";
      tableClasses += "'table-bordered': component.bordered, ";
      tableClasses += "'table-hover': component.hover, ";
      tableClasses += "'table-condensed': component.condensed}";
      $templateCache.put('formio/components/table.html',
        "<div class=\"table-responsive\" id=\"{{ component.key }}\">\r\n  <table ng-class=\"{'table-striped': component.striped, 'table-bordered': component.bordered, 'table-hover': component.hover, 'table-condensed': component.condensed}\" class=\"table\">\r\n    <thead ng-if=\"component.header.length\">\r\n      <th ng-repeat=\"header in component.header track by $index\">{{ header | formioTranslate:null:builder }}</th>\r\n    </thead>\r\n    <tbody>\r\n      <tr ng-repeat=\"row in component.rows track by $index\">\r\n        <td ng-repeat=\"column in row track by $index\">\r\n          <formio-component\r\n            ng-repeat=\"_component in column.components track by $index\"\r\n            component=\"_component\"\r\n            data=\"data\"\r\n            formio=\"formio\"\r\n            submission=\"submission\"\r\n            hide-components=\"hideComponents\"\r\n            ng-if=\"builder ? '::true' : isVisible(_component, data)\"\r\n            formio-form=\"formioForm\"\r\n            read-only=\"isDisabled(_component, data)\"\r\n            grid-row=\"gridRow\"\r\n            grid-col=\"gridCol\"\r\n            builder=\"builder\"\r\n          ></formio-component>\r\n        </td>\r\n      </tr>\r\n    </tbody>\r\n  </table>\r\n</div>\r\n"
      );

      $templateCache.put('formio/componentsView/table.html',
        "<div class=\"table-responsive\" id=\"{{ component.key }}\">\r\n  <table ng-class=\"{'table-striped': component.striped, 'table-bordered': component.bordered, 'table-hover': component.hover, 'table-condensed': component.condensed}\" class=\"table\">\r\n    <thead ng-if=\"component.header.length\">\r\n      <th ng-repeat=\"header in component.header track by $index\">{{ header }}</th>\r\n    </thead>\r\n    <tbody>\r\n      <tr ng-repeat=\"row in component.rows track by $index\">\r\n        <td ng-repeat=\"column in row track by $index\">\r\n          <formio-component-view\r\n            ng-repeat=\"_component in column.components track by $index\"\r\n            component=\"_component\"\r\n            data=\"data\"\r\n            form=\"form\"\r\n            submission=\"submission\"\r\n            ignore=\"ignore\"\r\n            ng-if=\"builder ? '::true' : isVisible(_component, data)\"\r\n            builder=\"builder\"\r\n          ></formio-component-view>\r\n        </td>\r\n      </tr>\r\n    </tbody>\r\n  </table>\r\n</div>\r\n"
      );
    }
  ]);
};

},{"../factories/GridUtils":229}],213:[function(_dereq_,module,exports){
"use strict";

module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('textarea', {
        title: 'Text Area',
        template: function($scope) {
          if (!$scope.readOnly && $scope.component.wysiwyg) {
            var defaults = {
              toolbarGroups:  [
                {name: 'basicstyles', groups: ['basicstyles', 'cleanup']},
                {name: 'paragraph', groups: ['list', 'indent', 'blocks', 'align', 'bidi', 'paragraph', '-', 'JustifyLeft', 'JustifyCenter', 'JustifyRight', 'JustifyBlock']},
                {name: 'links', groups: ['links']},
                {name: 'insert', groups: ['insert']},
                '/',
                {name: 'styles', groups: ['Styles', 'Format', 'Font', 'FontSize']},
                {name: 'colors', groups: ['colors']},
                {name: 'clipboard', groups: ['clipboard', 'undo']},
                {name: 'editing', groups: ['find', 'selection', 'spellchecker', 'editing']},
                {name: 'document', groups: ['mode', 'document', 'doctools']},
                {name: 'others', groups: ['others']},
                {name: 'tools', groups: ['tools']}
              ],
              extraPlugins: 'justify,font',
              removeButtons: 'Cut,Copy,Paste,Underline,Subscript,Superscript,Scayt,About',
              uiColor: '#eeeeee',
              height: '400px',
              width: '100%'
            };
            if ($scope.component.wysiwyg === true) {
              $scope.component.wysiwyg = defaults;
            }
            else {
              $scope.component.wysiwyg = angular.extend(defaults, $scope.component.wysiwyg);
            }
            return 'formio/components/texteditor.html';
          }
          return 'formio/components/textarea.html';
        },
        settings: {
          input: true,
          tableView: true,
          label: '',
          key: 'textareaField',
          placeholder: '',
          prefix: '',
          suffix: '',
          rows: 3,
          multiple: false,
          defaultValue: '',
          protected: false,
          persistent: true,
          hidden: false,
          wysiwyg: false,
          clearOnHide: true,
          validate: {
            required: false,
            minLength: '',
            maxLength: '',
            pattern: '',
            custom: ''
          }
        }
      });
    }
  ]);
  app.run([
    '$templateCache',
    'FormioUtils',
    function($templateCache,
              FormioUtils) {
      $templateCache.put('formio/components/textarea.html', FormioUtils.fieldWrap(
        "<textarea\r\n  class=\"form-control\"\r\n  ng-model=\"data[component.key]\"\r\n  ng-disabled=\"readOnly\"\r\n  ng-required=\"isRequired(component)\"\r\n  safe-multiple-to-single\r\n  id=\"{{ componentId }}\"\r\n  name=\"{{ componentId }}\"\r\n  tabindex=\"{{ component.tabindex || 0 }}\"\r\n  ng-attr-placeholder=\"{{ component.placeholder | formioTranslate:null:builder }}\"\r\n  custom-validator=\"component.validate.custom\"\r\n  rows=\"{{ component.rows }}\"\r\n></textarea>\r\n"
      ));
      $templateCache.put('formio/components/texteditor.html', FormioUtils.fieldWrap(
        "<textarea\r\n  class=\"form-control\"\r\n  ng-model=\"data[component.key]\"\r\n  ng-disabled=\"readOnly\"\r\n  ng-required=\"isRequired(component)\"\r\n  ckeditor=\"component.wysiwyg\"\r\n  safe-multiple-to-single\r\n  id=\"{{ componentId }}\"\r\n  name=\"{{ componentId }}\"\r\n  tabindex=\"{{ component.tabindex || 0 }}\"\r\n  ng-attr-placeholder=\"{{ component.placeholder }}\"\r\n  custom-validator=\"component.validate.custom\"\r\n  rows=\"{{ component.rows }}\"\r\n></textarea>\r\n"
      ));
    }
  ]);
};

},{}],214:[function(_dereq_,module,exports){
"use strict";


module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('textfield', {
        title: 'Text Field',
        template: 'formio/components/textfield.html',
        icon: 'fa fa-terminal',
        settings: {
          input: true,
          tableView: true,
          inputType: 'text',
          inputMask: '',
          label: '',
          key: 'textField',
          placeholder: '',
          prefix: '',
          suffix: '',
          multiple: false,
          defaultValue: '',
          protected: false,
          unique: false,
          persistent: true,
          hidden: false,
          clearOnHide: true,
          validate: {
            required: false,
            minLength: '',
            maxLength: '',
            pattern: '',
            custom: '',
            customPrivate: false
          },
          conditional: {
            show: null,
            when: null,
            eq: ''
          }
        }
      });
    }
  ]);

  app.run([
    '$templateCache',
    'FormioUtils',
    function(
      $templateCache,
      FormioUtils
    ) {
      $templateCache.put('formio/components/textfield.html', FormioUtils.fieldWrap(
        "<input\r\n  type=\"{{ component.inputType }}\"\r\n  class=\"form-control\"\r\n  id=\"{{ componentId }}\"\r\n  name=\"{{ componentId }}\"\r\n  tabindex=\"{{ component.tabindex || 0 }}\"\r\n  ng-disabled=\"readOnly\"\r\n  ng-model=\"data[component.key]\"\r\n  ng-model-options=\"{ debounce: 500 }\"\r\n  safe-multiple-to-single\r\n  ng-required=\"isRequired(component)\"\r\n  ng-minlength=\"component.validate.minLength\"\r\n  ng-maxlength=\"component.validate.maxLength\"\r\n  ng-pattern=\"component.validate.pattern\"\r\n  custom-validator=\"component.validate.custom\"\r\n  ng-attr-placeholder=\"{{ component.placeholder | formioTranslate:null:builder }}\"\r\n  ui-mask=\"{{ component.inputMask }}\"\r\n  ui-mask-placeholder=\"\"\r\n  ui-options=\"uiMaskOptions\"\r\n>\r\n"
      ));
    }
  ]);
};

},{}],215:[function(_dereq_,module,exports){
"use strict";

var GridUtils = _dereq_('../factories/GridUtils')();

module.exports = function(app) {
  app.config([
    'formioComponentsProvider',
    function(formioComponentsProvider) {
      formioComponentsProvider.register('well', {
        title: 'Well',
        template: 'formio/components/well.html',
        group: 'layout',
        settings: {
          key: 'well',
          input: false,
          components: [],
          tableView: true
        },
        viewTemplate: 'formio/componentsView/well.html',
        tableView: function(data, component, $interpolate, componentInfo, tableChild) {
          var view = '<table class="table table-striped table-bordered table-child">';

          if (!tableChild) {
            view += '<thead><tr>';
            view += '<th>Well (' + component.key + ')</th>';
            view += '</tr></thead>';
          }
          view += '<tbody>';
          angular.forEach(component.components, function(component) {
            view += '<tr>' + GridUtils.columnForComponent(data, component, $interpolate, componentInfo, true) + '</tr>';
          });

          view += '</tbody></table>';
          return view;
        }
      });
    }
  ]);
  app.run([
    '$templateCache',
    function($templateCache) {
      $templateCache.put('formio/components/well.html',
        "<div class=\"well\" id=\"{{ component.key }}\">\r\n  <formio-component\r\n    ng-repeat=\"_component in component.components track by $index\"\r\n    component=\"_component\"\r\n    data=\"data\"\r\n    formio=\"formio\"\r\n    submission=\"submission\"\r\n    hide-components=\"hideComponents\"\r\n    ng-if=\"builder ? '::true' : isVisible(_component, data)\"\r\n    read-only=\"isDisabled(_component, data)\"\r\n    formio-form=\"formioForm\"\r\n    grid-row=\"gridRow\"\r\n    grid-col=\"gridCol\"\r\n    builder=\"builder\"\r\n  ></formio-component>\r\n</div>\r\n"
      );
      $templateCache.put('formio/componentsView/well.html',
        "<div class=\"well\" id=\"{{ component.key }}\">\r\n  <formio-component-view\r\n    ng-repeat=\"_component in component.components track by $index\"\r\n    component=\"_component\"\r\n    data=\"data\"\r\n    form=\"form\"\r\n    submission=\"submission\"\r\n    ignore=\"ignore\"\r\n    ng-if=\"builder ? '::true' : isVisible(_component, data)\"\r\n    builder=\"builder\"\r\n  ></formio-component-view>\r\n</div>\r\n"
      );
    }
  ]);
};

},{"../factories/GridUtils":229}],216:[function(_dereq_,module,exports){
"use strict";
module.exports = function() {
  return {
    restrict: 'A',
    require: 'ngModel',
    link: function(scope, ele, attrs, ctrl) {
      if (scope.builder) return;
      if (
        !scope.component.validate ||
        !scope.component.validate.custom
      ) {
        return;
      }

      var _get = function(item, path, def) {
        if (!item) {
          return def || undefined;
        }
        if (!path) {
          return item;
        }

        // If the path is a string, turn it into an array.
        if (typeof path === 'string') {
          path = path.split('.');
        }
        // If the path is an array, take the first element, and recurse its path
        if (path instanceof Array) {
          var current = path.shift();
          if (item.hasOwnProperty(current)) {
            // If there are no more path items, stop here.
            if (path.length === 0) {
              return item[current];
            }

            return _get(item[current], path);
          }

          return undefined;
        }

        return undefined;
      };

      ctrl.$validators.custom = function(modelValue, viewValue) {
        var valid = true;
        /*eslint-disable no-unused-vars */
        var input = modelValue || viewValue;

        // FOR-255 - Enable row data and form data to be visible in the validator.
        var data = scope.submission.data;
        var row = scope.data;
        /*eslint-enable no-unused-vars */

        var custom = scope.component.validate.custom;
        custom = custom.replace(/({{\s{0,}(.*[^\s]){1}\s{0,}}})/g, function(match, $1, $2) {
          return _get(scope.submission.data, $2);
        });

        try {
          /* jshint evil: true */
          eval(custom);
        }
        catch (err) {
          valid = err.message;
        }

        if (valid !== true) {
          scope.component.customError = valid;
          return false;
        }
        return true;
      };
    }
  };
};

},{}],217:[function(_dereq_,module,exports){
"use strict";
module.exports = function() {
  return {
    restrict: 'E',
    replace: true,
    scope: {
      src: '=?',
      url: '=?',
      formAction: '=?',
      form: '=?',
      submission: '=?',
      readOnly: '=?',
      hideComponents: '=?',
      requireComponents: '=?',
      disableComponents: '=?',
      formioOptions: '=?',
      options: '=?'
    },
    controller: [
      '$scope',
      '$http',
      '$element',
      'FormioScope',
      'Formio',
      'FormioUtils',
      '$q',
      function(
        $scope,
        $http,
        $element,
        FormioScope,
        Formio,
        FormioUtils,
        $q
      ) {
        var iframeReady = $q.defer();
        $scope._src = $scope.src || '';
        $scope.formioAlerts = [];
        $scope.iframeReady = false;
        // Shows the given alerts (single or array), and dismisses old alerts
        this.showAlerts = $scope.showAlerts = function(alerts) {
          /* eslint-disable no-empty */
          try {
            alerts.message = (JSON.parse(alerts.message)).data;
          }
          catch (e) {}
          /* eslint-enable no-empty */

          $scope.formioAlerts = [].concat(alerts);
        };

        $scope.getIframeSrc = function(pdf) {
          var iframeSrc = pdf.src + '.html';
          var params = [];
          if ($scope.form.builder) {
            params.push('builder=1');
          }
          if ($scope.readOnly) {
            params.push('readonly=1');
          }
          if (params.length) {
            iframeSrc += '?' + params.join('&');
          }
          return iframeSrc;
        };

        $scope.downloadUrl = '';

        $scope.getPDFDownload = function(pdf) {
          if (!$scope.formio) {
            return;
          }
          var download = '';
          if ($scope.formio && $scope.formio.submissionUrl) {
            download = $scope.formio.submissionUrl;
          }
          else if ($scope.submission._id) {
            download = Formio.baseUrl + '/project/' + $scope.form.project + '/';
            download += '/form/' + $scope.form._id;
            download += '/submission/' + $scope.submission._id;
          }
          if (!download) {
            return;
          }

          download += '/download/' + pdf.id;
          var allowedPath = download.replace(Formio.baseUrl, '');
          allowedPath = allowedPath.replace(Formio.getProjectUrl(), '');
          return $scope.formio.getTempToken(3600, 'GET:' + allowedPath).then(function(tempToken) {
            download += '?token=' + tempToken.key;
            $scope.downloadUrl = download;
            return download;
          });
        };

        // Add the live form parameter to the url.
        if ($scope._src && ($scope._src.indexOf('live=') === -1)) {
          $scope._src += ($scope._src.indexOf('?') === -1) ? '?' : '&';
          $scope._src += 'live=1';
        }

        var sendIframeMessage = function(message) {
          iframeReady.promise.then(function(iframe) {
            iframe.contentWindow.postMessage(JSON.stringify(message), '*');
          });
        };

        $scope.$on('iframe-ready', function() {
          $scope.iframeReady = true;
          var iframe = $element.find('.formio-iframe')[0];
          if (iframe) {
            iframeReady.resolve(iframe);
            if ($scope.form) {
              sendIframeMessage({name: 'form', data: $scope.form});
            }
            if ($scope.submission) {
              sendIframeMessage({name: 'submission', data: $scope.submission});
            }
          }
        });

        $scope.$on('iframeMessage', function(event, message) {
          sendIframeMessage(message);
        });

        var cancelFormLoadEvent = $scope.$on('formLoad', function(event, form) {
          cancelFormLoadEvent();
          iframeReady.promise.then(function() {
            $scope.getPDFDownload(form.settings.pdf);
          });
          sendIframeMessage({name: 'form', data: form});
        });

        $scope.$on('submissionLoad', function(event, submission) {
          submission.editable = !$scope.readOnly;
          sendIframeMessage({name: 'submission', data: submission});
        });

        // Submit the form from the iframe.
        $scope.$on('iframe-submission', function(event, submission) {
          $scope.submitForm(submission);
        });

        // Called from the submit on iframe.
        $scope.submitIFrameForm = function() {
          sendIframeMessage({name: 'getSubmission'});
        };

        $scope.zoomIn = function() {
          sendIframeMessage({name: 'zoomIn'});
        };

        $scope.zoomOut = function() {
          sendIframeMessage({name: 'zoomOut'});
        };

        // FOR-71
        if (!$scope._src && !$scope.builder) {
          $scope.$watch('src', function(src) {
            if (!src) {
              return;
            }
            $scope._src = src;
            $scope.formio = FormioScope.register($scope, $element, {
              form: true,
              submission: true
            });
          });
        }

        // Create the formio object.
        $scope.formio = FormioScope.register($scope, $element, {
          form: true,
          submission: true
        });

        $scope.checkErrors = function(form) {
          if (form.submitting) {
            return true;
          }
          form.$setDirty(true);
          for (var key in form) {
            if (form[key] && form[key].$validate) {
              form[key].$setDirty(true);
              form[key].$validate();
            }
          }
          return !form.$valid;
        };

        $scope.isVisible = function(component, row) {
          return FormioUtils.isVisible(
            component,
            row,
            $scope.submission ? $scope.submission.data : null,
            $scope.hideComponents
          );
        };

        // Show the submit message and say the form is no longer submitting.
        var onSubmit = function(submission, message, form) {
          if (message) {
            $scope.showAlerts({
              type: 'success',
              message: message
            });
          }
          if (form) {
            form.submitting = false;
          }
        };

        // Called when a submission has been made.
        var onSubmitDone = function(method, submission, form) {
          var message = '';
          if ($scope.options && $scope.options.submitMessage) {
            message = $scope.options.submitMessage;
          }
          else {
            message = 'Submission was ' + ((method === 'put') ? 'updated' : 'created') + '.';
          }
          onSubmit(submission, message, form);
          // Trigger the form submission.
          $scope.$emit('formSubmission', submission);
        };

        $scope.submitForm = function(submissionData, form) {
          // Allow custom action urls.
          if ($scope.action) {
            var method = submissionData._id ? 'put' : 'post';
            var action = $scope.action;
            // Add the action Id if it is not already part of the url.
            if (method === 'put' && (action.indexOf(submissionData._id) === -1)) {
              action += '/' + submissionData._id;
            }
            $http[method](action, submissionData).then(function(response) {
              Formio.clearCache();
              onSubmitDone(method, response.data, form);
            }, FormioScope.onError($scope, $element))
              .finally(function() {
                if (form) {
                  form.submitting = false;
                }
              });
          }

          // If they wish to submit to the default location.
          else if ($scope.formio && !$scope.formio.noSubmit) {
            // copy to remove angular $$hashKey
            $scope.formio.saveSubmission(submissionData, $scope.formioOptions).then(function(submission) {
              onSubmitDone(submission.method, submission, form);
            }, FormioScope.onError($scope, $element)).finally(function() {
              if (form) {
                form.submitting = false;
              }
            });
          }
          else {
            $scope.$emit('formSubmission', submissionData);
          }
        };

        $scope.isDisabled = function(component) {
          return $scope.readOnly || component.disabled || (Array.isArray($scope.disableComponents) && $scope.disableComponents.indexOf(component.key) !== -1);
        };

        $scope.isRequired = function(component) {
          return FormioUtils.isRequired(component, $scope.requireComponents);
        };

        // Called when the form is submitted.
        $scope.onSubmit = function(form) {
          $scope.formioAlerts = [];
          if ($scope.checkErrors(form)) {
            $scope.formioAlerts.push({
              type: 'danger',
              message: 'Please fix the following errors before submitting.'
            });
            return;
          }

          form.submitting = true;

          // Create a sanitized submission object.
          var submissionData = {data: {}};
          if ($scope.submission._id) {
            submissionData._id = $scope.submission._id;
          }
          if ($scope.submission.data._id) {
            submissionData._id = $scope.submission.data._id;
          }

          var grabIds = function(input) {
            if (!input) {
              return [];
            }

            if (!(input instanceof Array)) {
              input = [input];
            }

            var final = [];
            input.forEach(function(element) {
              if (element && element._id) {
                final.push(element._id);
              }
            });

            return final;
          };

          var defaultPermissions = {};
          FormioUtils.eachComponent($scope.form.components, function(component) {
            if (component.type === 'resource' && component.key && component.defaultPermission) {
              defaultPermissions[component.key] = component.defaultPermission;
            }
            if ($scope.submission.data.hasOwnProperty(component.key)) {
              var value = $scope.submission.data[component.key];
              if (component.type === 'number' && (value !== null)) {
                submissionData.data[component.key] = value ? parseFloat(value) : 0;
              }
              else {
                submissionData.data[component.key] = value;
              }
            }
          }, true);

          angular.forEach($scope.submission.data, function(value, key) {
            if (value && !value.hasOwnProperty('_id')) {
              submissionData.data[key] = value;
            }

            // Setup the submission access.
            var perm = defaultPermissions[key];
            if (perm) {
              submissionData.access = submissionData.access || [];

              // Coerce value into an array for plucking.
              if (!(value instanceof Array)) {
                value = [value];
              }

              // Try to find and update an existing permission.
              var found = false;
              submissionData.access.forEach(function(permission) {
                if (permission.type === perm) {
                  found = true;
                  permission.resources = permission.resources || [];
                  permission.resources.concat(grabIds(value));
                }
              });

              // Add a permission, because one was not found.
              if (!found) {
                submissionData.access.push({
                  type: perm,
                  resources: grabIds(value)
                });
              }
            }
          });

          // Allow the form to be completed externally.
          $scope.$on('submitDone', function(event, submission, message) {
            onSubmit(submission, message, form);
          });

          // Allow an error to be thrown externally.
          $scope.$on('submitError', function(event, error) {
            FormioScope.onError($scope, $element)(error);
          });

          var submitEvent = $scope.$emit('formSubmit', submissionData);
          if (submitEvent.defaultPrevented) {
            // Listener wants to cancel the form submission
            form.submitting = false;
            return;
          }

          // Make sure to make a copy of the submission data to remove bad characters.
          submissionData = angular.copy(submissionData);
          $scope.submitForm(submissionData, form);
        };
      }
    ],
    templateUrl: 'formio.html'
  };
};

},{}],218:[function(_dereq_,module,exports){
"use strict";
module.exports = ['$sce', '$parse', '$compile', function($sce, $parse, $compile) {
  return {
    restrict: 'A',
    compile: function formioBindHtmlCompile(tElement, tAttrs) {
      var formioBindHtmlGetter = $parse(tAttrs.formioBindHtml);
      $compile.$$addBindingClass(tElement);
      return function formioBindHtmlLink(scope, element, attr) {
        $compile.$$addBindingInfo(element, attr.formioBindHtml);
        var value = formioBindHtmlGetter(scope);
        element.html($sce.getTrustedHtml(value) || '');
      };
    }
  };
}];

},{}],219:[function(_dereq_,module,exports){
"use strict";
var _cloneDeep = _dereq_('lodash/cloneDeep');
var _filter = _dereq_('lodash/filter');
var _get = _dereq_('lodash/get');

// FOR-524 - Attempt to load json logic.
var jsonLogic;
try {
  jsonLogic = _dereq_('json-logic-js') || undefined;
}
catch (e) {
  // Ignore optional module.
}

module.exports = [
  'Formio',
  'formioComponents',
  function(
    Formio,
    formioComponents
  ) {
    return {
      replace: true,
      restrict: 'E',
      require: '?^formio',
      scope: {
        component: '=',
        data: '=',
        submission: '=',
        hideComponents: '=',
        formio: '=',
        formioForm: '=',
        readOnly: '=',
        gridRow: '=',
        gridCol: '=',
        builder: '=?'
      },
      templateUrl: 'formio/component.html',
      link: function(scope, el, attrs, formioCtrl) {
        if (formioCtrl) {
          scope.showAlerts = formioCtrl.showAlerts.bind(formioCtrl);
        }
        else {
          scope.showAlerts = function() {
            throw new Error('Cannot call $scope.showAlerts unless this component is inside a formio directive.');
          };
        }
      },
      controller: [
        '$scope',
        '$http',
        '$controller',
        'FormioUtils',
        '$timeout',
        function(
          $scope,
          $http,
          $controller,
          FormioUtils,
          $timeout
        ) {
          $scope.builder = $scope.builder || false;
          // Options to match jquery.maskedinput masks
          $scope.uiMaskOptions = {
            maskDefinitions: {
              '9': /\d/,
              'a': /[a-zA-Z]/,
              '*': /[a-zA-Z0-9]/
            },
            clearOnBlur: false,
            eventsToHandle: ['input', 'keyup', 'click', 'focus'],
            silentEvents: ['click', 'focus']
          };

          // See if this component is visible or not.
          $scope.isVisible = function(component, row) {
            if ($scope.builder) return true;
            return FormioUtils.isVisible(
              component,
              row,
              $scope.submission ? $scope.submission.data : null,
              $scope.hideComponents
            );
          };

          // FOR-245 - Fix reset buttons.
          $scope.resetForm = function() {
            // Manually remove each key so we don't lose a reference to original
            // data in child scopes.
            for (var key in $scope.data) {
              delete $scope.data[key];
            }
          };

          $scope.isDisabled = function(component) {
            return $scope.readOnly || (typeof $scope.$parent.isDisabled === 'function' && $scope.$parent.isDisabled(component));
          };

          $scope.isRequired = function(component) {
            return FormioUtils.isRequired(component);
          };

          // Pass through checkConditional since this is an isolate scope.
          $scope.checkConditional = $scope.$parent.checkConditional;

          // FOR-71 - Dont watch in the builder view.
          // Calculate value when data changes.
          if (!$scope.builder && ($scope.component.calculateValue || (jsonLogic && _get($scope.component, 'validate.json')))) {
            $scope.$watch('data', function() {
              // Process calculated value stuff if present.
              if ($scope.component.calculateValue) {
                try {
                  $scope.data[$scope.component.key] = eval('(function(data) { var value = [];' + $scope.component.calculateValue.toString() + '; return value; })($scope.data)');
                }
                catch (e) {
                  /* eslint-disable no-console */
                  console.warn('An error occurred calculating a value for ' + $scope.component.key, e);
                  /* eslint-enable no-console */
                }
              }

              // Process jsonLogic stuff if present.
              if (jsonLogic && _get($scope.component, 'validate.json')) {
                var input;

                // Only json parse once.
                if (typeof $scope.component.validate.json === 'string') {
                  try {
                    input = JSON.parse($scope.component.validate.json);
                    $scope.component.validate.json = input;
                  }
                  catch (e) {
                    /* eslint-disable no-console */
                    console.warn('Invalid JSON validator given for ' + $scope.component.key);
                    console.warn($scope.component.validate.json);
                    /* eslint-enable no-console */
                    delete $scope.component.validate.json;
                    return;
                  }
                }
                else {
                  input = $scope.component.validate.json;
                }

                var valid;
                try {
                  valid = jsonLogic.apply(input, {
                    data: $scope.submission.data,
                    row: $scope.data
                  });
                }
                catch (err) {
                  valid = err.message;
                }

                $timeout(function() {
                  try {
                    if (valid !== true) {
                      $scope.component.customError = valid;
                      $scope.formioForm[$scope.component.key].$setValidity('custom', false);
                      return;
                    }

                    $scope.formioForm[$scope.component.key].$setValidity('custom', true);
                  }
                  catch (e) {
                    // Ignore any issues while editing the components.
                  }
                });
              }
            }, true);
          }

          // Get the settings.
          var component = formioComponents.components[$scope.component.type] || formioComponents.components['custom'];

          // Set the component with the defaults from the component settings.
          // Dont add the default key, so that components without keys will remain visible by default.
          angular.forEach(component.settings, function(value, key) {
            if (!$scope.component.hasOwnProperty(key) && key !== 'key') {
              $scope.component[key] = angular.copy(value);
            }
          });

          // Add a new field value.
          $scope.addFieldValue = function() {
            var value = '';
            if ($scope.component.hasOwnProperty('customDefaultValue')) {
              try {
                /* eslint-disable no-unused-vars */
                var data = _cloneDeep($scope.data);
                /* eslint-enable no-unused-vars */
                value = eval('(function(data) { var value = "";' + $scope.component.customDefaultValue.toString() + '; return value; })(data)');
              }
              catch (e) {
                /* eslint-disable no-console */
                console.warn('An error occurrend in a custom default value in ' + $scope.component.key, e);
                /* eslint-enable no-console */
                value = '';
              }
            }
            else if ($scope.component.hasOwnProperty('defaultValue')) {
              // Fix for select components
              if ($scope.component.type === 'select') {
                try {
                  // Allow a key:value search
                  var parts = $scope.component.defaultValue.split(':');
                  var results;
                  // If only one part was specified, search by value
                  /* eslint-disable max-depth */
                  if (parts.length === 1) {
                    results = _filter($scope.selectItems, {value: parts[0]});

                    // Trim results based on multiple
                    if (!$scope.component.multiple) {
                      value = results.shift();
                    }
                    else {
                      value = results;
                    }
                  }
                  // If two parts were specified, allow for key and value customization.
                  else if (parts.length === 2) {
                    var search = {};
                    search[parts[0]] = parts[1];

                    results = _filter($scope.selectItems, search);

                    // Trim results based on multiple
                    if (!$scope.component.multiple) {
                      value = results.shift();
                    }
                    else {
                      value = results;
                    }
                  }
                }
                catch (e) {
                  /* eslint-disable no-console */
                  console.log('An issue occurred with the select defaultValue for: ' + $scope.component.key);
                  console.log('Could not find defaultValue (' + $scope.defaultValue + ') in the selectItems');
                  console.log($scope.selectItems);
                  /* eslint-enable no-console */
                }
              }
              else {
                value = $scope.component.defaultValue;
              }
            }
            $scope.data[$scope.component.key] = $scope.data[$scope.component.key] || [];
            $scope.data[$scope.component.key].push(value);
          };

          // Remove a field value.
          $scope.removeFieldValue = function(index) {
            if (!Array.isArray($scope.data[$scope.component.key])) {
              $scope.data[$scope.component.key] = [];
            }
            $scope.data[$scope.component.key].splice(index, 1);
          };

          // Set the template for the component.
          if (typeof component.template === 'function') {
            $scope.template = component.template($scope);
          }
          else {
            $scope.template = component.template;
          }

          // Allow component keys to look like "settings[username]"
          if ($scope.component.key && $scope.component.key.indexOf('[') !== -1) {
            var matches = $scope.component.key.match(/([^\[]+)\[([^]+)\]/);
            if ((matches.length === 3) && $scope.data.hasOwnProperty(matches[1])) {
              $scope.data = $scope.data[matches[1]];
              $scope.component.key = matches[2];
            }
          }

          // If the component has a controller.
          if (component.controller) {
            // Maintain reverse compatibility by executing the old method style.
            if (typeof component.controller === 'function') {
              component.controller($scope.component, $scope, $http, Formio);
            }
            else {
              $controller(component.controller, {$scope: $scope, $timeout: $timeout});
            }
          }

          // FOR-71 - Dont watch in the builder view.
          if (!$scope.builder) {
            /**
             * Using the list of default options, split them with the identifier, and use filter to get each item.
             *
             * @param defaultItems
             * @param searchItems
             * @returns {Array}
             */
            var pluckItems = function(defaultItems, searchItems) {
              var temp = [];
              if (!defaultItems || !defaultItems.length) {
                return temp;
              }
              if (typeof defaultItems === 'string') {
                defaultItems = [defaultItems];
              }

              defaultItems.forEach(function(item) {
                var parts = item.split(':');
                if (parts.length === 2) {
                  var result = _filter(searchItems, function(potential) {
                    if (_get(potential, parts[0]) === parts[1]) {
                      return true;
                    }
                  });

                  if (result) {
                    temp = temp.concat(result);
                  }
                }
              });

              return temp;
            };

            $scope.$watch('component.multiple', function(mult) {
              // Establish a default for data.
              $scope.data = $scope.data || {};
              var value = null;

              // Use the current data or default.
              if ($scope.data.hasOwnProperty($scope.component.key)) {
                if (!mult) {
                  $scope.data[$scope.component.key] = $scope.data[$scope.component.key];
                  return;
                }

                // If a value is present, and its an array, assign it to the value.
                if ($scope.data[$scope.component.key] instanceof Array) {
                  value = $scope.data[$scope.component.key];
                }
                // If a value is present and it is not an array, wrap the value.
                else {
                  value = $scope.data[$scope.component.key].split(',');
                }

                $scope.data[$scope.component.key] = value;
                return;
              }
              else if ($scope.component.hasOwnProperty('customDefaultValue')) {
                if (!mult) {
                  try {
                    value = eval('(function(data) { var value = "";' + $scope.component.customDefaultValue.toString() + '; return value; })($scope.data)');
                  }
                  catch (e) {
                    /* eslint-disable no-console */
                    console.warn('An error occurrend in a custom default value in ' + $scope.component.key, e);
                    /* eslint-enable no-console */
                    value = '';
                  }
                  $scope.data[$scope.component.key] = value;
                  return;
                }

                try {
                  value = eval('(function(data) { var value = "";' + $scope.component.customDefaultValue.toString() + '; return value; })($scope.data)');
                }
                catch (e) {
                  /* eslint-disable no-console */
                  console.warn('An error occurrend in a custom default value in ' + $scope.component.key, e);
                  /* eslint-enable no-console */
                  value = '';
                }
                $scope.data[$scope.component.key] = value;
                return;
              }
              else if ($scope.component.hasOwnProperty('defaultValue')) {
                // FA-835 - The default values for select boxes are set in the component.
                if ($scope.component.type === 'selectboxes') {
                  return;
                }

                // If there is a default value and it is not an array, wrap the value.
                if (mult && typeof $scope.component.defaultValue === 'string') {
                  value = $scope.component.defaultValue.split(',');
                }
                else {
                  value = $scope.component.defaultValue;
                }

                // If no default is provided, then skip...
                if (!value || !value.length) {
                  return;
                }

                // FOR-193 - Fix default value for the number component.
                // FOR-262 - Fix multiple default value for the number component.
                if ($scope.component.type === 'number') {
                  if (!mult) {
                    // FOR-290 - Fix default values for number components, to allow decimal numbers.
                    if ($scope.component.defaultValue.indexOf('.') !== -1) {
                      $scope.data[$scope.component.key] = parseFloat($scope.component.defaultValue);
                      return;
                    }

                    $scope.data[$scope.component.key] = parseInt($scope.component.defaultValue);
                    return;
                  }

                  $scope.data[$scope.component.key] = value.map(function(item) {
                    try {
                      // FOR-290 - Fix default values for number components, to allow decimal numbers.
                      if (item.indexOf('.') !== -1) {
                        return parseFloat(item);
                      }

                      return parseInt(item);
                    }
                    catch (e) {
                      return 0;
                    }
                  });
                  return;
                }
                // FOR-135 - Add default values for select components.
                else if ($scope.component.type === 'select') {
                  // FOR-337 - Fix default values for select components without multi enabled.
                  if (!mult) {
                    $scope.data[$scope.component.key] = $scope.component.defaultValue;
                    return;
                  }

                  // If using the values input, split the default values, and search the options for each value in the list.
                  if ($scope.component.dataSrc === 'values') {
                    var temp = [];

                    $scope.component.data.values.forEach(function(item) {
                      if (value.indexOf(item.value) !== -1) {
                        temp.push(item);
                      }
                    });

                    $scope.data[$scope.component.key] = temp;
                    return;
                  }
                  // If using json input, split the values and search each key path for the item
                  else if ($scope.component.dataSrc === 'json') {
                    if (typeof $scope.component.data.json === 'string') {
                      try {
                        $scope.component.data.json = JSON.parse($scope.component.data.json);
                      }
                      catch (e) {
                        /* eslint-disable no-console */
                        console.log(e);
                        console.log('Could not parse the given JSON for the select component: ' + $scope.component.key);
                        console.log($scope.component.data.json);
                        /* eslint-enable no-console */
                        $scope.component.data.json = [];
                      }
                    }

                    $scope.data[$scope.component.key] = pluckItems(value, $scope.component.data.json);
                    return;
                  }
                  else if ($scope.component.dataSrc === 'url' || $scope.component.dataSrc === 'resource') {
                    // Wait until loading is done.
                    $scope.$on('selectLoaded', function() {
                      $scope.data[$scope.component.key] = pluckItems(value, $scope.selectItems);
                    });
                  }
                }
                // FOR-504 - Fix default values for survey components.
                else if ($scope.component.type === 'survey') {
                  if (!$scope.component.hasOwnProperty('defaultValue')) {
                    return;
                  }

                  $scope.data[$scope.component.key] = $scope.data[$scope.component.key] || {};
                  $scope.component.questions.forEach(function(question) {
                    $timeout(function() {
                      $scope.data[$scope.component.key][question.value] = $scope.data[$scope.component.key][question.value] || $scope.component.defaultValue;
                    });
                  });
                }
                else {
                  if (!mult) {
                    $scope.data[$scope.component.key] = $scope.component.defaultValue;
                    return;
                  }

                  // If there is a default value and it is an array, assign it to the value.
                  if ($scope.component.defaultValue instanceof Array) {
                    $scope.data[$scope.component.key] = $scope.component.defaultValue;
                    return;
                  }

                  // Make the defaultValue a single element array because were multi.
                  $scope.data[$scope.component.key] = [$scope.component.defaultValue];
                  return;
                }
              }

              // Couldn't safely default, don't add a garbage value.
              return;
            });
          }

          // Set the component name.
          $scope.componentId = $scope.component.key;
          if ($scope.gridRow !== undefined) {
            $scope.componentId += ('-' + $scope.gridRow);
          }
          if ($scope.gridCol !== undefined) {
            $scope.componentId += ('-' + $scope.gridCol);
          }
        }
      ]
    };
  }
];

},{"json-logic-js":11,"lodash/cloneDeep":153,"lodash/filter":156,"lodash/get":157}],220:[function(_dereq_,module,exports){
"use strict";
module.exports = [
  'formioComponents',
  function(
    formioComponents
  ) {
    return {
      replace: true,
      restrict: 'E',
      scope: {
        component: '=',
        data: '=',
        form: '=',
        submission: '=',
        ignore: '=?',
        builder: '=?'
      },
      templateUrl: 'formio/component-view.html',
      controller: [
        '$scope',
        'Formio',
        'FormioUtils',
        function(
          $scope,
          Formio,
          FormioUtils
        ) {
          // Set the form url.
          $scope.formUrl = $scope.form ? Formio.getAppUrl() + '/form/' + $scope.form._id.toString() : '';
          $scope.isVisible = function(component, row) {
            return FormioUtils.isVisible(
              component,
              row,
              $scope.submission ? $scope.submission.data : null,
              $scope.hideComponents
            );
          };

          // Get the settings.
          var component = formioComponents.components[$scope.component.type] || formioComponents.components['custom'];

          // Set the template for the component.
          if (!component.viewTemplate) {
            $scope.template = 'formio/element-view.html';
          }
          else if (typeof component.viewTemplate === 'function') {
            $scope.template = component.viewTemplate($scope);
          }
          else {
            $scope.template = component.viewTemplate;
          }

          // Set the component name.
          $scope.componentId = $scope.component.key;
          if ($scope.gridRow !== undefined) {
            $scope.componentId += ('-' + $scope.gridRow);
          }
          if ($scope.gridCol !== undefined) {
            $scope.componentId += ('-' + $scope.gridCol);
          }
        }
      ]
    };
  }
];

},{}],221:[function(_dereq_,module,exports){
"use strict";
module.exports = function() {
  return {
    restrict: 'E',
    replace: true,
    scope: {
      form: '=?',
      submission: '=?',
      src: '=?',
      formAction: '=?',
      resourceName: '=?',
      message: '=?'
    },
    templateUrl: 'formio-delete.html',
    controller: [
      '$scope',
      '$element',
      'FormioScope',
      'Formio',
      '$http',
      function(
        $scope,
        $element,
        FormioScope,
        Formio,
        $http
      ) {
        $scope._src = $scope.src || '';
        $scope.formioAlerts = [];
        // Shows the given alerts (single or array), and dismisses old alerts
        $scope.showAlerts = function(alerts) {
          $scope.formioAlerts = [].concat(alerts);
        };
        var resourceName = 'resource';
        var methodName = '';
        var loader = FormioScope.register($scope, $element, {
          form: true,
          submission: true
        });

        if (loader) {
          resourceName = loader.submissionId ? 'submission' : 'form';
          var resourceTitle = resourceName.charAt(0).toUpperCase() + resourceName.slice(1);
          methodName = 'delete' + resourceTitle;
        }

        // Set the resource name
        $scope._resourceName = $scope.resourceName || resourceName;
        $scope.deleteMessage = $scope.message || 'Are you sure you wish to delete the ' + $scope._resourceName + '?';

        // Create delete capability.
        $scope.onDelete = function() {
          // Rebuild resourceTitle, $scope.resourceName could have changed
          var resourceName = $scope.resourceName || $scope._resourceName;
          var resourceTitle = resourceName.charAt(0).toUpperCase() + resourceName.slice(1);
          // Called when the delete is done.
          var onDeleteDone = function(data) {
            $scope.showAlerts({
              type: 'success',
              message: resourceTitle + ' was deleted.'
            });
            Formio.clearCache();
            $scope.$emit('delete', data);
          };

          if ($scope.action) {
            $http.delete($scope.action).then(onDeleteDone, FormioScope.onError($scope, $element));
          }
          else if (loader) {
            if (!methodName) return;
            if (typeof loader[methodName] !== 'function') return;
            loader[methodName]().then(onDeleteDone, FormioScope.onError($scope, $element));
          }
        };
        $scope.onCancel = function() {
          $scope.$emit('cancel');
        };
      }
    ]
  };
};

},{}],222:[function(_dereq_,module,exports){
"use strict";
module.exports = [
  '$compile',
  '$templateCache',
  function(
    $compile,
    $templateCache
  ) {
    return {
      scope: false,
      link: function(scope, element) {
        element.replaceWith($compile($templateCache.get(scope.template))(scope));
        scope.$emit('formElementRender', element);
      }
    };
  }
];

},{}],223:[function(_dereq_,module,exports){
"use strict";
module.exports = function() {
  return {
    scope: false,
    restrict: 'E',
    templateUrl: 'formio/errors.html'
  };
};

},{}],224:[function(_dereq_,module,exports){
"use strict";
module.exports = function() {
  return {
    replace: true,
    restrict: 'E',
    scope: {
      form: '=',
      submission: '=',
      ignore: '=?'
    },
    templateUrl: 'formio/submission.html',
    controller: [
      '$scope',
      'FormioUtils',
      function(
        $scope,
        FormioUtils
      ) {
        $scope.isVisible = function(component, row) {
          return FormioUtils.isVisible(
            component,
            row,
            $scope.submission ? $scope.submission.data : null,
            $scope.ignore
          );
        };
      }
    ]
  };
};

},{}],225:[function(_dereq_,module,exports){
"use strict";
module.exports = function() {
  return {
    replace: true,
    restrict: 'E',
    scope: {
      src: '=?',
      form: '=?',
      submissions: '=?',
      perPage: '=?'
    },
    templateUrl: 'formio/submissions.html',
    controller: [
      '$scope',
      '$element',
      'FormioScope',
      function(
        $scope,
        $element,
        FormioScope
      ) {
        $scope._src = $scope.src || '';
        $scope.formioAlerts = [];
        // Shows the given alerts (single or array), and dismisses old alerts
        this.showAlerts = $scope.showAlerts = function(alerts) {
          $scope.formioAlerts = [].concat(alerts);
        };

        $scope.perPage = $scope.perPage === undefined ? 10 : $scope.perPage;
        $scope.formio = FormioScope.register($scope, $element, {
          form: true,
          submissions: true
        });

        $scope.currentPage = 1;
        $scope.pageChanged = function(page) {
          $scope.skip = (page - 1) * $scope.perPage;
          $scope.updateSubmissions();
        };

        $scope.tableView = function(component) {
          return !component.hasOwnProperty('tableView') || component.tableView;
        };

        $scope.$watch('submissions', function(submissions) {
          if (submissions && submissions.length > 0) {
            $scope.$emit('submissionLoad', $scope.submissions);
          }
        });
      }
    ]
  };
};

},{}],226:[function(_dereq_,module,exports){
"use strict";
module.exports = function() {
  return {
    restrict: 'E',
    replace: true,
    templateUrl: 'formio-wizard.html',
    scope: {
      src: '=?',
      url: '=?',
      formAction: '=?',
      form: '=?',
      submission: '=?',
      readOnly: '=?',
      hideComponents: '=?',
      disableComponents: '=?',
      formioOptions: '=?',
      storage: '=?'
    },
    link: function(scope, element) {
      // From https://siongui.github.io/2013/05/12/angularjs-get-element-offset-position/
      var offset = function(elm) {
        try {
          return elm.offset();
        }
        catch (e) {
          // Do nothing...
        }
        var rawDom = elm[0];
        var _x = 0;
        var _y = 0;
        var body = document.documentElement || document.body;
        var scrollX = window.pageXOffset || body.scrollLeft;
        var scrollY = window.pageYOffset || body.scrollTop;
        _x = rawDom.getBoundingClientRect().left + scrollX;
        _y = rawDom.getBoundingClientRect().top + scrollY;
        return {
          left: _x,
          top: _y
        };
      };

      scope.wizardLoaded = false;
      scope.wizardTop = offset(element).top;
      if (scope.wizardTop > 50) {
        scope.wizardTop -= 50;
      }
      scope.wizardElement = angular.element('.formio-wizard', element);
    },
    controller: [
      '$scope',
      '$compile',
      '$element',
      'Formio',
      'FormioScope',
      'FormioUtils',
      '$http',
      '$timeout',
      function(
        $scope,
        $compile,
        $element,
        Formio,
        FormioScope,
        FormioUtils,
        $http,
        $timeout
      ) {
        var session = ($scope.storage && !$scope.readOnly) ? localStorage.getItem($scope.storage) : false;
        if (session) {
          session = angular.fromJson(session);
        }

        $scope.formio = null;
        $scope.url = $scope.url || $scope.src;
        $scope.page = {};
        $scope.pages = [];
        $scope.hasTitles = false;
        $scope.colclass = '';
        if (!$scope.submission || !Object.keys($scope.submission).length) {
          $scope.submission = session ? {data: session.data} : {data: {}};
        }
        $scope.currentPage = session ? session.page : 0;
        $scope.formioAlerts = [];
        $scope.formioOptions = $scope.formioOptions || {};

        var getForm = function() {
          var element = $element.find('#formio-wizard-form');
          if (!element.length) {
            return {};
          }
          return element.children().scope().formioForm;
        };

        // Show the current page.
        var showPage = function(scroll) {
          // When allowing navigate on invsalid
          // prev page alert can be visible.
          // Let's clear it
          $scope.showAlerts(null);
          $scope.pageWasVisited[$scope.currentPage] = true;

          $scope.wizardLoaded = false;
          $scope.page.components = [];
          $scope.page.components.length = 0;
          $timeout(function() {
            // If the page is past the components length, try to clear first.
            if ($scope.currentPage >= $scope.pages.length) {
              $scope.clear();
            }

            if ($scope.storage && !$scope.readOnly) {
              localStorage.setItem($scope.storage, angular.toJson({
                page: $scope.currentPage,
                data: $scope.submission.data
              }));
            }

            $scope.page.components = $scope.pages[$scope.currentPage].components;
            $scope.formioAlerts = [];
            if (scroll) {
              window.scrollTo(0, $scope.wizardTop);
            }
            $scope.wizardLoaded = true;
            $scope.$emit('wizardPage', $scope.currentPage);
            $timeout($scope.$apply.bind($scope));
          });
        };

        if (!$scope.form && $scope.src) {
          (new Formio($scope.src)).loadForm().then(function(form) {
            $scope.form = form;
            if (!$scope.wizardLoaded) {
              showPage();
            }
          });
        }

        // We can be comming back with the 'prev' button.
        // Wait for the form to be loaded.
        // Then timeout to wait the loaded form to be rendered
        // before checking for errors.
        $scope.$on('formLoad', function() {
          if ($scope.pageHasErrors[$scope.currentPage]) {
            $timeout(function() {
              $scope.checkErrors();
            });
          }
        });

        // Shows the given alerts (single or array), and dismisses old alerts
        this.showAlerts = $scope.showAlerts = function(alerts) {
          $scope.formioAlerts = [].concat(alerts);
        };

        $scope.clear = function() {
          if ($scope.storage && !$scope.readOnly) {
            localStorage.setItem($scope.storage, '');
          }
          $scope.submission = {data: {}};
          $scope.currentPage = 0;
        };

        // Check for errors.
        $scope.checkErrors = function() {
          if (!$scope.isValid()) {
            // Change all of the fields to not be pristine.
            angular.forEach($element.find('[name="formioForm"]').children(), function(element) {
              var elementScope = angular.element(element).scope();
              var fieldForm = elementScope.formioForm;
              if (fieldForm[elementScope.component.key]) {
                fieldForm[elementScope.component.key].$pristine = false;
              }
            });
            $scope.formioAlerts = [{
              type: 'danger',
              message: 'Please fix the following errors before proceeding.'
            }];
            return true;
          }
          return false;
        };

        // Submit the submission.
        $scope.submit = function() {
          if ($scope.checkErrors()) {
            return;
          }

          // We want to submit, but free navigation is enabled.
          // Lets check if previous pages where not visited or has errors.
          // If find one, stop searching, go to that page and do not continue with the submission.
          if ($scope.formioOptions.wizardFreeNavigation) {
            var backToPage = null;
            for (var i = 0; i < $scope.pages.length; i++) {
              if ($scope.pageHasErrors[i] || !$scope.pageWasVisited[i]) {
                backToPage = i;
                break;
              }
            }
            if (backToPage !== null) {
              return $scope.goto(backToPage);
            }
          }

          // Create a sanitized submission object.
          var submissionData = {data: {}};
          if ($scope.submission._id) {
            submissionData._id = $scope.submission._id;
          }
          if ($scope.submission.data._id) {
            submissionData._id = $scope.submission.data._id;
          }

          var grabIds = function(input) {
            if (!input) {
              return [];
            }

            if (!(input instanceof Array)) {
              input = [input];
            }

            var final = [];
            input.forEach(function(element) {
              if (element && element._id) {
                final.push(element._id);
              }
            });

            return final;
          };

          var defaultPermissions = {};
          FormioUtils.eachComponent($scope.form.components, function(component) {
            if (component.type === 'resource' && component.key && component.defaultPermission) {
              defaultPermissions[component.key] = component.defaultPermission;
            }
            if (submissionData.data.hasOwnProperty(component.key) && (component.type === 'number')) {
              var value = $scope.submission.data[component.key];
              if (component.type === 'number') {
                submissionData.data[component.key] = value ? parseFloat(value) : 0;
              }
              else {
                submissionData.data[component.key] = value;
              }
            }
          }, true);

          angular.forEach($scope.submission.data, function(value, key) {
            submissionData.data[key] = value;

            // Setup the submission access.
            var perm = defaultPermissions[key];
            if (perm) {
              submissionData.access = submissionData.access || [];

              // Coerce value into an array for plucking.
              if (!(value instanceof Array)) {
                value = [value];
              }

              // Try to find and update an existing permission.
              var found = false;
              submissionData.access.forEach(function(permission) {
                if (permission.type === perm) {
                  found = true;
                  permission.resources = permission.resources || [];
                  permission.resources.concat(grabIds(value));
                }
              });

              // Add a permission, because one was not found.
              if (!found) {
                submissionData.access.push({
                  type: perm,
                  resources: grabIds(value)
                });
              }
            }
          });
          // Strip out any angular keys.
          submissionData = angular.copy(submissionData);

          var submitEvent = $scope.$emit('formSubmit', submissionData);
          if (submitEvent.defaultPrevented) {
              // Listener wants to cancel the form submission
              return;
          }

          var onDone = function(submission) {
            if ($scope.storage && !$scope.readOnly) {
              localStorage.setItem($scope.storage, '');
            }
            $scope.showAlerts({
              type: 'success',
              message: 'Submission Complete!'
            });
            $scope.$emit('formSubmission', submission);
          };

          // Save to specified action.
          if ($scope.action) {
            var method = submissionData._id ? 'put' : 'post';
            $http[method]($scope.action, submissionData).then(function(submission) {
              Formio.clearCache();
              onDone(submission);
            }, FormioScope.onError($scope, $element));
          }
          else if ($scope.formio && !$scope.formio.noSubmit) {
            $scope.formio.saveSubmission(submissionData).then(onDone).catch(FormioScope.onError($scope, $element));
          }
          else {
            onDone(submissionData);
          }
        };

        $scope.cancel = function() {
          $scope.clear();
          showPage(true);
          $scope.$emit('cancel');
        };

        $scope.pageHasErrors = {};
        $scope.pageWasVisited = {};

        // Move onto the next page.
        $scope.next = function() {
          var errors = $scope.checkErrors();
          if (errors) {
            $scope.pageHasErrors[$scope.currentPage] = true;
            if (!$scope.formioOptions.wizardFreeNavigation) {
              return;
            }
          }
          else {
            $scope.pageHasErrors[$scope.currentPage] = false;
          }
          if ($scope.currentPage >= ($scope.pages.length - 1)) {
            return;
          }
          $scope.currentPage++;
          showPage(true);
          $scope.$emit('wizardNext', $scope.currentPage);
        };

        // Move onto the previous page.
        $scope.prev = function() {
          if ($scope.currentPage < 1) {
            return;
          }
          $scope.currentPage--;
          showPage(true);
          $scope.$emit('wizardPrev', $scope.currentPage);
        };

        $scope.goto = function(page) {
          if (page < 0) {
            return;
          }
          if (page >= $scope.pages.length) {
            return;
          }
          var errors = $scope.checkErrors();
          $scope.pageHasErrors[$scope.currentPage] = errors;
          $scope.currentPage = page;
          showPage(true);
        };

        $scope.isValid = function() {
          return getForm().$valid;
        };

        $scope.$on('wizardGoToPage', function(event, page) {
          $scope.goto(page);
        });

        var updatePages = function() {
          if ($scope.pages.length > 6) {
            $scope.margin = ((1 - ($scope.pages.length * 0.0833333333)) / 2) * 100;
            $scope.colclass = 'col-sm-1';
          }
          else {
            $scope.margin = ((1 - ($scope.pages.length * 0.1666666667)) / 2) * 100;
            $scope.colclass = 'col-sm-2';
          }
        };

        var allPages = [];
        var hasConditionalPages = false;
        var setForm = function(form) {
          $scope.pages = [];
          angular.forEach(form.components, function(component) {
            // Only include panels for the pages.
            if (component.type === 'panel') {
              if (!$scope.hasTitles && component.title) {
                $scope.hasTitles = true;
              }
              if (component.customConditional) {
                hasConditionalPages = true;
              }
              else if (component.conditional && component.conditional.when) {
                hasConditionalPages = true;
              }
              // Make sure this page is not in the hide compoenents array.
              if (
                ($scope.hideComponents) &&
                (component.key) &&
                ($scope.hideComponents.indexOf(component.key) !== -1)
              ) {
                return;
              }
              allPages.push(component);
              $scope.pages.push(component);
            }
          });

          // FOR-71
          if (!$scope.builder && hasConditionalPages) {
            $scope.$watch('submission.data', function(data) {
              var newPages = [];
              angular.forEach(allPages, function(page) {
                if (FormioUtils.isVisible(page, null, data)) {
                  newPages.push(page);
                }
              });
              $scope.pages = newPages;
              updatePages();
              setTimeout($scope.$apply.bind($scope), 10);
            }, true);
          }

          $scope.form = $scope.form ? angular.merge($scope.form, angular.copy(form)) : angular.copy(form);
          $scope.page = angular.copy(form);
          $scope.page.display = 'form';
          $scope.$emit('wizardFormLoad', form);
          updatePages();
          showPage();
        };

        // FOR-71
        if (!$scope.builder) {
          $scope.$watch('form', function(form) {
            if (
              $scope.src ||
              !form ||
              !Object.keys(form).length ||
              !form.components ||
              !form.components.length
            ) {
              return;
            }
            var formUrl = form.project ? '/project/' + form.project : '';
            formUrl += '/form/' + form._id;
            $scope.formio = new Formio(formUrl);
            setForm(form);
          });
        }

        // When the components length changes update the pages.
        $scope.$watch('form.components.length', updatePages);

        // Load the form.
        if ($scope.src) {
          $scope.formio = new Formio($scope.src);
          $scope.formio.loadForm().then(function(form) {
            setForm(form);
          });
        }
        else {
          $scope.src = '';
          $scope.formio = new Formio($scope.src);
        }
      }
    ]
  };
};

},{}],227:[function(_dereq_,module,exports){
"use strict";
module.exports = [
  'Formio',
  'formioComponents',
  '$timeout',
  function(
    Formio,
    formioComponents,
    $timeout
  ) {
    return {
      onError: function($scope, $element) {
        return function(error) {
          if ((error.name === 'ValidationError') && $element) {
            $element.find('#form-group-' + error.details[0].path).addClass('has-error');
            var message = 'ValidationError: ' + error.details[0].message;
            $scope.showAlerts({
              type: 'danger',
              message: message
            });
          }
          else {
            if (error instanceof Error) {
              error = error.toString();
            }
            else if (typeof error === 'object') {
              error = JSON.stringify(error);
            }
            $scope.showAlerts({
              type: 'danger',
              message: error
            });
          }
          $scope.$emit('formError', error);
        };
      },
      register: function($scope, $element, options) {
        var loader = null;
        $scope.formLoading = true;
        $scope.form = angular.isDefined($scope.form) ? $scope.form : {};
        $scope.submission = angular.isDefined($scope.submission) ? $scope.submission : {data: {}};
        $scope.submissions = angular.isDefined($scope.submissions) ? $scope.submissions : [];

        // Keep track of the elements rendered.
        var elementsRendered = 0;
        $scope.$on('formElementRender', function() {
          elementsRendered++;
          if (elementsRendered === $scope.form.components.length) {
            $timeout(function() {
              $scope.$emit('formRender', $scope.form);
            });
          }
        });

        $scope.setLoading = function(_loading) {
          $scope.formLoading = _loading;
        };

        // Used to set the form action.
        var getAction = function(action) {
          if (!action) return '';
          if (action.substr(0, 1) === '/') {
            action = Formio.getBaseUrl() + action;
          }
          return action;
        };

        // Set the action.
        $scope.action = getAction($scope.formAction);

        // Allow sub components the ability to add new form components to the form.
        var addedData = {};
        $scope.$on('addFormComponent', function(event, component) {
          if (!addedData.hasOwnProperty(component.settings.key)) {
            addedData[component.settings.key] = true;
            var defaultComponent = formioComponents.components[component.type];
            $scope.form.components.push(angular.extend(defaultComponent.settings, component.settings));
          }
        });

        // Set the action if they provided it in the form.
        $scope.$watch('form.action', function(value) {
          if (!value) return;
          var action = getAction(value);
          if (action) {
            $scope.action = action;
          }
        });

        // Trigger a form load event when the components length is more than 0.
        $scope.$watch('form.components.length', function() {
          if (
            !$scope.form ||
            !$scope.form.components ||
            !$scope.form.components.length
          ) {
            return;
          }
          $scope.setLoading(false);
          $scope.$emit('formLoad', $scope.form);
        });

        $scope.updateSubmissions = function() {
          $scope.setLoading(true);
          var params = {};
          if ($scope.perPage) params.limit = $scope.perPage;
          if ($scope.skip) params.skip = $scope.skip;
          loader.loadSubmissions({params: params}).then(function(submissions) {
            angular.merge($scope.submissions, angular.copy(submissions));
            $scope.setLoading(false);
            $scope.$emit('submissionsLoad', submissions);
          }, this.onError($scope));
        }.bind(this);

        if ($scope._src) {
          loader = new Formio($scope._src);
          if (options.form) {
            $scope.setLoading(true);

            // If a form is already provided, then skip the load.
            if ($scope.form && Object.keys($scope.form).length) {
              $scope.setLoading(false);
              $scope.$emit('formLoad', $scope.form);
            }
            else {
              loader.loadForm().then(function(form) {
                angular.merge($scope.form, angular.copy(form));
                $scope.setLoading(false);
                $scope.$emit('formLoad', $scope.form);
              }, this.onError($scope));
            }
          }
          if (options.submission && loader.submissionId) {
            $scope.setLoading(true);

            // If a submission is already provided, then skip the load.
            if ($scope.submission && Object.keys($scope.submission.data).length) {
              $scope.setLoading(false);
              $scope.$emit('submissionLoad', $scope.submission);
            }
            else {
              loader.loadSubmission().then(function(submission) {
                angular.merge($scope.submission, angular.copy(submission));
                $scope.setLoading(false);
                $scope.$emit('submissionLoad', submission);
              }, this.onError($scope));
            }
          }
          if (options.submissions) {
            $scope.updateSubmissions();
          }
        }
        else {
          // If they provide a url to the form, we still need to create it but tell it to not submit.
          if ($scope.url) {
            loader = new Formio($scope.url);
            loader.noSubmit = true;
          }

          $scope.formoLoaded = true;
          $scope.formLoading = !$scope.form || (Object.keys($scope.form).length === 0) || !$scope.form.components.length;
          $scope.setLoading($scope.formLoading);

          // Emit the events if these objects are already loaded.
          if (!$scope.formLoading) {
            $scope.$emit('formLoad', $scope.form);
          }
          if ($scope.submission) {
            $scope.$emit('submissionLoad', $scope.submission);
          }
          if ($scope.submissions) {
            $scope.$emit('submissionsLoad', $scope.submissions);
          }
        }

        // Return the loader.
        return loader;
      }
    };
  }
];

},{}],228:[function(_dereq_,module,exports){
"use strict";
var formioUtils = _dereq_('formiojs/utils');

module.exports = function() {
  return {
    checkVisible: function(component, row, data) {
      var visible = formioUtils.checkCondition(component, row, data);
      if (!visible) {
        if (!component.hasOwnProperty('clearOnHide') || component.clearOnHide.toString() === 'true') {
          if (row && row.hasOwnProperty(component.key)) {
            delete row[component.key];
          }
          if (data && data.hasOwnProperty(component.key)) {
            delete data[component.key];
          }
        }
        return false;
      }
      return true;
    },
    isVisible: function(component, row, data, hide) {
      // If the component is in the hideComponents array, then hide it by default.
      if (hide && Array.isArray(hide) && (hide.indexOf(component.key) !== -1)) {
        return false;
      }

      return this.checkVisible(component, row, data);
    },
    flattenComponents: formioUtils.flattenComponents,
    eachComponent: formioUtils.eachComponent,
    getComponent: formioUtils.getComponent,
    getValue: formioUtils.getValue,
    hideFields: function(form, components) {
      this.eachComponent(form.components, function(component) {
        for (var i in components) {
          if (component.key === components[i]) {
            component.type = 'hidden';
          }
        }
      });
    },
    uniqueName: function(name) {
      var parts = name.toLowerCase().replace(/[^0-9a-z\.]/g, '').split('.');
      var fileName = parts[0];
      var ext = '';
      if (parts.length > 1) {
        ext = '.' + parts[(parts.length - 1)];
      }
      return fileName.substr(0, 10) + '-' + this.guid() + ext;
    },
    guid: function() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random()*16|0, v = c === 'x' ? r : (r&0x3|0x8);
        return v.toString(16);
      });
    },
    fieldWrap: function(input) {
      var multiInput = input.replace('data[component.key]', 'data[component.key][$index]');
      var inputLabel = '<label ng-if="component.label && !component.hideLabel" for="{{ component.key }}" class="control-label" ng-class="{\'field-required\': isRequired(component)}">{{ component.label | formioTranslate:null:builder }}</label>';
      var requiredInline = '<span ng-if="(component.hideLabel === true || component.label === \'\' || !component.label) && isRequired(component)" class="glyphicon glyphicon-asterisk form-control-feedback field-required-inline" aria-hidden="true"></span>';
      var template =
        '<div ng-if="!component.multiple">' +
          inputLabel +
          '<div class="input-group">' +
            '<div class="input-group-addon" ng-if="!!component.prefix">{{ component.prefix }}</div>' +
            input +
            requiredInline +
            '<div class="input-group-addon" ng-if="!!component.suffix">{{ component.suffix }}</div>' +
          '</div>' +
          '<div class="formio-errors">' +
            '<formio-errors ng-if="::!builder"></formio-errors>' +
          '</div>' +
        '</div>' +
        '<div ng-if="!!component.description" class="help-block">' +
          '<span>{{ component.description }}</span>' +
        '</div>' +
        '<div ng-if="component.multiple"><table class="table table-bordered">' +
          inputLabel +
          '<tr ng-repeat="value in data[component.key] track by $index">' +
            '<td>' +
              '<div class="input-group">' +
                '<div class="input-group-addon" ng-if="!!component.prefix">{{ component.prefix }}</div>' +
                  multiInput +
                  requiredInline +
                '<div class="input-group-addon" ng-if="!!component.suffix">{{ component.suffix }}</div>' +
              '</div>' +
              '<div class="formio-errors">' +
                '<formio-errors ng-if="::!builder"></formio-errors>' +
              '</div>' +
            '</td>' +
            '<td><a ng-click="removeFieldValue($index)" class="btn btn-default"><span class="glyphicon glyphicon-remove-circle"></span></a></td>' +
          '</tr>' +
          '<tr>' +
            '<td colspan="2"><a ng-click="addFieldValue()" class="btn btn-primary"><span class="glyphicon glyphicon-plus" aria-hidden="true"></span> {{ component.addAnother || "Add Another" | formioTranslate:null:builder }}</a></td>' +
          '</tr>' +
        '</table></div>';
      return template;
    },

    /**
     * Check if a component is required
     *
     * @param {Object} component The component to be checked
     * @param {Array} componentsToRequire An array of component keys manually set to mark specific components as required
     */
    isRequired: function(component, componentsToRequire) {
      return (component.validate && component.validate.required) || (Array.isArray(componentsToRequire) && componentsToRequire.indexOf(component.key) !== -1);
    }
  };
};

},{"formiojs/utils":10}],229:[function(_dereq_,module,exports){
"use strict";
module.exports = function() {
  var generic = function(data, component) {
    if (typeof data === 'string') {
      return data;
    }
    var startTable = function(labels) {
      if (!(labels instanceof Array)) {
        labels = [labels];
      }

      var view = '<table class="table table-striped table-bordered"><thead><tr>';

      labels.forEach(function(item) {
        view += '<th>' + item + '</th>';
      });

      view += '</tr></thead>';
      view += '<tbody>';
      return view;
    };

    var finishTable = function() {
      return '</tbody></table>';
    };

    var makeRow = function(data, noRow) {
      var view = !noRow ? '<tr>' : '';

      if (typeof data === 'string' || typeof data === 'number') {
        view += '<td>' + data + '</td>';
      }
      else if (data === null || data === undefined) {
        view += '<td></td>';
      }
      else if (data instanceof Array) {
        data.forEach(function(item) {
          view += makeRow(item);
        });
      }
      else if (typeof data === 'object' && data !== null && data !== undefined) {
        var labels = Object.keys(data);

        view += '<td>' + startTable(labels);
        labels.forEach(function(key) {
          view += makeRow(data[key], true);
        });
        view += finishTable() + '</td>';
      }

      view += !noRow ? '</tr>' : '';
      return view;
    };

    // Create a template
    var view = '';
    var label;
    if (!label && component && component.label) {
      label = component.label;
    }
    else if (!label && component && component.key) {
      label = component.key;
    }
    else {
      label = '';
    }

    view += startTable(label);
    view += makeRow(data);
    view += finishTable();
    return view;
  };

  // Generate a column for the component.
  var columnForComponent = function(data, component, $interpolate, componentInfo, tableChild) {
    // If no component is given, generate an empty cell.
    if (!component) {
      return '<td></td>';
    }

    // Generate a table for each component with one column to display the key/value for each component.
    var view = '<td>';
    view += '<table class="table table-striped table-bordered' + (tableChild ? ' table-child' : '') + '">';
    view += '<thead><tr>';
    view += '<th>' + (component.label || '') + ' (' + component.key + ')</th>';
    view += '</tr></thead>';
    view += '<tbody>';

    // If the component has a defined tableView, use that, otherwise try and use the raw data as a string.
    var info = componentInfo.components.hasOwnProperty(component.type)
      ? componentInfo.components[component.type]
      : {};
    if (info.tableView) {
      view += '<td>' +
        info.tableView(
          data && component.key && (data.hasOwnProperty(component.key) ? data[component.key] : data),
          component,
          $interpolate,
          componentInfo,
          tableChild
        ) + '</td>';
    }
    else {
      view += '<td>';
      if (component.prefix) {
        view += component.prefix;
      }
      view += data && component.key && (data.hasOwnProperty(component.key) ? data[component.key] : '');
      if (component.suffix) {
        view += ' ' + component.suffix;
      }
      view += '</td>';
    }

    view += '</tbody></table>';
    view += '</td>';
    return view;
  };

  return {
    generic: generic,
    columnForComponent: columnForComponent
  };
};

},{}],230:[function(_dereq_,module,exports){
"use strict";
module.exports = [
  '$q',
  '$rootScope',
  'Formio',
  function($q, $rootScope, Formio) {
    var Interceptor = {
      /**
       * Update JWT token received from response.
       */
      response: function(response) {
        var token = response.headers('x-jwt-token');
        if (response.status >= 200 && response.status < 300 && token && token !== '') {
          Formio.setToken(token);
        }
        return response;
      },

      /**
       * Intercept a response error.
       */
      responseError: function(response) {
        if (parseInt(response.status, 10) === 440) {
          response.loggedOut = true;
          Formio.setToken(null);
          $rootScope.$broadcast('formio.sessionExpired', response.body);
        }
        else if (parseInt(response.status, 10) === 401) {
          $rootScope.$broadcast('formio.unauthorized', response.body);
        }
        return $q.reject(response);
      },

      /**
       * Set the token in the request headers.
       */
      request: function(config) {
        if (config.disableJWT) return config;
        var token = Formio.getToken();
        if (token) config.headers['x-jwt-token'] = token;
        return config;
      }
    };

    return Interceptor;
  }
];

},{}],231:[function(_dereq_,module,exports){
"use strict";
module.exports = [
  'Formio',
  'formioComponents',
  '$interpolate',
  function(
    Formio,
    formioComponents,
    $interpolate
  ) {
    return function(value, component) {
      if (!value && value !== 0 && value !== false) {
        return '';
      }
      if (!component || !component.input|| !component.type) {
        return value;
      }
      var componentInfo = formioComponents.components[component.type];
      if (!componentInfo.tableView) {
        return value;
      }
      if (component.multiple && (value.length > 0)) {
        var values = [];
        angular.forEach(value, function(arrayValue) {
          values.push(componentInfo.tableView(arrayValue, component, $interpolate, formioComponents));
        });
        return values;
      }
      return componentInfo.tableView(value, component, $interpolate, formioComponents);
    };
  }
];

},{}],232:[function(_dereq_,module,exports){
"use strict";
module.exports = [
  'FormioUtils',
  function(FormioUtils) {
    return FormioUtils.flattenComponents;
  }
];

},{}],233:[function(_dereq_,module,exports){
"use strict";
module.exports = [
  '$sce',
  function(
    $sce
  ) {
    return function(html) {
      return $sce.trustAsHtml(html);
    };
  }
];

},{}],234:[function(_dereq_,module,exports){
"use strict";
module.exports = [
  function() {
    return function(components) {
      var tableComps = [];
      if (!components || !components.length) {
        return tableComps;
      }
      components.forEach(function(component) {
        if (component.tableView) {
          tableComps.push(component);
        }
      });
      return tableComps;
    };
  }
];

},{}],235:[function(_dereq_,module,exports){
"use strict";
module.exports = [
  'formioTableView',
  function(
    formioTableView
  ) {
    return function(value, component) {
      return formioTableView(value, component);
    };
  }
];

},{}],236:[function(_dereq_,module,exports){
"use strict";
module.exports = [
  'Formio',
  'formioTableView',
  function(
    Formio,
    formioTableView
  ) {
    return function(data, component) {
      return formioTableView(Formio.fieldData(data, component), component);
    };
  }
];

},{}],237:[function(_dereq_,module,exports){
"use strict";
module.exports = [
  '$filter',
  '$injector',
  function(
    $filter,
    $injector
  ) {
    return function(text, key, builder) {
      /**
       * Lookup the available translate libraries, currently supports:
       * angular-translate: @see https://github.com/angular-translate/angular-translate
       * angular-gettext: @see https://github.com/rubenv/angular-gettext
       */
      var $translate, gettextCatalog;
      if ($injector.has('$translate')) {
        $translate = $injector.get('$translate');
      }
      else if ($injector.has('gettextCatalog')) {
        gettextCatalog = $injector.get('gettextCatalog');
      }
      if (builder) return text;
      try {
        // Translate text using either angular-translate or angular-gettext
        var translateText = function(text) {
          if ($translate) return $translate.instant(text);
          if (gettextCatalog) return gettextCatalog.getString(text);
          return text;
        };

        // Allow translating by field key which helps with large blocks of html.
        if (key) {
          var result = translateText(key);
          if (result === key) {
            result = translateText(text);
          }
          return result;
        }

        return translateText(text);
      }
      catch (e) {
        return text;
      }
    };
  }
];

},{}],238:[function(_dereq_,module,exports){
"use strict";
module.exports = ['$sce', function($sce) {
  return function(val) {
    return $sce.trustAsResourceUrl(val);
  };
}];

},{}],239:[function(_dereq_,module,exports){
"use strict";
'use strict';

if (typeof Object.assign != 'function') {
  (function() {
    Object.assign = function(target) {
      'use strict';
      // We must check against these specific cases.
      if (target === undefined || target === null) {
        throw new TypeError('Cannot convert undefined or null to object');
      }

      var output = Object(target);
      /* eslint-disable max-depth */
      for (var index = 1; index < arguments.length; index++) {
        var source = arguments[index];
        if (source !== undefined && source !== null) {
          for (var nextKey in source) {
            if (source.hasOwnProperty(nextKey)) {
              output[nextKey] = source[nextKey];
            }
          }
        }
      }
      /* eslint-enable max-depth */
      return output;
    };
  })();
}

},{}],240:[function(_dereq_,module,exports){
"use strict";
'use strict';

_dereq_('./Object.assign');

},{"./Object.assign":239}],241:[function(_dereq_,module,exports){
"use strict";
module.exports = function() {
  // The formio class.
  var Formio = _dereq_('formiojs');

  // Return the provider interface.
  return {

    // Expose Formio configuration functions
    setBaseUrl: Formio.setBaseUrl,
    getBaseUrl: Formio.getBaseUrl,
    setApiUrl: Formio.setBaseUrl,
    getApiUrl: Formio.getBaseUrl,
    setAppUrl: Formio.setAppUrl,
    setProjectUrl: Formio.setProjectUrl,
    getAppUrl: Formio.getAppUrl,
    getProjectUrl: Formio.getProjectUrl,
    registerPlugin: Formio.registerPlugin,
    getPlugin: Formio.getPlugin,
    providers: Formio.providers,
    setDomain: function() {
      // Remove this?
    },

    $get: [
      '$rootScope',
      '$q',
      function(
        $rootScope,
        $q
      ) {
        var wrapQPromise = function(promise) {
          return $q.when(promise)
          .catch(function(error) {
            if (error === 'Unauthorized') {
              $rootScope.$broadcast('formio.unauthorized', error);
            }
            else if (error === 'Login Timeout') {
              $rootScope.$broadcast('formio.sessionExpired', error);
            }
            // Propagate error
            throw error;
          });
        };

        Formio.registerPlugin({
          priority: -100,
          // Wrap Formio.request's promises with $q so $apply gets called correctly.
          wrapRequestPromise: wrapQPromise,
          wrapStaticRequestPromise: wrapQPromise
        }, 'ngFormioPromiseWrapper');

        // Broadcast offline events from $rootScope
        Formio.events.onAny(function() {
          var event = 'formio.' + this.event;
          var args = [].splice.call(arguments, 0);
          args.unshift(event);
          $rootScope.$apply(function() {
            $rootScope.$broadcast.apply($rootScope, args);
          });
        });

        // Return the formio interface.
        return Formio;
      }
    ]
  };
};

},{"formiojs":3}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvZm9ybWlvLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjIvbGliL2V2ZW50ZW1pdHRlcjIuanMiLCIuLlxcLi5cXC4uXFxuZ0Zvcm1pb1xcbmdGb3JtaW9cXG5vZGVfbW9kdWxlc1xcZm9ybWlvanNcXGJ1aWxkXFxmb3JtaW8uanMiLCIuLlxcLi5cXC4uXFxuZ0Zvcm1pb1xcbm9kZV9tb2R1bGVzXFxmb3JtaW9qc1xcYnVpbGRcXHByb3ZpZGVyc1xcaW5kZXguanMiLCIuLlxcLi5cXC4uXFxuZ0Zvcm1pb1xcbm9kZV9tb2R1bGVzXFxmb3JtaW9qc1xcYnVpbGRcXHByb3ZpZGVyc1xcc3RvcmFnZVxcZHJvcGJveC5qcyIsIi4uXFwuLlxcLi5cXG5nRm9ybWlvXFxub2RlX21vZHVsZXNcXGZvcm1pb2pzXFxidWlsZFxccHJvdmlkZXJzXFxzdG9yYWdlXFxpbmRleC5qcyIsIi4uXFwuLlxcLi5cXG5nRm9ybWlvXFxub2RlX21vZHVsZXNcXGZvcm1pb2pzXFxidWlsZFxccHJvdmlkZXJzXFxzdG9yYWdlXFxzMy5qcyIsIi4uXFwuLlxcLi5cXG5nRm9ybWlvXFxub2RlX21vZHVsZXNcXGZvcm1pb2pzXFxidWlsZFxccHJvdmlkZXJzXFxzdG9yYWdlXFx1cmwuanMiLCIuLlxcLi5cXC4uXFxuZ0Zvcm1pb1xcbm9kZV9tb2R1bGVzXFxmb3JtaW9qc1xcYnVpbGRcXHV0aWxzXFxpbmRleC5qcyIsIi4uXFwuLlxcLi5cXG5nRm9ybWlvXFxub2RlX21vZHVsZXNcXGZvcm1pb2pzXFx1dGlscy5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9qc29uLWxvZ2ljLWpzL2xvZ2ljLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fRGF0YVZpZXcuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19IYXNoLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTGlzdENhY2hlLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwQ2FjaGUuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19Qcm9taXNlLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU2V0LmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU2V0Q2FjaGUuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19TdGFjay5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1N5bWJvbC5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1VpbnQ4QXJyYXkuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19XZWFrTWFwLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYWRkTWFwRW50cnkuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19hZGRTZXRFbnRyeS5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FwcGx5LmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlFYWNoLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlGaWx0ZXIuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUxpa2VLZXlzLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlNYXAuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVB1c2guanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVJlZHVjZS5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5U29tZS5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc2lnblZhbHVlLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzb2NJbmRleE9mLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUFzc2lnbi5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBc3NpZ25Jbi5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBc3NpZ25WYWx1ZS5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VDbG9uZS5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VDcmVhdGUuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRWFjaC5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGaWx0ZXIuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRm9yLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZvck93bi5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXQuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0QWxsS2V5cy5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRUYWcuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSGFzSW4uanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNFcXVhbC5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc0VxdWFsRGVlcC5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc01hdGNoLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJdGVyYXRlZS5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUtleXNJbi5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNYXRjaGVzLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1hdGNoZXNQcm9wZXJ0eS5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQcm9wZXJ0eS5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQcm9wZXJ0eURlZXAuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUmVzdC5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VTZXQuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU2V0VG9TdHJpbmcuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVGltZXMuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVG9TdHJpbmcuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVW5hcnkuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19jYWNoZUhhcy5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RQYXRoLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVBcnJheUJ1ZmZlci5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQnVmZmVyLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVEYXRhVmlldy5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lTWFwLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVSZWdFeHAuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZVNldC5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lU3ltYm9sLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVUeXBlZEFycmF5LmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weUFycmF5LmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weU9iamVjdC5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlTeW1ib2xzLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weVN5bWJvbHNJbi5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcmVKc0RhdGEuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVBc3NpZ25lci5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUJhc2VFYWNoLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQmFzZUZvci5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2RlZmluZVByb3BlcnR5LmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxBcnJheXMuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19lcXVhbEJ5VGFnLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxPYmplY3RzLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldEFsbEtleXMuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRBbGxLZXlzSW4uanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXBEYXRhLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TWF0Y2hEYXRhLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TmF0aXZlLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UHJvdG90eXBlLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UmF3VGFnLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0U3ltYm9scy5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFN5bWJvbHNJbi5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFRhZy5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFZhbHVlLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzUGF0aC5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hDbGVhci5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hEZWxldGUuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoR2V0LmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEhhcy5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hTZXQuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVBcnJheS5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2luaXRDbG9uZUJ5VGFnLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lT2JqZWN0LmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNJbmRleC5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSXRlcmF0ZWVDYWxsLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXkuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleWFibGUuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19pc01hc2tlZC5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzUHJvdG90eXBlLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNTdHJpY3RDb21wYXJhYmxlLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlQ2xlYXIuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVEZWxldGUuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVHZXQuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVIYXMuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVTZXQuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUNsZWFyLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVEZWxldGUuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUdldC5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlSGFzLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVTZXQuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBUb0FycmF5LmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19tZW1vaXplQ2FwcGVkLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlQ3JlYXRlLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlS2V5cy5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUtleXNJbi5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25vZGVVdGlsLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb2JqZWN0VG9TdHJpbmcuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyQXJnLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlclJlc3QuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19yb290LmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0Q2FjaGVBZGQuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRDYWNoZUhhcy5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldFRvQXJyYXkuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb1N0cmluZy5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Nob3J0T3V0LmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tDbGVhci5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrRGVsZXRlLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tHZXQuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0hhcy5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrU2V0LmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaW5nVG9QYXRoLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9LZXkuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL190b1NvdXJjZS5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvYXNzaWduLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9jbG9uZURlZXAuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL2NvbnN0YW50LmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9lcS5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvZmlsdGVyLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9nZXQuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL2hhc0luLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9pZGVudGl0eS5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcmd1bWVudHMuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXkuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0J1ZmZlci5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNFcXVhbC5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNGdW5jdGlvbi5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNMZW5ndGguanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0LmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdExpa2UuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL2lzU3ltYm9sLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1R5cGVkQXJyYXkuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL2tleXMuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL2tleXNJbi5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvbWVtb2l6ZS5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvcHJvcGVydHkuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL3NldC5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL25vZGVfbW9kdWxlcy9sb2Rhc2gvc3R1YkFycmF5LmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViRmFsc2UuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvbG9kYXNoL3RvU3RyaW5nLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL25hdGl2ZS1wcm9taXNlLW9ubHkvbGliL25wby5zcmMuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9ub2RlX21vZHVsZXMvc2hhbGxvdy1jb3B5L2luZGV4LmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL3NpZ25hdHVyZV9wYWQvZGlzdC9zaWduYXR1cmVfcGFkLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vbm9kZV9tb2R1bGVzL3doYXR3Zy1mZXRjaC9mZXRjaC5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL3NyYy9jb21wb25lbnRzL2FkZHJlc3MuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9zcmMvY29tcG9uZW50cy9idXR0b24uanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9zcmMvY29tcG9uZW50cy9jaGVja2JveC5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL3NyYy9jb21wb25lbnRzL2NvbHVtbnMuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9zcmMvY29tcG9uZW50cy9jb21wb25lbnRzLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vc3JjL2NvbXBvbmVudHMvY29udGFpbmVyLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vc3JjL2NvbXBvbmVudHMvY29udGVudC5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL3NyYy9jb21wb25lbnRzL2N1cnJlbmN5LmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vc3JjL2NvbXBvbmVudHMvY3VzdG9tLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vc3JjL2NvbXBvbmVudHMvZGF0YWdyaWQuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9zcmMvY29tcG9uZW50cy9kYXRldGltZS5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL3NyYy9jb21wb25lbnRzL2RheS5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL3NyYy9jb21wb25lbnRzL2VtYWlsLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vc3JjL2NvbXBvbmVudHMvZmllbGRzZXQuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9zcmMvY29tcG9uZW50cy9maWxlLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vc3JjL2NvbXBvbmVudHMvaGlkZGVuLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vc3JjL2NvbXBvbmVudHMvaHRtbGVsZW1lbnQuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9zcmMvY29tcG9uZW50cy9pbmRleC5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL3NyYy9jb21wb25lbnRzL251bWJlci5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL3NyYy9jb21wb25lbnRzL3BhZ2UuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9zcmMvY29tcG9uZW50cy9wYW5lbC5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL3NyYy9jb21wb25lbnRzL3Bhc3N3b3JkLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vc3JjL2NvbXBvbmVudHMvcGhvbmVudW1iZXIuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9zcmMvY29tcG9uZW50cy9yYWRpby5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL3NyYy9jb21wb25lbnRzL3Jlc291cmNlLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vc3JjL2NvbXBvbmVudHMvc2VsZWN0LmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vc3JjL2NvbXBvbmVudHMvc2VsZWN0Ym94ZXMuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9zcmMvY29tcG9uZW50cy9zaWduYXR1cmUuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9zcmMvY29tcG9uZW50cy9zdXJ2ZXkuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9zcmMvY29tcG9uZW50cy90YWJsZS5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL3NyYy9jb21wb25lbnRzL3RleHRhcmVhLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vc3JjL2NvbXBvbmVudHMvdGV4dGZpZWxkLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vc3JjL2NvbXBvbmVudHMvd2VsbC5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL3NyYy9kaXJlY3RpdmVzL2N1c3RvbVZhbGlkYXRvci5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL3NyYy9kaXJlY3RpdmVzL2Zvcm1pby5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL3NyYy9kaXJlY3RpdmVzL2Zvcm1pb0JpbmRIdG1sLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vc3JjL2RpcmVjdGl2ZXMvZm9ybWlvQ29tcG9uZW50LmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vc3JjL2RpcmVjdGl2ZXMvZm9ybWlvQ29tcG9uZW50Vmlldy5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL3NyYy9kaXJlY3RpdmVzL2Zvcm1pb0RlbGV0ZS5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL3NyYy9kaXJlY3RpdmVzL2Zvcm1pb0VsZW1lbnQuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9zcmMvZGlyZWN0aXZlcy9mb3JtaW9FcnJvcnMuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9zcmMvZGlyZWN0aXZlcy9mb3JtaW9TdWJtaXNzaW9uLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vc3JjL2RpcmVjdGl2ZXMvZm9ybWlvU3VibWlzc2lvbnMuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9zcmMvZGlyZWN0aXZlcy9mb3JtaW9XaXphcmQuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9zcmMvZmFjdG9yaWVzL0Zvcm1pb1Njb3BlLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vc3JjL2ZhY3Rvcmllcy9Gb3JtaW9VdGlscy5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL3NyYy9mYWN0b3JpZXMvR3JpZFV0aWxzLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vc3JjL2ZhY3Rvcmllcy9mb3JtaW9JbnRlcmNlcHRvci5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL3NyYy9mYWN0b3JpZXMvZm9ybWlvVGFibGVWaWV3LmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vc3JjL2ZpbHRlcnMvZmxhdHRlbkNvbXBvbmVudHMuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9zcmMvZmlsdGVycy9zYWZlaHRtbC5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL3NyYy9maWx0ZXJzL3RhYmxlQ29tcG9uZW50cy5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL3NyYy9maWx0ZXJzL3RhYmxlRmllbGRWaWV3LmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vc3JjL2ZpbHRlcnMvdGFibGVWaWV3LmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vc3JjL2ZpbHRlcnMvdHJhbnNsYXRlLmpzIiwiLi4vLi4vLi4vbmdGb3JtaW8vc3JjL2ZpbHRlcnMvdHJ1c3R1cmwuanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9zcmMvcG9seWZpbGxzL09iamVjdC5hc3NpZ24uanMiLCIuLi8uLi8uLi9uZ0Zvcm1pby9zcmMvcG9seWZpbGxzL3BvbHlmaWxscy5qcyIsIi4uLy4uLy4uL25nRm9ybWlvL3NyYy9wcm92aWRlcnMvRm9ybWlvLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2x0QkE7O0FBRUE7QUFDQTtBQUNBOzs7O0FBRUEsT0FBTyxjQUFQLENBQXNCLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQzNDLFNBQU87QUFEb0MsQ0FBN0M7O0FBSUEsSUFBSSxVQUFVLE9BQU8sTUFBUCxLQUFrQixVQUFsQixJQUFnQyxTQUFPLE9BQU8sUUFBZCxNQUEyQixRQUEzRCxHQUFzRSxVQUFVLEdBQVYsRUFBZTtBQUFFLGdCQUFjLEdBQWQsMENBQWMsR0FBZDtBQUFvQixDQUEzRyxHQUE4RyxVQUFVLEdBQVYsRUFBZTtBQUFFLFNBQU8sT0FBTyxPQUFPLE1BQVAsS0FBa0IsVUFBekIsSUFBdUMsSUFBSSxXQUFKLEtBQW9CLE1BQTNELElBQXFFLFFBQVEsT0FBTyxTQUFwRixHQUFnRyxRQUFoRyxVQUFrSCxHQUFsSCwwQ0FBa0gsR0FBbEgsQ0FBUDtBQUErSCxDQUE1UTs7QUFFQSxJQUFJLGVBQWUsWUFBWTtBQUFFLFdBQVMsZ0JBQVQsQ0FBMEIsTUFBMUIsRUFBa0MsS0FBbEMsRUFBeUM7QUFBRSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksTUFBTSxNQUExQixFQUFrQyxHQUFsQyxFQUF1QztBQUFFLFVBQUksYUFBYSxNQUFNLENBQU4sQ0FBakIsQ0FBMkIsV0FBVyxVQUFYLEdBQXdCLFdBQVcsVUFBWCxJQUF5QixLQUFqRCxDQUF3RCxXQUFXLFlBQVgsR0FBMEIsSUFBMUIsQ0FBZ0MsSUFBSSxXQUFXLFVBQWYsRUFBMkIsV0FBVyxRQUFYLEdBQXNCLElBQXRCLENBQTRCLE9BQU8sY0FBUCxDQUFzQixNQUF0QixFQUE4QixXQUFXLEdBQXpDLEVBQThDLFVBQTlDO0FBQTREO0FBQUUsR0FBQyxPQUFPLFVBQVUsV0FBVixFQUF1QixVQUF2QixFQUFtQyxXQUFuQyxFQUFnRDtBQUFFLFFBQUksVUFBSixFQUFnQixpQkFBaUIsWUFBWSxTQUE3QixFQUF3QyxVQUF4QyxFQUFxRCxJQUFJLFdBQUosRUFBaUIsaUJBQWlCLFdBQWpCLEVBQThCLFdBQTlCLEVBQTRDLE9BQU8sV0FBUDtBQUFxQixHQUFoTjtBQUFtTixDQUE5aEIsRUFBbkI7O0FBRUEsU0FBUyxlQUFULENBQXlCLFFBQXpCLEVBQW1DLFdBQW5DLEVBQWdEO0FBQUUsTUFBSSxFQUFFLG9CQUFvQixXQUF0QixDQUFKLEVBQXdDO0FBQUUsVUFBTSxJQUFJLFNBQUosQ0FBYyxtQ0FBZCxDQUFOO0FBQTJEO0FBQUU7O0FBRXpKLElBQUksVUFBVSxRQUFRLHFCQUFSLENBQWQ7QUFDQSxRQUFRLGNBQVI7QUFDQSxJQUFJLGVBQWUsUUFBUSxlQUFSLEVBQXlCLGFBQTVDO0FBQ0EsSUFBSSxPQUFPLFFBQVEsY0FBUixDQUFYOztBQUVBOzs7Ozs7QUFNQSxJQUFJLFNBQVMsWUFBWTtBQUN2QixXQUFTLE1BQVQsQ0FBZ0IsSUFBaEIsRUFBc0I7QUFDcEIsUUFBSSxRQUFRLElBQVo7O0FBRUEsUUFBSSxVQUFVLFVBQVUsTUFBVixHQUFtQixDQUFuQixJQUF3QixVQUFVLENBQVYsTUFBaUIsU0FBekMsR0FBcUQsVUFBVSxDQUFWLENBQXJELEdBQW9FLEVBQWxGOztBQUVBLG9CQUFnQixJQUFoQixFQUFzQixNQUF0Qjs7QUFFQTtBQUNBLFFBQUksRUFBRSxnQkFBZ0IsTUFBbEIsQ0FBSixFQUErQjtBQUM3QixhQUFPLElBQUksTUFBSixDQUFXLElBQVgsQ0FBUDtBQUNEOztBQUVEO0FBQ0EsU0FBSyxJQUFMLEdBQVksRUFBWjtBQUNBLFNBQUssV0FBTCxHQUFtQixFQUFuQjtBQUNBLFNBQUssVUFBTCxHQUFrQixFQUFsQjtBQUNBLFNBQUssU0FBTCxHQUFpQixFQUFqQjtBQUNBLFNBQUssT0FBTCxHQUFlLEVBQWY7QUFDQSxTQUFLLFFBQUwsR0FBZ0IsRUFBaEI7QUFDQSxTQUFLLE1BQUwsR0FBYyxFQUFkO0FBQ0EsU0FBSyxjQUFMLEdBQXNCLEVBQXRCO0FBQ0EsU0FBSyxhQUFMLEdBQXFCLEVBQXJCO0FBQ0EsU0FBSyxZQUFMLEdBQW9CLEVBQXBCO0FBQ0EsU0FBSyxVQUFMLEdBQWtCLEVBQWxCO0FBQ0EsU0FBSyxRQUFMLEdBQWdCLEVBQWhCO0FBQ0EsU0FBSyxTQUFMLEdBQWlCLEVBQWpCO0FBQ0EsU0FBSyxLQUFMLEdBQWEsRUFBYjs7QUFFQSxRQUFJLFFBQVEsY0FBUixDQUF1QixNQUF2QixDQUFKLEVBQW9DO0FBQ2xDLFdBQUssSUFBTCxHQUFZLFFBQVEsSUFBcEI7QUFDRCxLQUZELE1BRU8sSUFBSSxPQUFPLE9BQVgsRUFBb0I7QUFDekIsV0FBSyxJQUFMLEdBQVksT0FBTyxPQUFuQjtBQUNELEtBRk0sTUFFQTtBQUNMLFdBQUssSUFBTCxHQUFZLE9BQU8sUUFBUCxDQUFnQixJQUFoQixDQUFxQixLQUFyQixDQUEyQixtQkFBM0IsRUFBZ0QsQ0FBaEQsQ0FBWjtBQUNEOztBQUVELFFBQUksQ0FBQyxJQUFMLEVBQVc7QUFDVDtBQUNBO0FBQ0EsV0FBSyxVQUFMLEdBQWtCLEtBQUssSUFBTCxHQUFZLFVBQTlCO0FBQ0EsV0FBSyxXQUFMLEdBQW1CLEtBQUssSUFBTCxHQUFZLFVBQS9CO0FBQ0EsV0FBSyxTQUFMLEdBQWlCLEtBQWpCO0FBQ0EsV0FBSyxLQUFMLEdBQWEsRUFBYjtBQUNBO0FBQ0Q7O0FBRUQsUUFBSSxRQUFRLGNBQVIsQ0FBdUIsU0FBdkIsQ0FBSixFQUF1QztBQUNyQyxXQUFLLFVBQUwsR0FBa0IsUUFBUSxPQUExQjtBQUNEOztBQUVELFFBQUksVUFBVSxLQUFLLFVBQUwsSUFBbUIsT0FBTyxVQUF4Qzs7QUFFQTtBQUNBO0FBQ0EsUUFBSSxXQUFXLEtBQUssSUFBTCxLQUFjLE9BQTdCLEVBQXNDO0FBQ3BDLFdBQUssU0FBTCxHQUFpQixJQUFqQjtBQUNBLFdBQUssVUFBTCxHQUFrQixLQUFLLElBQXZCO0FBQ0Q7O0FBRUQ7QUFDQSxRQUFJLEtBQUssT0FBTCxDQUFhLE1BQWIsTUFBeUIsQ0FBekIsSUFBOEIsS0FBSyxPQUFMLENBQWEsSUFBYixNQUF1QixDQUF6RCxFQUE0RDtBQUMxRCxhQUFPLEtBQUssSUFBTCxHQUFZLElBQW5CO0FBQ0Q7O0FBRUQsUUFBSSxZQUFZLE9BQU8sV0FBUCxDQUFtQixJQUFuQixDQUFoQjtBQUNBLFFBQUksUUFBUSxFQUFaO0FBQ0EsUUFBSSxXQUFXLFVBQVUsQ0FBVixJQUFlLFVBQVUsQ0FBVixDQUE5QjtBQUNBLFdBQU8sVUFBVSxNQUFWLEdBQW1CLENBQW5CLEdBQXVCLFVBQVUsQ0FBVixDQUF2QixHQUFzQyxFQUE3QztBQUNBLFFBQUksYUFBYSxLQUFLLEtBQUwsQ0FBVyxHQUFYLENBQWpCO0FBQ0EsUUFBSSxXQUFXLE1BQVgsR0FBb0IsQ0FBeEIsRUFBMkI7QUFDekIsYUFBTyxXQUFXLENBQVgsQ0FBUDtBQUNBLFdBQUssS0FBTCxHQUFhLE1BQU0sV0FBVyxDQUFYLENBQW5CO0FBQ0Q7O0FBRUQ7QUFDQSxRQUFJLGVBQWUsU0FBUyxZQUFULENBQXNCLElBQXRCLEVBQTRCLElBQTVCLEVBQWtDO0FBQ25ELFlBQU0sT0FBTyxNQUFiLElBQXVCLE9BQU8sR0FBUCxHQUFhLElBQXBDO0FBQ0EsVUFBSSxRQUFRLElBQUksTUFBSixDQUFXLE9BQU8sSUFBUCxHQUFjLFdBQXpCLENBQVo7QUFDQSxVQUFJLEtBQUssTUFBTCxDQUFZLEtBQVosTUFBdUIsQ0FBQyxDQUE1QixFQUErQjtBQUM3QixnQkFBUSxLQUFLLEtBQUwsQ0FBVyxLQUFYLENBQVI7QUFDQSxjQUFNLE9BQU8sS0FBYixJQUFzQixRQUFRLE9BQU8sTUFBTSxDQUFOLENBQWYsR0FBMEIsRUFBaEQ7QUFDQSxjQUFNLE9BQU8sSUFBYixJQUFxQixNQUFNLE1BQU4sR0FBZSxDQUFmLEdBQW1CLE1BQU0sQ0FBTixDQUFuQixHQUE4QixFQUFuRDtBQUNBLGdCQUFRLE1BQU0sQ0FBTixDQUFSO0FBQ0Q7QUFDRCxhQUFPLElBQVA7QUFDRCxLQVZEOztBQVlBO0FBQ0EsUUFBSSxnQkFBZ0IsU0FBUyxhQUFULENBQXVCLEtBQXZCLEVBQThCLElBQTlCLEVBQW9DLFVBQXBDLEVBQWdEO0FBQ2xFLFdBQUssSUFBSSxDQUFULElBQWMsS0FBZCxFQUFxQjtBQUNuQixZQUFJLE1BQU0sY0FBTixDQUFxQixDQUFyQixDQUFKLEVBQTZCO0FBQzNCLGNBQUksT0FBTyxNQUFNLENBQU4sQ0FBWDtBQUNBLGNBQUksZ0JBQWdCLEtBQXBCLEVBQTJCO0FBQ3pCLDBCQUFjLElBQWQsRUFBb0IsSUFBcEIsRUFBMEIsSUFBMUI7QUFDRCxXQUZELE1BRU87QUFDTCxnQkFBSSxVQUFVLGFBQWEsSUFBYixFQUFtQixJQUFuQixDQUFkO0FBQ0EsbUJBQU8sYUFBYSxJQUFiLEdBQW9CLE9BQTNCO0FBQ0Q7QUFDRjtBQUNGO0FBQ0YsS0FaRDs7QUFjQSxRQUFJLENBQUMsS0FBSyxVQUFOLElBQW9CLEtBQUssVUFBTCxLQUFvQixLQUFLLElBQWpELEVBQXVEO0FBQ3JELFdBQUssVUFBTCxHQUFrQixRQUFsQjtBQUNEOztBQUVELFFBQUksQ0FBQyxLQUFLLFNBQVYsRUFBcUI7QUFDbkI7QUFDQSxVQUFJLEtBQUssTUFBTCxDQUFZLHVCQUFaLE1BQXlDLENBQUMsQ0FBOUMsRUFBaUQ7QUFDL0M7QUFDQSxzQkFBYyxDQUFDLFNBQUQsQ0FBZCxFQUEyQixRQUEzQjtBQUNELE9BSEQsTUFHTyxJQUFJLGFBQWEsS0FBSyxJQUF0QixFQUE0QjtBQUNqQztBQUNBLFlBQUksVUFBVSxNQUFWLEdBQW1CLENBQW5CLElBQXdCLEtBQUssS0FBTCxDQUFXLEdBQVgsRUFBZ0IsTUFBaEIsR0FBeUIsQ0FBckQsRUFBd0Q7QUFDdEQsY0FBSSxZQUFZLEtBQUssS0FBTCxDQUFXLEdBQVgsQ0FBaEI7QUFDQSxvQkFBVSxLQUFWLEdBRnNELENBRW5DO0FBQ25CLGVBQUssU0FBTCxHQUFpQixVQUFVLEtBQVYsRUFBakI7QUFDQSxpQkFBTyxNQUFNLFVBQVUsSUFBVixDQUFlLEdBQWYsQ0FBYjtBQUNBLGVBQUssVUFBTCxHQUFrQixXQUFXLEdBQVgsR0FBaUIsS0FBSyxTQUF4QztBQUNEO0FBQ0YsT0FUTSxNQVNBO0FBQ0w7QUFDQSxZQUFJLFVBQVUsTUFBVixHQUFtQixDQUFuQixLQUF5QixVQUFVLENBQVYsRUFBYSxLQUFiLENBQW1CLEdBQW5CLEVBQXdCLE1BQXhCLEdBQWlDLENBQWpDLElBQXNDLFNBQVMsT0FBVCxDQUFpQixXQUFqQixNQUFrQyxDQUFDLENBQWxHLENBQUosRUFBMEc7QUFDeEcsZUFBSyxVQUFMLEdBQWtCLFFBQWxCO0FBQ0EsZUFBSyxTQUFMLEdBQWlCLFVBQVUsQ0FBVixFQUFhLEtBQWIsQ0FBbUIsR0FBbkIsRUFBd0IsQ0FBeEIsQ0FBakI7QUFDRDtBQUNGO0FBQ0QsV0FBSyxXQUFMLEdBQW1CLEtBQUssV0FBTCxJQUFvQixLQUFLLElBQUwsR0FBWSxVQUFuRDtBQUNEOztBQUVEO0FBQ0EsUUFBSSxLQUFLLE1BQUwsQ0FBWSw0QkFBWixNQUE4QyxDQUFDLENBQW5ELEVBQXNEO0FBQ3BELG9CQUFjLENBQUMsTUFBRCxFQUFTLENBQUMsWUFBRCxFQUFlLFFBQWYsQ0FBVCxDQUFkLEVBQWtELEtBQUssVUFBdkQ7QUFDRCxLQUZELE1BRU87QUFDTCxVQUFJLFdBQVcsSUFBSSxNQUFKLENBQVcsK0JBQVgsQ0FBZjtBQUNBLFVBQUksT0FBTyxLQUFLLEtBQUwsQ0FBVyxRQUFYLENBQVg7QUFDQSxXQUFLLFFBQUwsR0FBZ0IsUUFBUSxLQUFLLE1BQUwsR0FBYyxDQUF0QixHQUEwQixLQUFLLENBQUwsQ0FBMUIsR0FBb0MsRUFBcEQ7QUFDQSxhQUFPLEtBQUssT0FBTCxDQUFhLFFBQWIsRUFBdUIsRUFBdkIsQ0FBUDtBQUNBLGFBQU8sS0FBSyxPQUFMLENBQWEsS0FBYixFQUFvQixFQUFwQixDQUFQO0FBQ0EsV0FBSyxRQUFMLEdBQWdCLEtBQUssVUFBTCxHQUFrQixPQUFsQztBQUNBLFdBQUssT0FBTCxHQUFlLEtBQUssVUFBTCxHQUFrQixJQUFqQztBQUNBLFdBQUssTUFBTCxHQUFjLEtBQUssT0FBTCxDQUFhLFlBQWIsRUFBMkIsRUFBM0IsQ0FBZDtBQUNBLFVBQUksUUFBUSxDQUFDLFlBQUQsRUFBZSxRQUFmLENBQVo7QUFDQSxXQUFLLElBQUksQ0FBVCxJQUFjLEtBQWQsRUFBcUI7QUFDbkIsWUFBSSxNQUFNLGNBQU4sQ0FBcUIsQ0FBckIsQ0FBSixFQUE2QjtBQUMzQixjQUFJLE9BQU8sTUFBTSxDQUFOLENBQVg7QUFDQSxlQUFLLE9BQU8sTUFBWixJQUFzQixLQUFLLFVBQUwsR0FBa0IsSUFBbEIsR0FBeUIsR0FBekIsR0FBK0IsSUFBckQ7QUFDQSxjQUFJLEtBQUssUUFBTCxLQUFrQixJQUFsQixJQUEwQixLQUFLLE1BQUwsR0FBYyxDQUF4QyxJQUE2QyxLQUFLLENBQUwsQ0FBakQsRUFBMEQ7QUFDeEQsaUJBQUssT0FBTyxJQUFaLElBQW9CLEtBQUssQ0FBTCxFQUFRLE9BQVIsQ0FBZ0IsWUFBaEIsRUFBOEIsRUFBOUIsQ0FBcEI7QUFDQSxpQkFBSyxPQUFPLEtBQVosSUFBcUIsS0FBSyxVQUFMLEdBQWtCLElBQWxCLEdBQXlCLEtBQUssQ0FBTCxDQUE5QztBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVEO0FBQ0EsUUFBSSxDQUFDLE9BQU8sYUFBWixFQUEyQjtBQUN6QixhQUFPLFVBQVAsR0FBb0IsS0FBSyxVQUF6QjtBQUNEO0FBQ0Y7O0FBRUQsZUFBYSxNQUFiLEVBQXFCLENBQUM7QUFDcEIsU0FBSyxRQURlO0FBRXBCLFdBQU8sU0FBUyxPQUFULENBQWlCLElBQWpCLEVBQXVCLElBQXZCLEVBQTZCO0FBQ2xDLFVBQUksTUFBTSxPQUFPLElBQWpCO0FBQ0EsVUFBSSxPQUFPLE9BQU8sS0FBbEI7QUFDQSxVQUFJLENBQUMsS0FBSyxHQUFMLENBQUwsRUFBZ0I7QUFDZCxnQkFBUSxNQUFSLENBQWUsbUJBQWY7QUFDRDtBQUNELGFBQU8sS0FBUCxHQUFlLEVBQWY7QUFDQSxhQUFPLEtBQUssV0FBTCxDQUFpQixJQUFqQixFQUF1QixLQUFLLElBQUwsQ0FBdkIsRUFBbUMsUUFBbkMsRUFBNkMsSUFBN0MsRUFBbUQsSUFBbkQsQ0FBUDtBQUNEO0FBVm1CLEdBQUQsRUFXbEI7QUFDRCxTQUFLLE9BREo7QUFFRCxXQUFPLFNBQVMsS0FBVCxDQUFlLElBQWYsRUFBcUIsS0FBckIsRUFBNEIsSUFBNUIsRUFBa0M7QUFDdkMsVUFBSSxPQUFPLE9BQU8sS0FBbEI7QUFDQSxjQUFRLFNBQVMsRUFBakI7QUFDQSxVQUFJLFNBQVMsQ0FBQyxPQUFPLEtBQVAsS0FBaUIsV0FBakIsR0FBK0IsV0FBL0IsR0FBNkMsUUFBUSxLQUFSLENBQTlDLE1BQWtFLFFBQS9FLEVBQXlGO0FBQ3ZGLGdCQUFRLE1BQU0sT0FBTyxTQUFQLENBQWlCLE1BQU0sTUFBdkIsQ0FBZDtBQUNEO0FBQ0QsYUFBTyxLQUFLLFdBQUwsQ0FBaUIsSUFBakIsRUFBdUIsS0FBSyxJQUFMLElBQWEsS0FBcEMsRUFBMkMsS0FBM0MsRUFBa0QsSUFBbEQsRUFBd0QsSUFBeEQsQ0FBUDtBQUNEO0FBVEEsR0FYa0IsRUFxQmxCO0FBQ0QsU0FBSyxNQURKO0FBRUQsV0FBTyxTQUFTLElBQVQsQ0FBYyxJQUFkLEVBQW9CLElBQXBCLEVBQTBCLElBQTFCLEVBQWdDO0FBQ3JDLFVBQUksTUFBTSxPQUFPLElBQWpCO0FBQ0EsVUFBSSxPQUFPLE9BQU8sS0FBbEI7QUFDQSxVQUFJLFNBQVMsS0FBSyxHQUFMLEtBQWEsS0FBSyxHQUFsQixHQUF3QixLQUF4QixHQUFnQyxNQUE3QztBQUNBLFVBQUksU0FBUyxLQUFLLEdBQUwsSUFBWSxLQUFLLElBQUwsQ0FBWixHQUF5QixLQUFLLE9BQU8sTUFBWixDQUF0QztBQUNBLFVBQUksQ0FBQyxLQUFLLEdBQUwsQ0FBRCxJQUFjLEtBQUssR0FBbkIsSUFBMEIsV0FBVyxLQUFyQyxJQUE4QyxPQUFPLE9BQVAsQ0FBZSxLQUFLLEdBQXBCLE1BQTZCLENBQUMsQ0FBaEYsRUFBbUY7QUFDakYsa0JBQVUsTUFBTSxLQUFLLEdBQXJCO0FBQ0Q7QUFDRCxhQUFPLEtBQVAsR0FBZSxFQUFmO0FBQ0EsYUFBTyxLQUFLLFdBQUwsQ0FBaUIsSUFBakIsRUFBdUIsU0FBUyxLQUFLLEtBQXJDLEVBQTRDLE1BQTVDLEVBQW9ELElBQXBELEVBQTBELElBQTFELENBQVA7QUFDRDtBQVpBLEdBckJrQixFQWtDbEI7QUFDRCxTQUFLLE1BREo7QUFFRCxXQUFPLFNBQVMsSUFBVCxDQUFjLElBQWQsRUFBb0IsS0FBcEIsRUFBMkIsSUFBM0IsRUFBaUM7QUFDdEMsVUFBSSxNQUFNLE9BQU8sSUFBakI7QUFDQSxVQUFJLE9BQU8sT0FBTyxLQUFsQjtBQUNBLFVBQUksU0FBUyxDQUFDLE9BQU8sS0FBUCxLQUFpQixXQUFqQixHQUErQixXQUEvQixHQUE2QyxRQUFRLEtBQVIsQ0FBOUMsTUFBa0UsUUFBL0UsRUFBeUY7QUFDdkYsZ0JBQVEsT0FBTyxTQUFQLENBQWlCLE1BQU0sTUFBdkIsQ0FBUjtBQUNEO0FBQ0QsVUFBSSxLQUFKLEVBQVc7QUFDVCxnQkFBUSxLQUFLLEtBQUwsR0FBYSxLQUFLLEtBQUwsR0FBYSxHQUFiLEdBQW1CLEtBQWhDLEdBQXdDLE1BQU0sS0FBdEQ7QUFDRCxPQUZELE1BRU87QUFDTCxnQkFBUSxLQUFLLEtBQWI7QUFDRDtBQUNELFVBQUksQ0FBQyxLQUFLLEdBQUwsQ0FBTCxFQUFnQjtBQUNkLGVBQU8sUUFBUSxNQUFSLENBQWUsYUFBYSxHQUE1QixDQUFQO0FBQ0Q7QUFDRCxhQUFPLEtBQUssV0FBTCxDQUFpQixJQUFqQixFQUF1QixLQUFLLElBQUwsSUFBYSxLQUFwQyxFQUEyQyxLQUEzQyxFQUFrRCxJQUFsRCxFQUF3RCxJQUF4RCxDQUFQO0FBQ0Q7QUFqQkEsR0FsQ2tCLEVBb0RsQjtBQUNELFNBQUssYUFESjtBQUVELFdBQU8sU0FBUyxXQUFULENBQXFCLElBQXJCLEVBQTJCLEdBQTNCLEVBQWdDLE1BQWhDLEVBQXdDLElBQXhDLEVBQThDLElBQTlDLEVBQW9EO0FBQ3pELGVBQVMsQ0FBQyxVQUFVLEtBQVgsRUFBa0IsV0FBbEIsRUFBVDtBQUNBLFVBQUksQ0FBQyxJQUFELElBQVMsQ0FBQyxPQUFPLElBQVAsS0FBZ0IsV0FBaEIsR0FBOEIsV0FBOUIsR0FBNEMsUUFBUSxJQUFSLENBQTdDLE1BQWdFLFFBQTdFLEVBQXVGO0FBQ3JGLGVBQU8sRUFBUDtBQUNEOztBQUVELFVBQUksY0FBYztBQUNoQixnQkFBUSxJQURRO0FBRWhCLGNBQU0sSUFGVTtBQUdoQixhQUFLLEdBSFc7QUFJaEIsZ0JBQVEsTUFKUTtBQUtoQixjQUFNLElBTFU7QUFNaEIsY0FBTTtBQU5VLE9BQWxCOztBQVNBLFVBQUksVUFBVSxPQUFPLFVBQVAsQ0FBa0IsWUFBbEIsRUFBZ0MsV0FBaEMsRUFBNkMsSUFBN0MsQ0FBa0QsWUFBWTtBQUMxRSxlQUFPLE9BQU8sU0FBUCxDQUFpQixTQUFqQixFQUE0QixXQUE1QixFQUF5QyxJQUF6QyxDQUE4QyxVQUFVLE1BQVYsRUFBa0I7QUFDckUsY0FBSSxXQUFXLElBQVgsSUFBbUIsV0FBVyxTQUFsQyxFQUE2QztBQUMzQyxtQkFBTyxPQUFPLE9BQVAsQ0FBZSxHQUFmLEVBQW9CLE1BQXBCLEVBQTRCLElBQTVCLEVBQWtDLEtBQUssTUFBdkMsRUFBK0MsSUFBL0MsQ0FBUDtBQUNEO0FBQ0QsaUJBQU8sTUFBUDtBQUNELFNBTE0sQ0FBUDtBQU1ELE9BUGEsQ0FBZDs7QUFTQSxhQUFPLE9BQU8sV0FBUCxDQUFtQixvQkFBbkIsRUFBeUMsT0FBekMsRUFBa0QsV0FBbEQsQ0FBUDtBQUNEO0FBM0JBLEdBcERrQixFQWdGbEI7QUFDRCxTQUFLLGFBREo7QUFFRCxXQUFPLFNBQVMsV0FBVCxDQUFxQixLQUFyQixFQUE0QixJQUE1QixFQUFrQztBQUN2QyxhQUFPLEtBQUssSUFBTCxDQUFVLFNBQVYsRUFBcUIsS0FBckIsRUFBNEIsSUFBNUIsQ0FBUDtBQUNEO0FBSkEsR0FoRmtCLEVBcUZsQjtBQUNELFNBQUssYUFESjtBQUVELFdBQU8sU0FBUyxXQUFULENBQXFCLElBQXJCLEVBQTJCLElBQTNCLEVBQWlDO0FBQ3RDLGFBQU8sS0FBSyxJQUFMLENBQVUsU0FBVixFQUFxQixJQUFyQixFQUEyQixJQUEzQixDQUFQO0FBQ0Q7QUFKQSxHQXJGa0IsRUEwRmxCO0FBQ0QsU0FBSyxlQURKO0FBRUQsV0FBTyxTQUFTLGFBQVQsQ0FBdUIsSUFBdkIsRUFBNkI7QUFDbEMsYUFBTyxLQUFLLE1BQUwsQ0FBWSxTQUFaLEVBQXVCLElBQXZCLENBQVA7QUFDRDtBQUpBLEdBMUZrQixFQStGbEI7QUFDRCxTQUFLLFVBREo7QUFFRCxXQUFPLFNBQVMsUUFBVCxDQUFrQixLQUFsQixFQUF5QixJQUF6QixFQUErQjtBQUNwQyxhQUFPLEtBQUssSUFBTCxDQUFVLE1BQVYsRUFBa0IsS0FBbEIsRUFBeUIsSUFBekIsQ0FBUDtBQUNEO0FBSkEsR0EvRmtCLEVBb0dsQjtBQUNELFNBQUssVUFESjtBQUVELFdBQU8sU0FBUyxRQUFULENBQWtCLElBQWxCLEVBQXdCLElBQXhCLEVBQThCO0FBQ25DLGFBQU8sS0FBSyxJQUFMLENBQVUsTUFBVixFQUFrQixJQUFsQixFQUF3QixJQUF4QixDQUFQO0FBQ0Q7QUFKQSxHQXBHa0IsRUF5R2xCO0FBQ0QsU0FBSyxZQURKO0FBRUQsV0FBTyxTQUFTLFVBQVQsQ0FBb0IsSUFBcEIsRUFBMEI7QUFDL0IsYUFBTyxLQUFLLE1BQUwsQ0FBWSxNQUFaLEVBQW9CLElBQXBCLENBQVA7QUFDRDtBQUpBLEdBekdrQixFQThHbEI7QUFDRCxTQUFLLFdBREo7QUFFRCxXQUFPLFNBQVMsU0FBVCxDQUFtQixLQUFuQixFQUEwQixJQUExQixFQUFnQztBQUNyQyxhQUFPLEtBQUssS0FBTCxDQUFXLE9BQVgsRUFBb0IsS0FBcEIsRUFBMkIsSUFBM0IsQ0FBUDtBQUNEO0FBSkEsR0E5R2tCLEVBbUhsQjtBQUNELFNBQUssZ0JBREo7QUFFRCxXQUFPLFNBQVMsY0FBVCxDQUF3QixLQUF4QixFQUErQixJQUEvQixFQUFxQztBQUMxQyxhQUFPLEtBQUssSUFBTCxDQUFVLFlBQVYsRUFBd0IsS0FBeEIsRUFBK0IsSUFBL0IsQ0FBUDtBQUNEO0FBSkEsR0FuSGtCLEVBd0hsQjtBQUNELFNBQUssZ0JBREo7QUFFRCxXQUFPLFNBQVMsY0FBVCxDQUF3QixJQUF4QixFQUE4QixJQUE5QixFQUFvQztBQUN6QyxhQUFPLEtBQUssSUFBTCxDQUFVLFlBQVYsRUFBd0IsSUFBeEIsRUFBOEIsSUFBOUIsQ0FBUDtBQUNEO0FBSkEsR0F4SGtCLEVBNkhsQjtBQUNELFNBQUssa0JBREo7QUFFRCxXQUFPLFNBQVMsZ0JBQVQsQ0FBMEIsSUFBMUIsRUFBZ0M7QUFDckMsYUFBTyxLQUFLLE1BQUwsQ0FBWSxZQUFaLEVBQTBCLElBQTFCLENBQVA7QUFDRDtBQUpBLEdBN0hrQixFQWtJbEI7QUFDRCxTQUFLLGlCQURKO0FBRUQsV0FBTyxTQUFTLGVBQVQsQ0FBeUIsS0FBekIsRUFBZ0MsSUFBaEMsRUFBc0M7QUFDM0MsYUFBTyxLQUFLLEtBQUwsQ0FBVyxhQUFYLEVBQTBCLEtBQTFCLEVBQWlDLElBQWpDLENBQVA7QUFDRDtBQUpBLEdBbElrQixFQXVJbEI7QUFDRCxTQUFLLFlBREo7QUFFRCxXQUFPLFNBQVMsVUFBVCxDQUFvQixLQUFwQixFQUEyQixJQUEzQixFQUFpQztBQUN0QyxhQUFPLEtBQUssSUFBTCxDQUFVLFFBQVYsRUFBb0IsS0FBcEIsRUFBMkIsSUFBM0IsQ0FBUDtBQUNEO0FBSkEsR0F2SWtCLEVBNElsQjtBQUNELFNBQUssWUFESjtBQUVELFdBQU8sU0FBUyxVQUFULENBQW9CLElBQXBCLEVBQTBCLElBQTFCLEVBQWdDO0FBQ3JDLGFBQU8sS0FBSyxJQUFMLENBQVUsUUFBVixFQUFvQixJQUFwQixFQUEwQixJQUExQixDQUFQO0FBQ0Q7QUFKQSxHQTVJa0IsRUFpSmxCO0FBQ0QsU0FBSyxjQURKO0FBRUQsV0FBTyxTQUFTLFlBQVQsQ0FBc0IsSUFBdEIsRUFBNEI7QUFDakMsYUFBTyxLQUFLLE1BQUwsQ0FBWSxRQUFaLEVBQXNCLElBQXRCLENBQVA7QUFDRDtBQUpBLEdBakprQixFQXNKbEI7QUFDRCxTQUFLLGFBREo7QUFFRCxXQUFPLFNBQVMsV0FBVCxDQUFxQixLQUFyQixFQUE0QixJQUE1QixFQUFrQztBQUN2QyxhQUFPLEtBQUssS0FBTCxDQUFXLFNBQVgsRUFBc0IsS0FBdEIsRUFBNkIsSUFBN0IsQ0FBUDtBQUNEO0FBSkEsR0F0SmtCLEVBMkpsQjtBQUNELFNBQUssa0JBREo7QUFFRCxXQUFPLFNBQVMsZ0JBQVQsR0FBNEI7QUFDakMsYUFBTyxLQUFLLFdBQUwsQ0FBaUIsa0JBQWpCLEVBQXFDLEtBQUssT0FBTCxHQUFlLFVBQXBELENBQVA7QUFDRDtBQUpBLEdBM0prQixFQWdLbEI7QUFDRCxTQUFLLFlBREo7QUFFRCxXQUFPLFNBQVMsVUFBVCxDQUFvQixJQUFwQixFQUEwQjtBQUMvQixhQUFPLEtBQUssV0FBTCxDQUFpQixZQUFqQixFQUErQixLQUFLLE9BQUwsR0FBZSxXQUFmLEdBQTZCLElBQTVELENBQVA7QUFDRDs7QUFFRDs7OztBQU5DLEdBaEtrQixFQTBLbEI7QUFDRCxTQUFLLGNBREo7QUFFRCxXQUFPLFNBQVMsWUFBVCxDQUFzQixNQUF0QixFQUE4QixPQUE5QixFQUF1QztBQUM1QyxVQUFJLFFBQVEsT0FBTyxRQUFQLEVBQVo7QUFDQSxVQUFJLENBQUMsS0FBTCxFQUFZO0FBQ1YsZUFBTyxRQUFRLE1BQVIsQ0FBZSwrREFBZixDQUFQO0FBQ0Q7QUFDRCxhQUFPLEtBQUssV0FBTCxDQUFpQixXQUFqQixFQUE4QixLQUFLLFVBQUwsR0FBa0IsUUFBaEQsRUFBMEQsS0FBMUQsRUFBaUUsSUFBakUsRUFBdUU7QUFDNUUsZ0JBQVEsSUFBSSxPQUFKLENBQVk7QUFDbEIsc0JBQVksTUFETTtBQUVsQixxQkFBVztBQUZPLFNBQVo7QUFEb0UsT0FBdkUsQ0FBUDtBQU1EO0FBYkEsR0ExS2tCLEVBd0xsQjtBQUNELFNBQUssWUFESjtBQUVELFdBQU8sU0FBUyxVQUFULENBQW9CLE9BQXBCLEVBQTZCLElBQTdCLEVBQW1DLFFBQW5DLEVBQTZDLEdBQTdDLEVBQWtELGdCQUFsRCxFQUFvRSxHQUFwRSxFQUF5RTtBQUM5RSxVQUFJLGNBQWM7QUFDaEIsa0JBQVUsT0FETTtBQUVoQixnQkFBUSxRQUZRO0FBR2hCLGNBQU0sSUFIVTtBQUloQixrQkFBVSxRQUpNO0FBS2hCLGFBQUs7QUFMVyxPQUFsQjtBQU9BLFVBQUksVUFBVSxPQUFPLFVBQVAsQ0FBa0IsWUFBbEIsRUFBZ0MsV0FBaEMsRUFBNkMsSUFBN0MsQ0FBa0QsWUFBWTtBQUMxRSxlQUFPLE9BQU8sU0FBUCxDQUFpQixhQUFqQixFQUFnQyxXQUFoQyxFQUE2QyxJQUE3QyxDQUFrRCxVQUFVLE1BQVYsRUFBa0I7QUFDekUsY0FBSSxZQUFZLFdBQVcsSUFBWCxJQUFtQixXQUFXLFNBQTFDLENBQUosRUFBMEQ7QUFDeEQsZ0JBQUksT0FBTyxTQUFQLENBQWlCLE9BQWpCLENBQXlCLGNBQXpCLENBQXdDLE9BQXhDLENBQUosRUFBc0Q7QUFDcEQsa0JBQUksV0FBVyxJQUFJLE9BQU8sU0FBUCxDQUFpQixPQUFqQixDQUF5QixPQUF6QixDQUFKLENBQXNDLElBQXRDLENBQWY7QUFDQSxxQkFBTyxTQUFTLFVBQVQsQ0FBb0IsSUFBcEIsRUFBMEIsUUFBMUIsRUFBb0MsR0FBcEMsRUFBeUMsZ0JBQXpDLEVBQTJELEdBQTNELENBQVA7QUFDRCxhQUhELE1BR087QUFDTCxvQkFBTSw0QkFBTjtBQUNEO0FBQ0Y7QUFDRCxpQkFBTyxVQUFVLEVBQUUsS0FBSyxFQUFQLEVBQWpCO0FBQ0QsU0FWd0QsQ0FVdkQsSUFWdUQsQ0FVbEQsSUFWa0QsQ0FBbEQsQ0FBUDtBQVdELE9BWitELENBWTlELElBWjhELENBWXpELElBWnlELENBQWxELENBQWQ7O0FBY0EsYUFBTyxPQUFPLFdBQVAsQ0FBbUIsd0JBQW5CLEVBQTZDLE9BQTdDLEVBQXNELFdBQXRELENBQVA7QUFDRDtBQXpCQSxHQXhMa0IsRUFrTmxCO0FBQ0QsU0FBSyxjQURKO0FBRUQsV0FBTyxTQUFTLFlBQVQsQ0FBc0IsSUFBdEIsRUFBNEI7QUFDakMsVUFBSSxjQUFjO0FBQ2hCLGdCQUFRLFVBRFE7QUFFaEIsY0FBTTtBQUZVLE9BQWxCOztBQUtBLFVBQUksVUFBVSxPQUFPLFVBQVAsQ0FBa0IsWUFBbEIsRUFBZ0MsV0FBaEMsRUFBNkMsSUFBN0MsQ0FBa0QsWUFBWTtBQUMxRSxlQUFPLE9BQU8sU0FBUCxDQUFpQixhQUFqQixFQUFnQyxXQUFoQyxFQUE2QyxJQUE3QyxDQUFrRCxVQUFVLE1BQVYsRUFBa0I7QUFDekUsY0FBSSxLQUFLLE9BQUwsS0FBaUIsV0FBVyxJQUFYLElBQW1CLFdBQVcsU0FBL0MsQ0FBSixFQUErRDtBQUM3RCxnQkFBSSxPQUFPLFNBQVAsQ0FBaUIsT0FBakIsQ0FBeUIsY0FBekIsQ0FBd0MsS0FBSyxPQUE3QyxDQUFKLEVBQTJEO0FBQ3pELGtCQUFJLFdBQVcsSUFBSSxPQUFPLFNBQVAsQ0FBaUIsT0FBakIsQ0FBeUIsS0FBSyxPQUE5QixDQUFKLENBQTJDLElBQTNDLENBQWY7QUFDQSxxQkFBTyxTQUFTLFlBQVQsQ0FBc0IsSUFBdEIsQ0FBUDtBQUNELGFBSEQsTUFHTztBQUNMLG9CQUFNLDRCQUFOO0FBQ0Q7QUFDRjtBQUNELGlCQUFPLFVBQVUsRUFBRSxLQUFLLEVBQVAsRUFBakI7QUFDRCxTQVZ3RCxDQVV2RCxJQVZ1RCxDQVVsRCxJQVZrRCxDQUFsRCxDQUFQO0FBV0QsT0FaK0QsQ0FZOUQsSUFaOEQsQ0FZekQsSUFaeUQsQ0FBbEQsQ0FBZDs7QUFjQSxhQUFPLE9BQU8sV0FBUCxDQUFtQix3QkFBbkIsRUFBNkMsT0FBN0MsRUFBc0QsV0FBdEQsQ0FBUDtBQUNEO0FBdkJBLEdBbE5rQixDQUFyQixFQTBPSSxDQUFDO0FBQ0gsU0FBSyxjQURGO0FBRUgsV0FBTyxTQUFTLFlBQVQsQ0FBc0IsS0FBdEIsRUFBNkIsSUFBN0IsRUFBbUM7QUFDeEMsY0FBUSxTQUFTLEVBQWpCO0FBQ0EsVUFBSSxDQUFDLE9BQU8sS0FBUCxLQUFpQixXQUFqQixHQUErQixXQUEvQixHQUE2QyxRQUFRLEtBQVIsQ0FBOUMsTUFBa0UsUUFBdEUsRUFBZ0Y7QUFDOUUsZ0JBQVEsTUFBTSxVQUFVLE1BQU0sTUFBaEIsQ0FBZDtBQUNEO0FBQ0QsYUFBTyxPQUFPLGlCQUFQLENBQXlCLE9BQU8sT0FBUCxHQUFpQixVQUFqQixHQUE4QixLQUF2RCxDQUFQO0FBQ0Q7QUFSRSxHQUFELEVBU0Q7QUFDRCxTQUFLLGFBREo7QUFFRCxXQUFPLFNBQVMsV0FBVCxDQUFxQixHQUFyQixFQUEwQjtBQUMvQixVQUFJLFFBQVEsb0JBQVo7QUFDQSxVQUFJLEtBQUssSUFBTCxJQUFhLElBQUksT0FBSixDQUFZLEtBQUssSUFBakIsTUFBMkIsQ0FBNUMsRUFBK0M7QUFDN0MsaUJBQVMsTUFBTSxLQUFLLElBQUwsQ0FBVSxPQUFWLENBQWtCLGdCQUFsQixFQUFvQyxFQUFwQyxDQUFOLEdBQWdELEdBQXpEO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsaUJBQVMsU0FBVDtBQUNEO0FBQ0QsZUFBUyxXQUFUO0FBQ0EsYUFBTyxJQUFJLEtBQUosQ0FBVSxJQUFJLE1BQUosQ0FBVyxLQUFYLENBQVYsQ0FBUDtBQUNEO0FBWEEsR0FUQyxFQXFCRDtBQUNELFNBQUssV0FESjtBQUVELFdBQU8sU0FBUyxTQUFULENBQW1CLEdBQW5CLEVBQXdCO0FBQzdCLFVBQUksTUFBTSxFQUFWO0FBQ0EsV0FBSyxJQUFJLENBQVQsSUFBYyxHQUFkLEVBQW1CO0FBQ2pCLFlBQUksSUFBSSxjQUFKLENBQW1CLENBQW5CLENBQUosRUFBMkI7QUFDekIsY0FBSSxJQUFKLENBQVMsbUJBQW1CLENBQW5CLElBQXdCLEdBQXhCLEdBQThCLG1CQUFtQixJQUFJLENBQUosQ0FBbkIsQ0FBdkM7QUFDRDtBQUNGLGNBQU8sSUFBSSxJQUFKLENBQVMsR0FBVCxDQUFQO0FBQ0Y7QUFUQSxHQXJCQyxFQStCRDtBQUNELFNBQUssbUJBREo7QUFFRCxXQUFPLFNBQVMsaUJBQVQsQ0FBMkIsR0FBM0IsRUFBZ0MsTUFBaEMsRUFBd0MsSUFBeEMsRUFBOEMsSUFBOUMsRUFBb0Q7QUFDekQsZUFBUyxDQUFDLFVBQVUsS0FBWCxFQUFrQixXQUFsQixFQUFUO0FBQ0EsVUFBSSxDQUFDLElBQUQsSUFBUyxDQUFDLE9BQU8sSUFBUCxLQUFnQixXQUFoQixHQUE4QixXQUE5QixHQUE0QyxRQUFRLElBQVIsQ0FBN0MsTUFBZ0UsUUFBN0UsRUFBdUY7QUFDckYsZUFBTyxFQUFQO0FBQ0Q7QUFDRCxVQUFJLGNBQWM7QUFDaEIsYUFBSyxHQURXO0FBRWhCLGdCQUFRLE1BRlE7QUFHaEIsY0FBTTtBQUhVLE9BQWxCOztBQU1BLFVBQUksVUFBVSxPQUFPLFVBQVAsQ0FBa0IsWUFBbEIsRUFBZ0MsV0FBaEMsRUFBNkMsSUFBN0MsQ0FBa0QsWUFBWTtBQUMxRSxlQUFPLE9BQU8sU0FBUCxDQUFpQixlQUFqQixFQUFrQyxXQUFsQyxFQUErQyxJQUEvQyxDQUFvRCxVQUFVLE1BQVYsRUFBa0I7QUFDM0UsY0FBSSxXQUFXLElBQVgsSUFBbUIsV0FBVyxTQUFsQyxFQUE2QztBQUMzQyxtQkFBTyxPQUFPLE9BQVAsQ0FBZSxHQUFmLEVBQW9CLE1BQXBCLEVBQTRCLElBQTVCLEVBQWtDLEtBQUssTUFBdkMsRUFBK0MsSUFBL0MsQ0FBUDtBQUNEO0FBQ0QsaUJBQU8sTUFBUDtBQUNELFNBTE0sQ0FBUDtBQU1ELE9BUGEsQ0FBZDs7QUFTQSxhQUFPLE9BQU8sV0FBUCxDQUFtQiwwQkFBbkIsRUFBK0MsT0FBL0MsRUFBd0QsV0FBeEQsQ0FBUDtBQUNEO0FBdkJBLEdBL0JDLEVBdUREO0FBQ0QsU0FBSyxTQURKO0FBRUQsV0FBTyxTQUFTLE9BQVQsQ0FBaUIsR0FBakIsRUFBc0IsTUFBdEIsRUFBOEIsSUFBOUIsRUFBb0MsTUFBcEMsRUFBNEMsSUFBNUMsRUFBa0Q7QUFDdkQsVUFBSSxDQUFDLEdBQUwsRUFBVTtBQUNSLGVBQU8sUUFBUSxNQUFSLENBQWUsaUJBQWYsQ0FBUDtBQUNEO0FBQ0QsZUFBUyxDQUFDLFVBQVUsS0FBWCxFQUFrQixXQUFsQixFQUFUOztBQUVBO0FBQ0E7QUFDQSxVQUFJLE9BQU8sSUFBUCxLQUFnQixTQUFwQixFQUErQjtBQUM3QixlQUFPLEVBQUUsYUFBYSxJQUFmLEVBQVA7QUFDRDtBQUNELFVBQUksQ0FBQyxJQUFELElBQVMsQ0FBQyxPQUFPLElBQVAsS0FBZ0IsV0FBaEIsR0FBOEIsV0FBOUIsR0FBNEMsUUFBUSxJQUFSLENBQTdDLE1BQWdFLFFBQTdFLEVBQXVGO0FBQ3JGLGVBQU8sRUFBUDtBQUNEOztBQUVELFVBQUksV0FBVyxLQUFLLEdBQUwsQ0FBZjs7QUFFQSxhQUFPLElBQUksT0FBSixDQUFZLFVBQVUsT0FBVixFQUFtQixNQUFuQixFQUEyQjtBQUM1QztBQUNBLFlBQUksQ0FBQyxLQUFLLFdBQU4sSUFBcUIsV0FBVyxLQUFoQyxJQUF5QyxPQUFPLEtBQVAsQ0FBYSxjQUFiLENBQTRCLFFBQTVCLENBQTdDLEVBQW9GO0FBQ2xGLGlCQUFPLFFBQVEsT0FBTyxLQUFQLENBQWEsUUFBYixDQUFSLENBQVA7QUFDRDs7QUFFRCxZQUFJLGVBQWUsRUFBbkI7QUFDQSxnQkFBUSxJQUFJLE9BQUosQ0FBWSxVQUFVLE9BQVYsRUFBbUIsTUFBbkIsRUFBMkI7QUFDN0M7QUFDQSxjQUFJLFVBQVUsVUFBVSxJQUFJLE9BQUosQ0FBWTtBQUNsQyxzQkFBVSxrQkFEd0I7QUFFbEMsNEJBQWdCO0FBRmtCLFdBQVosQ0FBeEI7QUFJQSxjQUFJLFFBQVEsT0FBTyxRQUFQLEVBQVo7QUFDQSxjQUFJLFNBQVMsQ0FBQyxLQUFLLE9BQW5CLEVBQTRCO0FBQzFCLG9CQUFRLE1BQVIsQ0FBZSxhQUFmLEVBQThCLEtBQTlCO0FBQ0Q7O0FBRUQsY0FBSSxVQUFVO0FBQ1osb0JBQVEsTUFESTtBQUVaLHFCQUFTLE9BRkc7QUFHWixrQkFBTTtBQUhNLFdBQWQ7QUFLQSxjQUFJLElBQUosRUFBVTtBQUNSLG9CQUFRLElBQVIsR0FBZSxLQUFLLFNBQUwsQ0FBZSxJQUFmLENBQWY7QUFDRDs7QUFFRCx5QkFBZSxRQUFRLEdBQVIsQ0FBWSxhQUFaLENBQWY7QUFDQSxrQkFBUSxNQUFNLEdBQU4sRUFBVyxPQUFYLENBQVI7QUFDRCxTQXRCTyxFQXNCTCxLQXRCSyxDQXNCQyxVQUFVLEdBQVYsRUFBZTtBQUN0QixjQUFJLE9BQUosR0FBYyxzQ0FBc0MsSUFBSSxPQUExQyxHQUFvRCxHQUFsRTtBQUNBLGNBQUksWUFBSixHQUFtQixJQUFuQjtBQUNBLGdCQUFNLEdBQU47QUFDRCxTQTFCTyxFQTBCTCxJQTFCSyxDQTBCQSxVQUFVLFFBQVYsRUFBb0I7QUFDMUIsY0FBSSxDQUFDLFNBQVMsRUFBZCxFQUFrQjtBQUNoQixnQkFBSSxTQUFTLE1BQVQsS0FBb0IsR0FBeEIsRUFBNkI7QUFDM0IscUJBQU8sUUFBUCxDQUFnQixJQUFoQjtBQUNBLHFCQUFPLE1BQVAsQ0FBYyxJQUFkLENBQW1CLHVCQUFuQixFQUE0QyxTQUFTLElBQXJEO0FBQ0QsYUFIRCxNQUdPLElBQUksU0FBUyxNQUFULEtBQW9CLEdBQXhCLEVBQTZCO0FBQ2xDLHFCQUFPLE1BQVAsQ0FBYyxJQUFkLENBQW1CLHFCQUFuQixFQUEwQyxTQUFTLElBQW5EO0FBQ0Q7QUFDRDtBQUNBLG1CQUFPLENBQUMsU0FBUyxPQUFULENBQWlCLEdBQWpCLENBQXFCLGNBQXJCLEVBQXFDLE9BQXJDLENBQTZDLGtCQUE3QyxNQUFxRSxDQUFDLENBQXRFLEdBQTBFLFNBQVMsSUFBVCxFQUExRSxHQUE0RixTQUFTLElBQVQsRUFBN0YsRUFBOEcsSUFBOUcsQ0FBbUgsVUFBVSxLQUFWLEVBQWlCO0FBQ3pJLG9CQUFNLEtBQU47QUFDRCxhQUZNLENBQVA7QUFHRDs7QUFFRDtBQUNBLGNBQUksUUFBUSxTQUFTLE9BQVQsQ0FBaUIsR0FBakIsQ0FBcUIsYUFBckIsQ0FBWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQUksa0JBQWtCLEtBQXRCO0FBQ0EsY0FBSSxXQUFXLEtBQVgsSUFBb0IsQ0FBQyxZQUFyQixJQUFxQyxLQUFyQyxJQUE4QyxJQUFJLE9BQUosQ0FBWSxRQUFaLE1BQTBCLENBQUMsQ0FBekUsSUFBOEUsSUFBSSxPQUFKLENBQVksbUJBQW1CLENBQUMsQ0FBaEMsQ0FBbEYsRUFBc0g7QUFDcEgsb0JBQVEsSUFBUixDQUFhLGtDQUFiO0FBQ0EsOEJBQWtCLElBQWxCO0FBQ0Q7O0FBRUQsY0FBSSxTQUFTLE1BQVQsSUFBbUIsR0FBbkIsSUFBMEIsU0FBUyxNQUFULEdBQWtCLEdBQTVDLElBQW1ELEtBQW5ELElBQTRELFVBQVUsRUFBdEUsSUFBNEUsQ0FBQyxlQUFqRixFQUFrRztBQUNoRyxtQkFBTyxRQUFQLENBQWdCLEtBQWhCO0FBQ0Q7QUFDRDtBQUNBLGNBQUksU0FBUyxNQUFULEtBQW9CLEdBQXhCLEVBQTZCO0FBQzNCLG1CQUFPLEVBQVA7QUFDRDtBQUNELGlCQUFPLENBQUMsU0FBUyxPQUFULENBQWlCLEdBQWpCLENBQXFCLGNBQXJCLEVBQXFDLE9BQXJDLENBQTZDLGtCQUE3QyxNQUFxRSxDQUFDLENBQXRFLEdBQTBFLFNBQVMsSUFBVCxFQUExRSxHQUE0RixTQUFTLElBQVQsRUFBN0YsRUFBOEcsSUFBOUcsQ0FBbUgsVUFBVSxNQUFWLEVBQWtCO0FBQzFJO0FBQ0EsZ0JBQUksUUFBUSxTQUFTLE9BQVQsQ0FBaUIsR0FBakIsQ0FBcUIsZUFBckIsQ0FBWjtBQUNBLGdCQUFJLFNBQVMsQ0FBQyxPQUFPLE1BQVAsS0FBa0IsV0FBbEIsR0FBZ0MsV0FBaEMsR0FBOEMsUUFBUSxNQUFSLENBQS9DLE1BQW9FLFFBQWpGLEVBQTJGO0FBQ3pGLHNCQUFRLE1BQU0sS0FBTixDQUFZLEdBQVosQ0FBUjtBQUNBLGtCQUFJLE1BQU0sQ0FBTixNQUFhLEdBQWpCLEVBQXNCO0FBQ3BCLG9CQUFJLFlBQVksTUFBTSxDQUFOLEVBQVMsS0FBVCxDQUFlLEdBQWYsQ0FBaEI7QUFDQSx1QkFBTyxJQUFQLEdBQWMsT0FBTyxVQUFVLENBQVYsQ0FBUCxDQUFkO0FBQ0EsdUJBQU8sS0FBUCxHQUFlLFVBQVUsQ0FBVixJQUFlLFVBQVUsQ0FBVixDQUFmLEdBQThCLENBQTdDO0FBQ0Q7QUFDRCxxQkFBTyxXQUFQLEdBQXFCLE1BQU0sQ0FBTixNQUFhLEdBQWIsR0FBbUIsTUFBTSxDQUFOLENBQW5CLEdBQThCLE9BQU8sTUFBTSxDQUFOLENBQVAsQ0FBbkQ7QUFDRDs7QUFFRCxnQkFBSSxDQUFDLEtBQUssVUFBVixFQUFzQjtBQUNwQixxQkFBTyxNQUFQO0FBQ0Q7O0FBRUQsZ0JBQUksVUFBVSxFQUFkO0FBQ0EscUJBQVMsT0FBVCxDQUFpQixPQUFqQixDQUF5QixVQUFVLElBQVYsRUFBZ0IsR0FBaEIsRUFBcUI7QUFDNUMsc0JBQVEsR0FBUixJQUFlLElBQWY7QUFDRCxhQUZEOztBQUlBLG1CQUFPLElBQUksT0FBSixDQUFZLFVBQVUsT0FBVixFQUFtQixNQUFuQixFQUEyQjtBQUM1QyxzQkFBUSxFQUFFLFFBQVEsTUFBVixFQUFrQixTQUFTLE9BQTNCLEVBQVI7QUFDRCxhQUZNLENBQVA7QUFHRCxXQXpCTSxDQUFQO0FBMEJELFNBdEZPLEVBc0ZMLEtBdEZLLENBc0ZDLFVBQVUsR0FBVixFQUFlO0FBQ3RCLGNBQUksUUFBUSxXQUFaLEVBQXlCO0FBQ3ZCLG1CQUFPLFFBQVAsQ0FBZ0IsSUFBaEI7QUFDQSxtQkFBTyxNQUFQLENBQWMsSUFBZCxDQUFtQixpQkFBbkIsRUFBc0MsR0FBdEM7QUFDRDtBQUNELGNBQUksT0FBTyxLQUFQLENBQWEsY0FBYixDQUE0QixRQUE1QixDQUFKLEVBQTJDO0FBQ3pDO0FBQ0EsbUJBQU8sT0FBTyxLQUFQLENBQWEsUUFBYixDQUFQO0FBQ0Q7QUFDRDtBQUNBLGdCQUFNLEdBQU47QUFDRCxTQWpHTyxDQUFSO0FBa0dELE9BekdNLEVBeUdKLElBekdJLENBeUdDLFVBQVUsTUFBVixFQUFrQjtBQUN4QjtBQUNBLFlBQUksV0FBVyxLQUFmLEVBQXNCO0FBQ3BCLGlCQUFPLEtBQVAsQ0FBYSxRQUFiLElBQXlCLFFBQVEsT0FBUixDQUFnQixNQUFoQixDQUF6QjtBQUNEOztBQUVEO0FBQ0EsWUFBSSxNQUFNLE9BQU4sQ0FBYyxNQUFkLENBQUosRUFBMkI7QUFDekIsY0FBSSxhQUFhLE9BQU8sR0FBUCxDQUFXLElBQVgsQ0FBakI7QUFDQSxxQkFBVyxJQUFYLEdBQWtCLE9BQU8sSUFBekI7QUFDQSxxQkFBVyxLQUFYLEdBQW1CLE9BQU8sS0FBMUI7QUFDQSxxQkFBVyxXQUFYLEdBQXlCLE9BQU8sV0FBaEM7QUFDQSxpQkFBTyxVQUFQO0FBQ0Q7QUFDRCxlQUFPLEtBQUssTUFBTCxDQUFQO0FBQ0QsT0F4SE0sQ0FBUDtBQXlIRDtBQTVJQSxHQXZEQyxFQW9NRDtBQUNELFNBQUssVUFESjtBQUVELFdBQU8sU0FBUyxRQUFULENBQWtCLEtBQWxCLEVBQXlCO0FBQzlCLGNBQVEsU0FBUyxFQUFqQjtBQUNBLFVBQUksVUFBVSxLQUFLLEtBQW5CLEVBQTBCO0FBQ3hCO0FBQ0Q7QUFDRCxXQUFLLEtBQUwsR0FBYSxLQUFiO0FBQ0EsVUFBSSxDQUFDLEtBQUwsRUFBWTtBQUNWLGVBQU8sT0FBUCxDQUFlLElBQWY7QUFDQTtBQUNBLFlBQUk7QUFDRixpQkFBTyxhQUFhLFVBQWIsQ0FBd0IsYUFBeEIsQ0FBUDtBQUNELFNBRkQsQ0FFRSxPQUFPLEdBQVAsRUFBWTtBQUNaO0FBQ0Q7QUFDRjtBQUNEO0FBQ0EsVUFBSTtBQUNGLHFCQUFhLE9BQWIsQ0FBcUIsYUFBckIsRUFBb0MsS0FBcEM7QUFDRCxPQUZELENBRUUsT0FBTyxHQUFQLEVBQVk7QUFDWjtBQUNEO0FBQ0QsYUFBTyxPQUFPLFdBQVAsRUFBUCxDQXJCOEIsQ0FxQkQ7QUFDOUI7QUF4QkEsR0FwTUMsRUE2TkQ7QUFDRCxTQUFLLFVBREo7QUFFRCxXQUFPLFNBQVMsUUFBVCxHQUFvQjtBQUN6QixVQUFJLEtBQUssS0FBVCxFQUFnQjtBQUNkLGVBQU8sS0FBSyxLQUFaO0FBQ0Q7QUFDRCxVQUFJO0FBQ0YsWUFBSSxRQUFRLGFBQWEsT0FBYixDQUFxQixhQUFyQixLQUF1QyxFQUFuRDtBQUNBLGFBQUssS0FBTCxHQUFhLEtBQWI7QUFDQSxlQUFPLEtBQVA7QUFDRCxPQUpELENBSUUsT0FBTyxDQUFQLEVBQVU7QUFDVixlQUFPLEVBQVA7QUFDRDtBQUNGO0FBYkEsR0E3TkMsRUEyT0Q7QUFDRCxTQUFLLFNBREo7QUFFRCxXQUFPLFNBQVMsT0FBVCxDQUFpQixJQUFqQixFQUF1QjtBQUM1QixVQUFJLENBQUMsSUFBTCxFQUFXO0FBQ1QsYUFBSyxRQUFMLENBQWMsSUFBZDtBQUNBO0FBQ0EsWUFBSTtBQUNGLGlCQUFPLGFBQWEsVUFBYixDQUF3QixZQUF4QixDQUFQO0FBQ0QsU0FGRCxDQUVFLE9BQU8sR0FBUCxFQUFZO0FBQ1o7QUFDRDtBQUNGO0FBQ0Q7QUFDQSxVQUFJO0FBQ0YscUJBQWEsT0FBYixDQUFxQixZQUFyQixFQUFtQyxLQUFLLFNBQUwsQ0FBZSxJQUFmLENBQW5DO0FBQ0QsT0FGRCxDQUVFLE9BQU8sR0FBUCxFQUFZO0FBQ1o7QUFDRDtBQUNGO0FBbEJBLEdBM09DLEVBOFBEO0FBQ0QsU0FBSyxTQURKO0FBRUQsV0FBTyxTQUFTLE9BQVQsR0FBbUI7QUFDeEIsVUFBSTtBQUNGLGVBQU8sS0FBSyxLQUFMLENBQVcsYUFBYSxPQUFiLENBQXFCLFlBQXJCLEtBQXNDLElBQWpELENBQVA7QUFDRCxPQUZELENBRUUsT0FBTyxDQUFQLEVBQVU7QUFDVjtBQUNEO0FBQ0Y7QUFSQSxHQTlQQyxFQXVRRDtBQUNELFNBQUssWUFESjtBQUVELFdBQU8sU0FBUyxVQUFULENBQW9CLEdBQXBCLEVBQXlCO0FBQzlCLGFBQU8sT0FBUCxHQUFpQixHQUFqQjtBQUNBLFVBQUksQ0FBQyxPQUFPLGFBQVosRUFBMkI7QUFDekIsZUFBTyxVQUFQLEdBQW9CLEdBQXBCO0FBQ0Q7QUFDRjtBQVBBLEdBdlFDLEVBK1FEO0FBQ0QsU0FBSyxZQURKO0FBRUQsV0FBTyxTQUFTLFVBQVQsR0FBc0I7QUFDM0IsYUFBTyxPQUFPLE9BQWQ7QUFDRDtBQUpBLEdBL1FDLEVBb1JEO0FBQ0QsU0FBSyxXQURKO0FBRUQsV0FBTyxTQUFTLFNBQVQsQ0FBbUIsR0FBbkIsRUFBd0I7QUFDN0IsYUFBTyxPQUFPLFVBQVAsQ0FBa0IsR0FBbEIsQ0FBUDtBQUNEO0FBSkEsR0FwUkMsRUF5UkQ7QUFDRCxTQUFLLFdBREo7QUFFRCxXQUFPLFNBQVMsU0FBVCxHQUFxQjtBQUMxQixhQUFPLE9BQU8sVUFBUCxFQUFQO0FBQ0Q7QUFKQSxHQXpSQyxFQThSRDtBQUNELFNBQUssV0FESjtBQUVELFdBQU8sU0FBUyxTQUFULENBQW1CLEdBQW5CLEVBQXdCO0FBQzdCLGNBQVEsSUFBUixDQUFhLHFFQUFiO0FBQ0EsYUFBTyxVQUFQLEdBQW9CLEdBQXBCO0FBQ0EsYUFBTyxhQUFQLEdBQXVCLElBQXZCO0FBQ0Q7QUFOQSxHQTlSQyxFQXFTRDtBQUNELFNBQUssZUFESjtBQUVELFdBQU8sU0FBUyxhQUFULENBQXVCLEdBQXZCLEVBQTRCO0FBQ2pDLGFBQU8sVUFBUCxHQUFvQixHQUFwQjtBQUNBLGFBQU8sYUFBUCxHQUF1QixJQUF2QjtBQUNEO0FBTEEsR0FyU0MsRUEyU0Q7QUFDRCxTQUFLLFdBREo7QUFFRCxXQUFPLFNBQVMsU0FBVCxHQUFxQjtBQUMxQixjQUFRLElBQVIsQ0FBYSxxRUFBYjtBQUNBLGFBQU8sT0FBTyxVQUFkO0FBQ0Q7QUFMQSxHQTNTQyxFQWlURDtBQUNELFNBQUssZUFESjtBQUVELFdBQU8sU0FBUyxhQUFULEdBQXlCO0FBQzlCLGFBQU8sT0FBTyxVQUFkO0FBQ0Q7QUFKQSxHQWpUQyxFQXNURDtBQUNELFNBQUssWUFESjtBQUVELFdBQU8sU0FBUyxVQUFULEdBQXNCO0FBQzNCLGFBQU8sS0FBUCxHQUFlLEVBQWY7QUFDRDtBQUpBLEdBdFRDLEVBMlREO0FBQ0QsU0FBSyxNQURKO0FBRUQsV0FBTyxTQUFTLElBQVQsR0FBZ0IsQ0FBRTtBQUZ4QixHQTNUQyxFQThURDtBQUNELFNBQUssVUFESjtBQUVELFdBQU8sU0FBUyxRQUFULENBQWtCLEtBQWxCLEVBQXlCO0FBQzlCLGFBQU8sS0FBUDtBQUNEO0FBSkEsR0E5VEMsRUFtVUQ7QUFDRCxTQUFLLGtCQURKO0FBRUQsV0FBTyxTQUFTLGdCQUFULENBQTBCLE1BQTFCLEVBQWtDO0FBQ3ZDLFVBQUksZUFBZSxPQUFPLE9BQVAsQ0FBZSxNQUFsQztBQUNBLGFBQU8sT0FBUCxHQUFpQixPQUFPLE9BQVAsQ0FBZSxNQUFmLENBQXNCLFVBQVUsQ0FBVixFQUFhO0FBQ2xELFlBQUksTUFBTSxNQUFOLElBQWdCLEVBQUUsTUFBRixLQUFhLE1BQWpDLEVBQXlDLE9BQU8sSUFBUDtBQUN6QyxTQUFDLEVBQUUsVUFBRixJQUFnQixPQUFPLElBQXhCLEVBQThCLElBQTlCLENBQW1DLENBQW5DLEVBQXNDLE1BQXRDO0FBQ0EsZUFBTyxLQUFQO0FBQ0QsT0FKZ0IsQ0FBakI7QUFLQSxhQUFPLGlCQUFpQixPQUFPLE9BQVAsQ0FBZSxNQUF2QztBQUNEO0FBVkEsR0FuVUMsRUE4VUQ7QUFDRCxTQUFLLGdCQURKO0FBRUQsV0FBTyxTQUFTLGNBQVQsQ0FBd0IsTUFBeEIsRUFBZ0MsSUFBaEMsRUFBc0M7QUFDM0MsYUFBTyxPQUFQLENBQWUsSUFBZixDQUFvQixNQUFwQjtBQUNBLGFBQU8sT0FBUCxDQUFlLElBQWYsQ0FBb0IsVUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQjtBQUNsQyxlQUFPLENBQUMsRUFBRSxRQUFGLElBQWMsQ0FBZixLQUFxQixFQUFFLFFBQUYsSUFBYyxDQUFuQyxDQUFQO0FBQ0QsT0FGRDtBQUdBLGFBQU8sTUFBUCxHQUFnQixJQUFoQjtBQUNBLE9BQUMsT0FBTyxJQUFQLElBQWUsT0FBTyxJQUF2QixFQUE2QixJQUE3QixDQUFrQyxNQUFsQyxFQUEwQyxNQUExQztBQUNEO0FBVEEsR0E5VUMsRUF3VkQ7QUFDRCxTQUFLLFdBREo7QUFFRCxXQUFPLFNBQVMsU0FBVCxDQUFtQixJQUFuQixFQUF5QjtBQUM5QixhQUFPLE9BQU8sT0FBUCxDQUFlLE1BQWYsQ0FBc0IsVUFBVSxNQUFWLEVBQWtCLE1BQWxCLEVBQTBCO0FBQ3JELFlBQUksTUFBSixFQUFZLE9BQU8sTUFBUDtBQUNaLFlBQUksT0FBTyxNQUFQLEtBQWtCLElBQXRCLEVBQTRCLE9BQU8sTUFBUDtBQUM3QixPQUhNLEVBR0osSUFISSxDQUFQO0FBSUQ7QUFQQSxHQXhWQyxFQWdXRDtBQUNELFNBQUssWUFESjtBQUVELFdBQU8sU0FBUyxVQUFULENBQW9CLFFBQXBCLEVBQThCO0FBQ25DLFVBQUksT0FBTyxHQUFHLEtBQUgsQ0FBUyxJQUFULENBQWMsU0FBZCxFQUF5QixDQUF6QixDQUFYO0FBQ0EsYUFBTyxRQUFRLEdBQVIsQ0FBWSxPQUFPLE9BQVAsQ0FBZSxHQUFmLENBQW1CLFVBQVUsTUFBVixFQUFrQjtBQUN0RCxlQUFPLENBQUMsT0FBTyxRQUFQLEtBQW9CLE9BQU8sSUFBNUIsRUFBa0MsS0FBbEMsQ0FBd0MsTUFBeEMsRUFBZ0QsSUFBaEQsQ0FBUDtBQUNELE9BRmtCLENBQVosQ0FBUDtBQUdEO0FBUEEsR0FoV0MsRUF3V0Q7QUFDRCxTQUFLLFdBREo7QUFFRCxXQUFPLFNBQVMsU0FBVCxDQUFtQixRQUFuQixFQUE2QjtBQUNsQyxVQUFJLE9BQU8sR0FBRyxLQUFILENBQVMsSUFBVCxDQUFjLFNBQWQsRUFBeUIsQ0FBekIsQ0FBWDtBQUNBLFVBQUksYUFBYSxTQUFTLFVBQVQsQ0FBb0IsS0FBcEIsRUFBMkIsUUFBM0IsRUFBcUM7QUFDcEQsWUFBSSxTQUFTLE9BQU8sT0FBUCxDQUFlLEtBQWYsQ0FBYjtBQUNBLFlBQUksQ0FBQyxNQUFMLEVBQWEsT0FBTyxRQUFRLE9BQVIsQ0FBZ0IsSUFBaEIsQ0FBUDtBQUNiLGVBQU8sUUFBUSxPQUFSLENBQWdCLENBQUMsVUFBVSxPQUFPLFFBQVAsQ0FBVixJQUE4QixPQUFPLElBQXRDLEVBQTRDLEtBQTVDLENBQWtELE1BQWxELEVBQTBELEdBQUcsS0FBSCxDQUFTLElBQVQsQ0FBYyxTQUFkLEVBQXlCLENBQXpCLENBQTFELENBQWhCLEVBQXdHLElBQXhHLENBQTZHLFVBQVUsTUFBVixFQUFrQjtBQUNwSSxjQUFJLFdBQVcsSUFBWCxJQUFtQixXQUFXLFNBQWxDLEVBQTZDLE9BQU8sTUFBUDtBQUM3QyxpQkFBTyxXQUFXLEtBQVgsQ0FBaUIsSUFBakIsRUFBdUIsQ0FBQyxRQUFRLENBQVQsRUFBWSxNQUFaLENBQW1CLElBQW5CLENBQXZCLENBQVA7QUFDRCxTQUhNLENBQVA7QUFJRCxPQVBEO0FBUUEsYUFBTyxXQUFXLEtBQVgsQ0FBaUIsSUFBakIsRUFBdUIsQ0FBQyxDQUFELEVBQUksTUFBSixDQUFXLElBQVgsQ0FBdkIsQ0FBUDtBQUNEO0FBYkEsR0F4V0MsRUFzWEQ7QUFDRCxTQUFLLGFBREo7QUFFRCxXQUFPLFNBQVMsV0FBVCxDQUFxQixRQUFyQixFQUErQixLQUEvQixFQUFzQztBQUMzQyxVQUFJLE9BQU8sR0FBRyxLQUFILENBQVMsSUFBVCxDQUFjLFNBQWQsRUFBeUIsQ0FBekIsQ0FBWDtBQUNBLGFBQU8sT0FBTyxPQUFQLENBQWUsTUFBZixDQUFzQixVQUFVLEtBQVYsRUFBaUIsTUFBakIsRUFBeUI7QUFDcEQsZUFBTyxDQUFDLE9BQU8sUUFBUCxLQUFvQixPQUFPLFFBQTVCLEVBQXNDLEtBQXRDLENBQTRDLE1BQTVDLEVBQW9ELENBQUMsS0FBRCxFQUFRLE1BQVIsQ0FBZSxJQUFmLENBQXBELENBQVA7QUFDRCxPQUZNLEVBRUosS0FGSSxDQUFQO0FBR0Q7QUFQQSxHQXRYQyxFQThYRDtBQUNELFNBQUssYUFESjtBQUVELFdBQU8sU0FBUyxXQUFULEdBQXVCO0FBQzVCLFVBQUksTUFBTSxPQUFPLE9BQVAsR0FBaUIsVUFBM0I7QUFDQSxVQUFJLE9BQU8sS0FBSyxPQUFMLEVBQVg7QUFDQSxVQUFJLElBQUosRUFBVTtBQUNSLGVBQU8sT0FBTyxXQUFQLENBQW1CLDBCQUFuQixFQUErQyxRQUFRLE9BQVIsQ0FBZ0IsSUFBaEIsQ0FBL0MsRUFBc0U7QUFDM0UsZUFBSyxHQURzRTtBQUUzRSxrQkFBUTtBQUZtRSxTQUF0RSxDQUFQO0FBSUQ7QUFDRCxVQUFJLFFBQVEsS0FBSyxRQUFMLEVBQVo7QUFDQSxVQUFJLENBQUMsS0FBTCxFQUFZO0FBQ1YsZUFBTyxPQUFPLFdBQVAsQ0FBbUIsMEJBQW5CLEVBQStDLFFBQVEsT0FBUixDQUFnQixJQUFoQixDQUEvQyxFQUFzRTtBQUMzRSxlQUFLLEdBRHNFO0FBRTNFLGtCQUFRO0FBRm1FLFNBQXRFLENBQVA7QUFJRDtBQUNELGFBQU8sT0FBTyxpQkFBUCxDQUF5QixHQUF6QixFQUE4QixJQUE5QixDQUFtQyxVQUFVLFFBQVYsRUFBb0I7QUFDNUQsZUFBTyxPQUFQLENBQWUsUUFBZjtBQUNBLGVBQU8sUUFBUDtBQUNELE9BSE0sQ0FBUDtBQUlEO0FBdEJBLEdBOVhDLEVBcVpEO0FBQ0QsU0FBSyxRQURKO0FBRUQsV0FBTyxTQUFTLE1BQVQsR0FBa0I7QUFDdkIsYUFBTyxRQUFQLENBQWdCLElBQWhCO0FBQ0EsYUFBTyxPQUFQLENBQWUsSUFBZjtBQUNBLGFBQU8sVUFBUDtBQUNBLGFBQU8sT0FBTyxpQkFBUCxDQUF5QixPQUFPLE9BQVAsR0FBaUIsU0FBMUMsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7QUFUQyxHQXJaQyxFQW9hRDtBQUNELFNBQUssTUFESjtBQUVELFdBQU8sU0FBUyxJQUFULENBQWMsS0FBZCxFQUFxQixPQUFyQixFQUE4QixJQUE5QixFQUFvQztBQUN6QztBQUNBLFVBQUksQ0FBQyxJQUFELElBQVMsT0FBTyxPQUFQLEtBQW1CLFVBQWhDLEVBQTRDO0FBQzFDLGVBQU8sT0FBUDtBQUNBLGtCQUFVLEVBQVY7QUFDRDs7QUFFRCxhQUFPLFFBQVEsWUFBWTtBQUN6QixnQkFBUSxHQUFSLENBQVksU0FBWjtBQUNELE9BRkQ7QUFHQSxnQkFBVSxXQUFXLEVBQXJCOztBQUVBO0FBQ0EsVUFBSSxNQUFNLE1BQVYsRUFBa0I7QUFDaEIsZ0JBQVEsTUFBTSxDQUFOLENBQVI7QUFDRDtBQUNELFVBQUksQ0FBQyxLQUFMLEVBQVk7QUFDVixlQUFPLEtBQUssY0FBTCxDQUFQO0FBQ0Q7O0FBRUQsVUFBSSxZQUFZLFNBQVMsU0FBVCxHQUFxQjtBQUNuQyxlQUFPLFFBQVEsSUFBUixJQUFnQixNQUFNLFlBQU4sQ0FBbUIsUUFBbkIsQ0FBdkI7QUFDRCxPQUZEOztBQUlBOzs7O0FBSUEsVUFBSSxnQkFBZ0IsU0FBUyxhQUFULEdBQXlCO0FBQzNDLFlBQUksYUFBYSxFQUFFLE1BQU0sRUFBUixFQUFqQjtBQUNBLFlBQUksV0FBVyxTQUFTLFFBQVQsQ0FBa0IsSUFBbEIsRUFBd0IsS0FBeEIsRUFBK0I7QUFDNUMsY0FBSSxVQUFVLEtBQUssTUFBTCxDQUFZLENBQUMsQ0FBYixNQUFvQixJQUFsQztBQUNBLGNBQUksT0FBSixFQUFhO0FBQ1gsbUJBQU8sS0FBSyxPQUFMLENBQWEsSUFBYixFQUFtQixFQUFuQixDQUFQO0FBQ0Q7QUFDRCxjQUFJLFFBQVEsS0FBSyxPQUFMLENBQWEsVUFBYixFQUF5QixHQUF6QixFQUE4QixPQUE5QixDQUFzQyxNQUF0QyxFQUE4QyxFQUE5QyxFQUFrRCxLQUFsRCxDQUF3RCxHQUF4RCxDQUFaO0FBQ0EsY0FBSSxVQUFVLFVBQWQ7QUFDQSxpQkFBTyxPQUFPLE1BQU0sS0FBTixFQUFkLEVBQTZCO0FBQzNCLGdCQUFJLENBQUMsTUFBTSxNQUFYLEVBQW1CO0FBQ2pCLGtCQUFJLE9BQUosRUFBYTtBQUNYLG9CQUFJLENBQUMsUUFBUSxJQUFSLENBQUwsRUFBb0I7QUFDbEIsMEJBQVEsSUFBUixJQUFnQixFQUFoQjtBQUNEO0FBQ0Qsd0JBQVEsSUFBUixFQUFjLElBQWQsQ0FBbUIsS0FBbkI7QUFDRCxlQUxELE1BS087QUFDTCx3QkFBUSxJQUFSLElBQWdCLEtBQWhCO0FBQ0Q7QUFDRixhQVRELE1BU087QUFDTCxrQkFBSSxDQUFDLFFBQVEsSUFBUixDQUFMLEVBQW9CO0FBQ2xCLHdCQUFRLElBQVIsSUFBZ0IsRUFBaEI7QUFDRDtBQUNELHdCQUFVLFFBQVEsSUFBUixDQUFWO0FBQ0Q7QUFDRjtBQUNGLFNBeEJEOztBQTBCQTtBQUNBLFlBQUksV0FBVyxJQUFJLFFBQUosQ0FBYSxLQUFiLENBQWY7QUFDQSxZQUFJLFVBQVUsU0FBUyxPQUFULEVBQWQ7QUFDQSxZQUFJLFFBQVEsSUFBWjtBQUNBLGVBQU8sUUFBUSxRQUFRLElBQVIsR0FBZSxLQUE5QixFQUFxQztBQUNuQyxtQkFBUyxNQUFNLENBQU4sQ0FBVCxFQUFtQixNQUFNLENBQU4sQ0FBbkI7QUFDRDtBQUNELGVBQU8sVUFBUDtBQUNELE9BcENEOztBQXNDQTtBQUNBLFVBQUksU0FBUyxTQUFTLE1BQVQsQ0FBZ0IsS0FBaEIsRUFBdUI7QUFDbEMsWUFBSSxLQUFKLEVBQVc7QUFDVCxnQkFBTSxjQUFOO0FBQ0Q7QUFDRCxZQUFJLFNBQVMsV0FBYjtBQUNBLFlBQUksQ0FBQyxNQUFMLEVBQWE7QUFDWDtBQUNEO0FBQ0QsWUFBSSxNQUFKLENBQVcsTUFBWCxFQUFtQixjQUFuQixDQUFrQyxlQUFsQyxFQUFtRCxJQUFuRCxDQUF3RCxVQUFVLEdBQVYsRUFBZTtBQUNyRSxlQUFLLElBQUwsRUFBVyxHQUFYO0FBQ0QsU0FGRCxFQUVHLElBRkg7QUFHRCxPQVhEOztBQWFBO0FBQ0EsVUFBSSxNQUFNLFdBQVYsRUFBdUI7QUFDckIsY0FBTSxXQUFOLENBQWtCLFFBQWxCLEVBQTRCLE1BQTVCO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsY0FBTSxnQkFBTixDQUF1QixRQUF2QixFQUFpQyxNQUFqQztBQUNEOztBQUVELGFBQU87QUFDTCxnQkFBUSxNQURIO0FBRUwsbUJBQVcsU0FGTjtBQUdMLHVCQUFlO0FBSFYsT0FBUDtBQUtEO0FBOUZBLEdBcGFDLEVBbWdCRDtBQUNELFNBQUssV0FESjtBQUVELFdBQU8sU0FBUyxTQUFULENBQW1CLElBQW5CLEVBQXlCLFNBQXpCLEVBQW9DO0FBQ3pDLFVBQUksQ0FBQyxJQUFMLEVBQVc7QUFDVCxlQUFPLEVBQVA7QUFDRDtBQUNELFVBQUksQ0FBQyxTQUFELElBQWMsQ0FBQyxVQUFVLEdBQTdCLEVBQWtDO0FBQ2hDLGVBQU8sSUFBUDtBQUNEO0FBQ0QsVUFBSSxVQUFVLEdBQVYsQ0FBYyxPQUFkLENBQXNCLEdBQXRCLE1BQStCLENBQUMsQ0FBcEMsRUFBdUM7QUFDckMsWUFBSSxRQUFRLElBQVo7QUFDQSxZQUFJLFFBQVEsVUFBVSxHQUFWLENBQWMsS0FBZCxDQUFvQixHQUFwQixDQUFaO0FBQ0EsWUFBSSxNQUFNLEVBQVY7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksTUFBTSxNQUExQixFQUFrQyxHQUFsQyxFQUF1QztBQUNyQyxnQkFBTSxNQUFNLENBQU4sQ0FBTjs7QUFFQTtBQUNBLGNBQUksTUFBTSxjQUFOLENBQXFCLEtBQXJCLENBQUosRUFBaUM7QUFDL0Isb0JBQVEsTUFBTSxJQUFkO0FBQ0Q7O0FBRUQ7QUFDQSxjQUFJLENBQUMsTUFBTSxjQUFOLENBQXFCLEdBQXJCLENBQUwsRUFBZ0M7QUFDOUI7QUFDRDs7QUFFRDtBQUNBLGNBQUksUUFBUSxNQUFNLE1BQU0sTUFBTixHQUFlLENBQXJCLENBQVIsSUFBbUMsVUFBVSxRQUE3QyxJQUF5RCxDQUFDLE1BQU0sT0FBTixDQUFjLE1BQU0sR0FBTixDQUFkLENBQTlELEVBQXlGO0FBQ3ZGLGtCQUFNLEdBQU4sSUFBYSxDQUFDLE1BQU0sR0FBTixDQUFELENBQWI7QUFDRDs7QUFFRDtBQUNBLGtCQUFRLE1BQU0sR0FBTixDQUFSO0FBQ0Q7QUFDRCxlQUFPLEtBQVA7QUFDRCxPQTFCRCxNQTBCTztBQUNMO0FBQ0EsWUFBSSxVQUFVLFFBQVYsSUFBc0IsQ0FBQyxNQUFNLE9BQU4sQ0FBYyxLQUFLLFVBQVUsR0FBZixDQUFkLENBQTNCLEVBQStEO0FBQzdELGVBQUssVUFBVSxHQUFmLElBQXNCLENBQUMsS0FBSyxVQUFVLEdBQWYsQ0FBRCxDQUF0QjtBQUNEO0FBQ0QsZUFBTyxLQUFLLFVBQVUsR0FBZixDQUFQO0FBQ0Q7QUFDRjtBQTFDQSxHQW5nQkMsQ0ExT0o7O0FBMHhCQSxTQUFPLE1BQVA7QUFDRCxDQTc3QlksRUFBYjs7QUErN0JBOzs7QUFHQSxRQUFRLE1BQVIsR0FBaUIsTUFBakI7QUFDQSxPQUFPLE9BQVAsR0FBaUIscUJBQWpCO0FBQ0EsT0FBTyxVQUFQLEdBQW9CLE9BQU8sT0FBM0I7QUFDQSxPQUFPLGFBQVAsR0FBdUIsS0FBdkI7QUFDQSxPQUFPLE9BQVAsR0FBaUIsRUFBakI7QUFDQSxPQUFPLEtBQVAsR0FBZSxFQUFmO0FBQ0EsT0FBTyxTQUFQLEdBQW1CLFFBQVEsYUFBUixDQUFuQjtBQUNBLE9BQU8sTUFBUCxHQUFnQixJQUFJLFlBQUosQ0FBaUI7QUFDL0IsWUFBVSxLQURxQjtBQUUvQixnQkFBYztBQUZpQixDQUFqQixDQUFoQjs7QUFLQSxPQUFPLE9BQVAsR0FBaUIsT0FBTyxNQUFQLEdBQWdCLE1BQWpDOzs7OztBQ3orQkE7O0FBRUEsT0FBTyxPQUFQLEdBQWlCO0FBQ2YsV0FBUyxRQUFRLFdBQVI7QUFETSxDQUFqQjs7O0FDRkE7O0FBRUEsSUFBSSxVQUFVLFFBQVEscUJBQVIsQ0FBZDtBQUNBLElBQUksVUFBVSxTQUFTLE9BQVQsQ0FBaUIsTUFBakIsRUFBeUI7QUFDckMsU0FBTztBQUNMLGdCQUFZLFNBQVMsVUFBVCxDQUFvQixJQUFwQixFQUEwQixRQUExQixFQUFvQyxHQUFwQyxFQUF5QyxnQkFBekMsRUFBMkQ7QUFDckUsYUFBTyxJQUFJLE9BQUosQ0FBWSxVQUFVLE9BQVYsRUFBbUIsTUFBbkIsRUFBMkI7QUFDNUM7QUFDQSxZQUFJLE1BQU0sSUFBSSxjQUFKLEVBQVY7O0FBRUEsWUFBSSxPQUFPLGdCQUFQLEtBQTRCLFVBQWhDLEVBQTRDO0FBQzFDLGNBQUksTUFBSixDQUFXLFVBQVgsR0FBd0IsZ0JBQXhCO0FBQ0Q7O0FBRUQsWUFBSSxLQUFLLElBQUksUUFBSixFQUFUO0FBQ0EsV0FBRyxNQUFILENBQVUsTUFBVixFQUFrQixRQUFsQjtBQUNBLFdBQUcsTUFBSCxDQUFVLEtBQVYsRUFBaUIsR0FBakI7QUFDQSxXQUFHLE1BQUgsQ0FBVSxNQUFWLEVBQWtCLElBQWxCOztBQUVBO0FBQ0EsWUFBSSxPQUFKLEdBQWMsVUFBVSxHQUFWLEVBQWU7QUFDM0IsY0FBSSxZQUFKLEdBQW1CLElBQW5CO0FBQ0EsaUJBQU8sR0FBUDtBQUNELFNBSEQ7O0FBS0EsWUFBSSxNQUFKLEdBQWEsWUFBWTtBQUN2QixjQUFJLElBQUksTUFBSixJQUFjLEdBQWQsSUFBcUIsSUFBSSxNQUFKLEdBQWEsR0FBdEMsRUFBMkM7QUFDekMsZ0JBQUksV0FBVyxLQUFLLEtBQUwsQ0FBVyxJQUFJLFFBQWYsQ0FBZjtBQUNBLHFCQUFTLE9BQVQsR0FBbUIsU0FBbkI7QUFDQSxxQkFBUyxJQUFULEdBQWdCLEtBQUssSUFBckI7QUFDQSxxQkFBUyxJQUFULEdBQWdCLEtBQUssSUFBckI7QUFDQSxxQkFBUyxHQUFULEdBQWUsU0FBUyxVQUF4QjtBQUNBLG9CQUFRLFFBQVI7QUFDRCxXQVBELE1BT087QUFDTCxtQkFBTyxJQUFJLFFBQUosSUFBZ0IsdUJBQXZCO0FBQ0Q7QUFDRixTQVhEOztBQWFBLFlBQUksT0FBSixHQUFjLFVBQVUsR0FBVixFQUFlO0FBQzNCLGlCQUFPLEdBQVA7QUFDRCxTQUZEOztBQUlBLFlBQUksSUFBSixDQUFTLE1BQVQsRUFBaUIsT0FBTyxPQUFQLEdBQWlCLGtCQUFsQztBQUNBLFlBQUksUUFBUSxLQUFaO0FBQ0EsWUFBSTtBQUNGLGtCQUFRLGFBQWEsT0FBYixDQUFxQixhQUFyQixDQUFSO0FBQ0QsU0FGRCxDQUVFLE9BQU8sQ0FBUCxFQUFVO0FBQ1Y7QUFDRDtBQUNELFlBQUksS0FBSixFQUFXO0FBQ1QsY0FBSSxnQkFBSixDQUFxQixhQUFyQixFQUFvQyxLQUFwQztBQUNEO0FBQ0QsWUFBSSxJQUFKLENBQVMsRUFBVDtBQUNELE9BL0NNLENBQVA7QUFnREQsS0FsREk7QUFtREwsa0JBQWMsU0FBUyxZQUFULENBQXNCLElBQXRCLEVBQTRCO0FBQ3hDLFVBQUksUUFBUSxLQUFaO0FBQ0EsVUFBSTtBQUNGLGdCQUFRLGFBQWEsT0FBYixDQUFxQixhQUFyQixDQUFSO0FBQ0QsT0FGRCxDQUVFLE9BQU8sQ0FBUCxFQUFVO0FBQ1Y7QUFDRDtBQUNELFdBQUssR0FBTCxHQUFXLE9BQU8sT0FBUCxHQUFpQiw4QkFBakIsR0FBa0QsS0FBSyxVQUF2RCxJQUFxRSxRQUFRLGtCQUFrQixLQUExQixHQUFrQyxFQUF2RyxDQUFYO0FBQ0EsYUFBTyxRQUFRLE9BQVIsQ0FBZ0IsSUFBaEIsQ0FBUDtBQUNEO0FBNURJLEdBQVA7QUE4REQsQ0EvREQ7O0FBaUVBLFFBQVEsS0FBUixHQUFnQixTQUFoQjtBQUNBLE9BQU8sT0FBUCxHQUFpQixPQUFqQjs7O0FDckVBOztBQUVBLE9BQU8sT0FBUCxHQUFpQjtBQUNmLFdBQVMsUUFBUSxjQUFSLENBRE07QUFFZixNQUFJLFFBQVEsU0FBUixDQUZXO0FBR2YsT0FBSyxRQUFRLFVBQVI7QUFIVSxDQUFqQjs7O0FDRkE7O0FBRUEsSUFBSSxVQUFVLFFBQVEscUJBQVIsQ0FBZDtBQUNBLElBQUksS0FBSyxTQUFTLEVBQVQsQ0FBWSxNQUFaLEVBQW9CO0FBQzNCLFNBQU87QUFDTCxnQkFBWSxTQUFTLFVBQVQsQ0FBb0IsSUFBcEIsRUFBMEIsUUFBMUIsRUFBb0MsR0FBcEMsRUFBeUMsZ0JBQXpDLEVBQTJEO0FBQ3JFLGFBQU8sSUFBSSxPQUFKLENBQVksVUFBVSxPQUFWLEVBQW1CLE1BQW5CLEVBQTJCO0FBQzVDO0FBQ0EsWUFBSSxNQUFNLElBQUksY0FBSixFQUFWOztBQUVBLFlBQUksUUFBUSxJQUFJLFFBQUosRUFBWjtBQUNBLGNBQU0sTUFBTixDQUFhLE1BQWIsRUFBcUIsUUFBckI7QUFDQSxjQUFNLE1BQU4sQ0FBYSxNQUFiLEVBQXFCLEtBQUssSUFBMUI7QUFDQSxjQUFNLE1BQU4sQ0FBYSxNQUFiLEVBQXFCLEtBQUssSUFBMUI7O0FBRUE7QUFDQSxZQUFJLE9BQUosR0FBYyxVQUFVLEdBQVYsRUFBZTtBQUMzQixjQUFJLFlBQUosR0FBbUIsSUFBbkI7QUFDQSxpQkFBTyxHQUFQO0FBQ0QsU0FIRDs7QUFLQSxZQUFJLE9BQUosR0FBYyxVQUFVLEdBQVYsRUFBZTtBQUMzQixpQkFBTyxHQUFQO0FBQ0QsU0FGRDs7QUFJQSxZQUFJLE1BQUosR0FBYSxZQUFZO0FBQ3ZCLGNBQUksSUFBSSxNQUFKLElBQWMsR0FBZCxJQUFxQixJQUFJLE1BQUosR0FBYSxHQUF0QyxFQUEyQztBQUN6QyxnQkFBSSxXQUFXLEtBQUssS0FBTCxDQUFXLElBQUksUUFBZixDQUFmOztBQUVBO0FBQ0EsZ0JBQUksTUFBTSxJQUFJLGNBQUosRUFBVjs7QUFFQSxnQkFBSSxPQUFPLGdCQUFQLEtBQTRCLFVBQWhDLEVBQTRDO0FBQzFDLGtCQUFJLE1BQUosQ0FBVyxVQUFYLEdBQXdCLGdCQUF4QjtBQUNEOztBQUVELHFCQUFTLElBQVQsQ0FBYyxRQUFkLEdBQXlCLFFBQXpCO0FBQ0EscUJBQVMsSUFBVCxDQUFjLEdBQWQsSUFBcUIsTUFBTSxRQUEzQjs7QUFFQSxnQkFBSSxLQUFLLElBQUksUUFBSixFQUFUO0FBQ0EsaUJBQUssSUFBSSxHQUFULElBQWdCLFNBQVMsSUFBekIsRUFBK0I7QUFDN0IsaUJBQUcsTUFBSCxDQUFVLEdBQVYsRUFBZSxTQUFTLElBQVQsQ0FBYyxHQUFkLENBQWY7QUFDRDtBQUNELGVBQUcsTUFBSCxDQUFVLE1BQVYsRUFBa0IsSUFBbEI7O0FBRUE7QUFDQSxnQkFBSSxPQUFKLEdBQWMsVUFBVSxHQUFWLEVBQWU7QUFDM0Isa0JBQUksWUFBSixHQUFtQixJQUFuQjtBQUNBLHFCQUFPLEdBQVA7QUFDRCxhQUhEOztBQUtBLGdCQUFJLE1BQUosR0FBYSxZQUFZO0FBQ3ZCLGtCQUFJLElBQUksTUFBSixJQUFjLEdBQWQsSUFBcUIsSUFBSSxNQUFKLEdBQWEsR0FBdEMsRUFBMkM7QUFDekMsd0JBQVE7QUFDTiwyQkFBUyxJQURIO0FBRU4sd0JBQU0sUUFGQTtBQUdOLDBCQUFRLFNBQVMsTUFIWDtBQUlOLHVCQUFLLFNBQVMsSUFBVCxDQUFjLEdBSmI7QUFLTix1QkFBSyxTQUFTLEdBQVQsR0FBZSxTQUFTLElBQVQsQ0FBYyxHQUw1QjtBQU1OLHVCQUFLLFNBQVMsSUFBVCxDQUFjLEdBTmI7QUFPTix3QkFBTSxLQUFLLElBUEw7QUFRTix3QkFBTSxLQUFLO0FBUkwsaUJBQVI7QUFVRCxlQVhELE1BV087QUFDTCx1QkFBTyxJQUFJLFFBQUosSUFBZ0IsdUJBQXZCO0FBQ0Q7QUFDRixhQWZEOztBQWlCQSxnQkFBSSxPQUFKLEdBQWMsVUFBVSxHQUFWLEVBQWU7QUFDM0IscUJBQU8sR0FBUDtBQUNELGFBRkQ7O0FBSUEsZ0JBQUksSUFBSixDQUFTLE1BQVQsRUFBaUIsU0FBUyxHQUExQjs7QUFFQSxnQkFBSSxJQUFKLENBQVMsRUFBVDtBQUNELFdBakRELE1BaURPO0FBQ0wsbUJBQU8sSUFBSSxRQUFKLElBQWdCLHFCQUF2QjtBQUNEO0FBQ0YsU0FyREQ7O0FBdURBLFlBQUksSUFBSixDQUFTLE1BQVQsRUFBaUIsT0FBTyxPQUFQLEdBQWlCLGFBQWxDOztBQUVBLFlBQUksZ0JBQUosQ0FBcUIsUUFBckIsRUFBK0Isa0JBQS9CO0FBQ0EsWUFBSSxnQkFBSixDQUFxQixjQUFyQixFQUFxQyxpQ0FBckM7QUFDQSxZQUFJLFFBQVEsS0FBWjtBQUNBLFlBQUk7QUFDRixrQkFBUSxhQUFhLE9BQWIsQ0FBcUIsYUFBckIsQ0FBUjtBQUNELFNBRkQsQ0FFRSxPQUFPLENBQVAsRUFBVTtBQUNWO0FBQ0Q7QUFDRCxZQUFJLEtBQUosRUFBVztBQUNULGNBQUksZ0JBQUosQ0FBcUIsYUFBckIsRUFBb0MsS0FBcEM7QUFDRDs7QUFFRCxZQUFJLElBQUosQ0FBUyxLQUFLLFNBQUwsQ0FBZTtBQUN0QixnQkFBTSxRQURnQjtBQUV0QixnQkFBTSxLQUFLLElBRlc7QUFHdEIsZ0JBQU0sS0FBSztBQUhXLFNBQWYsQ0FBVDtBQUtELE9BN0ZNLENBQVA7QUE4RkQsS0FoR0k7QUFpR0wsa0JBQWMsU0FBUyxZQUFULENBQXNCLElBQXRCLEVBQTRCO0FBQ3hDLFVBQUksS0FBSyxHQUFMLEtBQWEsYUFBakIsRUFBZ0M7QUFDOUIsZUFBTyxPQUFPLFdBQVAsQ0FBbUIsTUFBbkIsRUFBMkIsT0FBTyxPQUFQLEdBQWlCLHFCQUFqQixHQUF5QyxLQUFLLE1BQTlDLEdBQXVELE9BQXZELEdBQWlFLEtBQUssR0FBakcsRUFBc0csS0FBdEcsQ0FBUDtBQUNELE9BRkQsTUFFTztBQUNMLGVBQU8sUUFBUSxPQUFSLENBQWdCLElBQWhCLENBQVA7QUFDRDtBQUNGO0FBdkdJLEdBQVA7QUF5R0QsQ0ExR0Q7O0FBNEdBLEdBQUcsS0FBSCxHQUFXLElBQVg7QUFDQSxPQUFPLE9BQVAsR0FBaUIsRUFBakI7OztBQ2hIQTs7QUFFQSxJQUFJLFVBQVUsUUFBUSxxQkFBUixDQUFkO0FBQ0EsSUFBSSxNQUFNLFNBQVMsR0FBVCxDQUFhLE1BQWIsRUFBcUI7QUFDN0IsU0FBTztBQUNMLFdBQU8sS0FERjtBQUVMLFVBQU0sS0FGRDtBQUdMLGdCQUFZLFNBQVMsVUFBVCxDQUFvQixJQUFwQixFQUEwQixRQUExQixFQUFvQyxHQUFwQyxFQUF5QyxnQkFBekMsRUFBMkQsR0FBM0QsRUFBZ0U7QUFDMUUsYUFBTyxJQUFJLE9BQUosQ0FBWSxVQUFVLE9BQVYsRUFBbUIsTUFBbkIsRUFBMkI7QUFDNUMsWUFBSSxPQUFPO0FBQ1QsZUFBSyxHQURJO0FBRVQsZ0JBQU0sUUFGRztBQUdULGdCQUFNO0FBSEcsU0FBWDs7QUFNQTtBQUNBLFlBQUksTUFBTSxJQUFJLGNBQUosRUFBVjs7QUFFQSxZQUFJLE9BQU8sZ0JBQVAsS0FBNEIsVUFBaEMsRUFBNEM7QUFDMUMsY0FBSSxNQUFKLENBQVcsVUFBWCxHQUF3QixnQkFBeEI7QUFDRDs7QUFFRCxZQUFJLEtBQUssSUFBSSxRQUFKLEVBQVQ7QUFDQSxhQUFLLElBQUksR0FBVCxJQUFnQixJQUFoQixFQUFzQjtBQUNwQixhQUFHLE1BQUgsQ0FBVSxHQUFWLEVBQWUsS0FBSyxHQUFMLENBQWY7QUFDRDs7QUFFRCxZQUFJLE1BQUosR0FBYSxZQUFZO0FBQ3ZCLGNBQUksSUFBSSxNQUFKLElBQWMsR0FBZCxJQUFxQixJQUFJLE1BQUosR0FBYSxHQUF0QyxFQUEyQztBQUN6QztBQUNBLGdCQUFJLFdBQVcsRUFBZjtBQUNBLGdCQUFJO0FBQ0YseUJBQVcsT0FBTyxJQUFJLFFBQVgsS0FBd0IsUUFBeEIsR0FBbUMsS0FBSyxLQUFMLENBQVcsSUFBSSxRQUFmLENBQW5DLEdBQThELEVBQXpFO0FBQ0EseUJBQVcsWUFBWSxTQUFTLElBQXJCLEdBQTRCLFNBQVMsSUFBckMsR0FBNEMsRUFBdkQ7QUFDRCxhQUhELENBR0UsT0FBTyxHQUFQLEVBQVk7QUFDWix5QkFBVyxFQUFYO0FBQ0Q7O0FBRUQsb0JBQVE7QUFDTix1QkFBUyxLQURIO0FBRU4sb0JBQU0sUUFGQTtBQUdOLG1CQUFLLElBQUksV0FBSixHQUFrQixHQUFsQixHQUF3QixRQUh2QjtBQUlOLG9CQUFNLEtBQUssSUFKTDtBQUtOLG9CQUFNLEtBQUssSUFMTDtBQU1OLG9CQUFNO0FBTkEsYUFBUjtBQVFELFdBbEJELE1Ba0JPO0FBQ0wsbUJBQU8sSUFBSSxRQUFKLElBQWdCLHVCQUF2QjtBQUNEO0FBQ0YsU0F0QkQ7O0FBd0JBO0FBQ0EsWUFBSSxPQUFKLEdBQWMsWUFBWTtBQUN4QixpQkFBTyxHQUFQO0FBQ0QsU0FGRDs7QUFJQSxZQUFJLE9BQUosR0FBYyxZQUFZO0FBQ3hCLGlCQUFPLEdBQVA7QUFDRCxTQUZEOztBQUlBLFlBQUksSUFBSixDQUFTLE1BQVQsRUFBaUIsR0FBakI7QUFDQSxZQUFJLFFBQVEsYUFBYSxPQUFiLENBQXFCLGFBQXJCLENBQVo7QUFDQSxZQUFJLEtBQUosRUFBVztBQUNULGNBQUksZ0JBQUosQ0FBcUIsYUFBckIsRUFBb0MsS0FBcEM7QUFDRDtBQUNELFlBQUksSUFBSixDQUFTLEVBQVQ7QUFDRCxPQTFETSxDQUFQO0FBMkRELEtBL0RJO0FBZ0VMLGtCQUFjLFNBQVMsWUFBVCxDQUFzQixJQUF0QixFQUE0QjtBQUN4QztBQUNBLGFBQU8sUUFBUSxPQUFSLENBQWdCLElBQWhCLENBQVA7QUFDRDtBQW5FSSxHQUFQO0FBcUVELENBdEVEOztBQXdFQSxJQUFJLEtBQUosR0FBWSxLQUFaO0FBQ0EsT0FBTyxPQUFQLEdBQWlCLEdBQWpCOzs7QUM1RUE7Ozs7QUFFQSxJQUFJLFVBQVUsT0FBTyxNQUFQLEtBQWtCLFVBQWxCLElBQWdDLFNBQU8sT0FBTyxRQUFkLE1BQTJCLFFBQTNELEdBQXNFLFVBQVUsR0FBVixFQUFlO0FBQUUsZ0JBQWMsR0FBZCwwQ0FBYyxHQUFkO0FBQW9CLENBQTNHLEdBQThHLFVBQVUsR0FBVixFQUFlO0FBQUUsU0FBTyxPQUFPLE9BQU8sTUFBUCxLQUFrQixVQUF6QixJQUF1QyxJQUFJLFdBQUosS0FBb0IsTUFBM0QsSUFBcUUsUUFBUSxPQUFPLFNBQXBGLEdBQWdHLFFBQWhHLFVBQWtILEdBQWxILDBDQUFrSCxHQUFsSCxDQUFQO0FBQStILENBQTVROztBQUVBLElBQUksZUFBZSxRQUFRLGVBQVIsQ0FBbkI7O0FBRUEsSUFBSSxnQkFBZ0IsdUJBQXVCLFlBQXZCLENBQXBCOztBQUVBLFNBQVMsc0JBQVQsQ0FBZ0MsR0FBaEMsRUFBcUM7QUFBRSxTQUFPLE9BQU8sSUFBSSxVQUFYLEdBQXdCLEdBQXhCLEdBQThCLEVBQUUsU0FBUyxHQUFYLEVBQXJDO0FBQXdEOztBQUUvRixJQUFJLE9BQU8sUUFBUSxZQUFSLENBQVg7O0FBRUEsT0FBTyxPQUFQLEdBQWlCO0FBQ2Y7Ozs7Ozs7OztBQVNBLHFCQUFtQixTQUFTLGlCQUFULENBQTJCLFNBQTNCLEVBQXNDO0FBQ3ZELFdBQU8sVUFBVSxPQUFWLElBQXFCLE1BQU0sT0FBTixDQUFjLFVBQVUsT0FBeEIsQ0FBckIsSUFBeUQsVUFBVSxJQUFWLElBQWtCLE1BQU0sT0FBTixDQUFjLFVBQVUsSUFBeEIsQ0FBM0UsSUFBNEcsVUFBVSxVQUFWLElBQXdCLE1BQU0sT0FBTixDQUFjLFVBQVUsVUFBeEIsQ0FBcEksR0FBMEssSUFBMUssR0FBaUwsS0FBeEw7QUFDRCxHQVpjOztBQWNmOzs7Ozs7Ozs7Ozs7QUFZQSxpQkFBZSxTQUFTLGFBQVQsQ0FBdUIsVUFBdkIsRUFBbUMsRUFBbkMsRUFBdUMsVUFBdkMsRUFBbUQsSUFBbkQsRUFBeUQ7QUFDdEUsUUFBSSxDQUFDLFVBQUwsRUFBaUI7QUFDakIsV0FBTyxRQUFRLEVBQWY7QUFDQSxlQUFXLE9BQVgsQ0FBbUIsVUFBVSxTQUFWLEVBQXFCO0FBQ3RDLFVBQUksYUFBYSxVQUFVLE9BQVYsSUFBcUIsTUFBTSxPQUFOLENBQWMsVUFBVSxPQUF4QixDQUF0QztBQUNBLFVBQUksVUFBVSxVQUFVLElBQVYsSUFBa0IsTUFBTSxPQUFOLENBQWMsVUFBVSxJQUF4QixDQUFoQztBQUNBLFVBQUksV0FBVyxVQUFVLFVBQVYsSUFBd0IsTUFBTSxPQUFOLENBQWMsVUFBVSxVQUF4QixDQUF2QztBQUNBLFVBQUksWUFBWSxLQUFoQjtBQUNBLFVBQUksVUFBVSxVQUFVLEdBQVYsR0FBZ0IsT0FBTyxPQUFPLEdBQVAsR0FBYSxVQUFVLEdBQTlCLEdBQW9DLFVBQVUsR0FBOUQsR0FBb0UsRUFBbEY7O0FBRUEsVUFBSSxjQUFjLFVBQVUsSUFBeEIsSUFBZ0MsQ0FBQyxVQUFELElBQWUsQ0FBQyxPQUFoQixJQUEyQixDQUFDLFFBQWhFLEVBQTBFO0FBQ3hFLG9CQUFZLEdBQUcsU0FBSCxFQUFjLE9BQWQsQ0FBWjtBQUNEOztBQUVELFVBQUksVUFBVSxTQUFTLE9BQVQsR0FBbUI7QUFDL0IsWUFBSSxVQUFVLEdBQVYsS0FBa0IsVUFBVSxJQUFWLEtBQW1CLFVBQW5CLElBQWlDLFVBQVUsSUFBVixLQUFtQixXQUF0RSxDQUFKLEVBQXdGO0FBQ3RGLGlCQUFPLE9BQVA7QUFDRDtBQUNELGVBQU8sSUFBUDtBQUNELE9BTEQ7O0FBT0EsVUFBSSxDQUFDLFNBQUwsRUFBZ0I7QUFDZCxZQUFJLFVBQUosRUFBZ0I7QUFDZCxvQkFBVSxPQUFWLENBQWtCLE9BQWxCLENBQTBCLFVBQVUsTUFBVixFQUFrQjtBQUMxQywwQkFBYyxPQUFPLFVBQXJCLEVBQWlDLEVBQWpDLEVBQXFDLFVBQXJDLEVBQWlELFNBQWpEO0FBQ0QsV0FGRDtBQUdELFNBSkQsTUFJTyxJQUFJLE9BQUosRUFBYTtBQUNsQixhQUFHLE1BQUgsQ0FBVSxLQUFWLENBQWdCLEVBQWhCLEVBQW9CLFVBQVUsSUFBOUIsRUFBb0MsT0FBcEMsQ0FBNEMsVUFBVSxHQUFWLEVBQWU7QUFDekQsMEJBQWMsSUFBSSxVQUFsQixFQUE4QixFQUE5QixFQUFrQyxVQUFsQyxFQUE4QyxTQUE5QztBQUNELFdBRkQ7QUFHRCxTQUpNLE1BSUEsSUFBSSxRQUFKLEVBQWM7QUFDbkIsd0JBQWMsVUFBVSxVQUF4QixFQUFvQyxFQUFwQyxFQUF3QyxVQUF4QyxFQUFvRCxTQUFwRDtBQUNEO0FBQ0Y7QUFDRixLQS9CRDtBQWdDRCxHQTdEYzs7QUErRGY7Ozs7Ozs7Ozs7O0FBV0EsZ0JBQWMsU0FBUyxZQUFULENBQXNCLFVBQXRCLEVBQWtDLEdBQWxDLEVBQXVDO0FBQ25ELFFBQUksTUFBSjtBQUNBLFdBQU8sT0FBUCxDQUFlLGFBQWYsQ0FBNkIsVUFBN0IsRUFBeUMsVUFBVSxTQUFWLEVBQXFCO0FBQzVELFVBQUksVUFBVSxHQUFWLEtBQWtCLEdBQXRCLEVBQTJCO0FBQ3pCLGlCQUFTLFNBQVQ7QUFDRDtBQUNGLEtBSkQ7QUFLQSxXQUFPLE1BQVA7QUFDRCxHQWxGYzs7QUFvRmY7Ozs7Ozs7Ozs7O0FBV0EscUJBQW1CLFNBQVMsaUJBQVQsQ0FBMkIsVUFBM0IsRUFBdUMsVUFBdkMsRUFBbUQ7QUFDcEUsUUFBSSxZQUFZLEVBQWhCO0FBQ0EsV0FBTyxPQUFQLENBQWUsYUFBZixDQUE2QixVQUE3QixFQUF5QyxVQUFVLFNBQVYsRUFBcUIsSUFBckIsRUFBMkI7QUFDbEUsZ0JBQVUsSUFBVixJQUFrQixTQUFsQjtBQUNELEtBRkQsRUFFRyxVQUZIO0FBR0EsV0FBTyxTQUFQO0FBQ0QsR0FyR2M7O0FBdUdmOzs7Ozs7O0FBT0EsZ0JBQWMsU0FBUyxZQUFULENBQXNCLFNBQXRCLEVBQWlDO0FBQzdDLFdBQU8sVUFBVSxjQUFWLENBQXlCLG1CQUF6QixLQUFpRCxVQUFVLGlCQUEzRCxJQUFnRixVQUFVLGNBQVYsQ0FBeUIsYUFBekIsS0FBMkMsVUFBVSxXQUFyRCxJQUFvRSxVQUFVLFdBQVYsQ0FBc0IsSUFBMUssSUFBa0wsVUFBVSxjQUFWLENBQXlCLGFBQXpCLEtBQTJDLFVBQVUsV0FBckQsSUFBb0UsVUFBVSxXQUFWLENBQXNCLElBQW5SO0FBQ0QsR0FoSGM7O0FBa0hmOzs7Ozs7Ozs7Ozs7QUFZQSxrQkFBZ0IsU0FBUyxjQUFULENBQXdCLFNBQXhCLEVBQW1DLEdBQW5DLEVBQXdDLElBQXhDLEVBQThDO0FBQzVELFFBQUksVUFBVSxjQUFWLENBQXlCLG1CQUF6QixLQUFpRCxVQUFVLGlCQUEvRCxFQUFrRjtBQUNoRixVQUFJO0FBQ0YsWUFBSSxTQUFTLGdDQUFiO0FBQ0Esa0JBQVUsVUFBVSxpQkFBVixDQUE0QixRQUE1QixFQUFWO0FBQ0Esa0JBQVUscUJBQVY7QUFDQSxZQUFJLFNBQVMsS0FBSyxNQUFMLENBQWI7QUFDQSxlQUFPLE9BQU8sUUFBUCxPQUFzQixNQUE3QjtBQUNELE9BTkQsQ0FNRSxPQUFPLENBQVAsRUFBVTtBQUNWLGdCQUFRLElBQVIsQ0FBYSx1RUFBdUUsVUFBVSxHQUE5RixFQUFtRyxDQUFuRztBQUNBLGVBQU8sSUFBUDtBQUNEO0FBQ0YsS0FYRCxNQVdPLElBQUksVUFBVSxjQUFWLENBQXlCLGFBQXpCLEtBQTJDLFVBQVUsV0FBckQsSUFBb0UsVUFBVSxXQUFWLENBQXNCLElBQTlGLEVBQW9HO0FBQ3pHLFVBQUksT0FBTyxVQUFVLFdBQXJCO0FBQ0EsVUFBSSxRQUFRLElBQVo7QUFDQSxVQUFJLEdBQUosRUFBUztBQUNQLGdCQUFRLEtBQUssUUFBTCxDQUFjLEVBQUUsTUFBTSxHQUFSLEVBQWQsRUFBNkIsS0FBSyxJQUFsQyxDQUFSO0FBQ0Q7QUFDRCxVQUFJLFNBQVMsVUFBVSxJQUFWLElBQWtCLE9BQU8sS0FBUCxLQUFpQixXQUE1QyxDQUFKLEVBQThEO0FBQzVELGdCQUFRLEtBQUssUUFBTCxDQUFjLEVBQUUsTUFBTSxJQUFSLEVBQWQsRUFBOEIsS0FBSyxJQUFuQyxDQUFSO0FBQ0Q7QUFDRDtBQUNBLFVBQUksVUFBVSxJQUFWLElBQWtCLE9BQU8sS0FBUCxLQUFpQixXQUF2QyxFQUFvRDtBQUNsRCxlQUFPLEtBQVA7QUFDRDtBQUNEO0FBQ0EsVUFBSSxDQUFDLE9BQU8sS0FBUCxLQUFpQixXQUFqQixHQUErQixXQUEvQixHQUE2QyxRQUFRLEtBQVIsQ0FBOUMsTUFBa0UsUUFBbEUsSUFBOEUsTUFBTSxjQUFOLENBQXFCLEtBQUssRUFBMUIsQ0FBbEYsRUFBaUg7QUFDL0csZUFBTyxNQUFNLEtBQUssRUFBWCxFQUFlLFFBQWYsT0FBOEIsS0FBSyxJQUFMLENBQVUsUUFBVixFQUFyQztBQUNEO0FBQ0Q7QUFDQSxVQUFJLGlCQUFpQixLQUFqQixJQUEwQixNQUFNLE9BQU4sQ0FBYyxLQUFLLEVBQW5CLE1BQTJCLENBQUMsQ0FBMUQsRUFBNkQ7QUFDM0QsZUFBTyxLQUFLLElBQUwsQ0FBVSxRQUFWLE9BQXlCLE1BQWhDO0FBQ0Q7O0FBRUQsYUFBTyxNQUFNLFFBQU4sT0FBcUIsS0FBSyxFQUFMLENBQVEsUUFBUixFQUFyQixNQUE2QyxLQUFLLElBQUwsQ0FBVSxRQUFWLE9BQXlCLE1BQXRFLENBQVA7QUFDRCxLQXZCTSxNQXVCQSxJQUFJLFVBQVUsY0FBVixDQUF5QixhQUF6QixLQUEyQyxVQUFVLFdBQXJELElBQW9FLFVBQVUsV0FBVixDQUFzQixJQUE5RixFQUFvRztBQUN6RyxhQUFPLGNBQWMsT0FBZCxDQUFzQixLQUF0QixDQUE0QixVQUFVLFdBQVYsQ0FBc0IsSUFBbEQsRUFBd0Q7QUFDN0QsY0FBTSxJQUR1RDtBQUU3RCxhQUFLO0FBRndELE9BQXhELENBQVA7QUFJRDs7QUFFRDtBQUNBLFdBQU8sSUFBUDtBQUNELEdBMUtjOztBQTRLZjs7Ozs7Ozs7QUFRQSxZQUFVLFNBQVMsUUFBVCxDQUFrQixVQUFsQixFQUE4QixHQUE5QixFQUFtQztBQUMzQyxRQUFJLE9BQU8sV0FBVyxJQUFYLElBQW1CLEVBQTlCOztBQUVBLFFBQUksU0FBUyxTQUFTLE1BQVQsQ0FBZ0IsSUFBaEIsRUFBc0I7QUFDakMsVUFBSSxDQUFKO0FBQ0EsVUFBSSxLQUFKOztBQUVBLFVBQUksQ0FBQyxJQUFMLEVBQVc7QUFDVCxlQUFPLElBQVA7QUFDRDs7QUFFRCxVQUFJLENBQUMsT0FBTyxJQUFQLEtBQWdCLFdBQWhCLEdBQThCLFdBQTlCLEdBQTRDLFFBQVEsSUFBUixDQUE3QyxNQUFnRSxRQUFoRSxJQUE0RSxFQUFFLGdCQUFnQixLQUFsQixDQUFoRixFQUEwRztBQUN4RyxZQUFJLEtBQUssY0FBTCxDQUFvQixHQUFwQixDQUFKLEVBQThCO0FBQzVCLGlCQUFPLEtBQUssR0FBTCxDQUFQO0FBQ0Q7O0FBRUQsWUFBSSxPQUFPLE9BQU8sSUFBUCxDQUFZLElBQVosQ0FBWDtBQUNBLGFBQUssSUFBSSxDQUFULEVBQVksSUFBSSxLQUFLLE1BQXJCLEVBQTZCLEdBQTdCLEVBQWtDO0FBQ2hDLGNBQUksUUFBUSxLQUFLLEtBQUssQ0FBTCxDQUFMLENBQVIsTUFBMkIsUUFBL0IsRUFBeUM7QUFDdkMsb0JBQVEsT0FBTyxLQUFLLEtBQUssQ0FBTCxDQUFMLENBQVAsQ0FBUjtBQUNEOztBQUVELGNBQUksS0FBSixFQUFXO0FBQ1QsbUJBQU8sS0FBUDtBQUNEO0FBQ0Y7QUFDRjtBQUNGLEtBeEJEOztBQTBCQSxXQUFPLE9BQU8sSUFBUCxDQUFQO0FBQ0QsR0FsTmM7O0FBb05mOzs7Ozs7O0FBT0EsZUFBYSxTQUFTLFdBQVQsQ0FBcUIsTUFBckIsRUFBNkIsSUFBN0IsRUFBbUM7QUFDOUMsV0FBTyxPQUFPLE9BQVAsQ0FBZSx5QkFBZixFQUEwQyxVQUFVLEtBQVYsRUFBaUIsS0FBakIsRUFBd0I7QUFDdkUsYUFBTyxLQUFLLElBQUwsRUFBVyxLQUFYLENBQVA7QUFDRCxLQUZNLENBQVA7QUFHRDtBQS9OYyxDQUFqQjs7O0FDWkE7O0FBQ0EsT0FBTyxPQUFQLEdBQWlCLFFBQVEsZUFBUixDQUFqQjs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2poQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDemxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Z0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiXCJ1c2Ugc3RyaWN0XCI7XG5yZXF1aXJlKCcuL3BvbHlmaWxscy9wb2x5ZmlsbHMnKTtcclxuXHJcblxyXG52YXIgYXBwID0gYW5ndWxhci5tb2R1bGUoJ2Zvcm1pbycsIFtcclxuICAnbmdTYW5pdGl6ZScsXHJcbiAgJ3VpLmJvb3RzdHJhcCcsXHJcbiAgJ3VpLmJvb3RzdHJhcC5kYXRldGltZXBpY2tlcicsXHJcbiAgJ3VpLnNlbGVjdCcsXHJcbiAgJ3VpLm1hc2snLFxyXG4gICdhbmd1bGFyTW9tZW50JyxcclxuICAnbmdEaWFsb2cnLFxyXG4gICduZ0ZpbGVVcGxvYWQnLFxyXG4gICduZ0ZpbGVTYXZlcidcclxuXSk7XHJcblxyXG4vKipcclxuICogQ3JlYXRlIHRoZSBmb3JtaW8gcHJvdmlkZXJzLlxyXG4gKi9cclxuYXBwLnByb3ZpZGVyKCdGb3JtaW8nLCByZXF1aXJlKCcuL3Byb3ZpZGVycy9Gb3JtaW8nKSk7XHJcblxyXG4vKipcclxuICogUHJvdmlkZXMgYSB3YXkgdG8gcmVnaXN0ZXIgdGhlIEZvcm1pbyBzY29wZS5cclxuICovXHJcbmFwcC5mYWN0b3J5KCdGb3JtaW9TY29wZScsIHJlcXVpcmUoJy4vZmFjdG9yaWVzL0Zvcm1pb1Njb3BlJykpO1xyXG5cclxuYXBwLmZhY3RvcnkoJ0Zvcm1pb1V0aWxzJywgcmVxdWlyZSgnLi9mYWN0b3JpZXMvRm9ybWlvVXRpbHMnKSk7XHJcblxyXG5hcHAuZmFjdG9yeSgnZm9ybWlvSW50ZXJjZXB0b3InLCByZXF1aXJlKCcuL2ZhY3Rvcmllcy9mb3JtaW9JbnRlcmNlcHRvcicpKTtcclxuXHJcbmFwcC5mYWN0b3J5KCdmb3JtaW9UYWJsZVZpZXcnLCByZXF1aXJlKCcuL2ZhY3Rvcmllcy9mb3JtaW9UYWJsZVZpZXcnKSk7XHJcblxyXG5hcHAuZGlyZWN0aXZlKCdmb3JtaW8nLCByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvZm9ybWlvJykpO1xyXG5cclxuYXBwLmRpcmVjdGl2ZSgnZm9ybWlvRGVsZXRlJywgcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2Zvcm1pb0RlbGV0ZScpKTtcclxuXHJcbmFwcC5kaXJlY3RpdmUoJ2Zvcm1pb0Vycm9ycycsIHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9mb3JtaW9FcnJvcnMnKSk7XHJcblxyXG5hcHAuZGlyZWN0aXZlKCdjdXN0b21WYWxpZGF0b3InLCByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvY3VzdG9tVmFsaWRhdG9yJykpO1xyXG5cclxuYXBwLmRpcmVjdGl2ZSgnZm9ybWlvU3VibWlzc2lvbnMnLCByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvZm9ybWlvU3VibWlzc2lvbnMnKSk7XHJcblxyXG5hcHAuZGlyZWN0aXZlKCdmb3JtaW9TdWJtaXNzaW9uJywgcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2Zvcm1pb1N1Ym1pc3Npb24nKSk7XHJcblxyXG5hcHAuZGlyZWN0aXZlKCdmb3JtaW9Db21wb25lbnQnLCByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvZm9ybWlvQ29tcG9uZW50JykpO1xyXG5cclxuYXBwLmRpcmVjdGl2ZSgnZm9ybWlvQ29tcG9uZW50VmlldycsIHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9mb3JtaW9Db21wb25lbnRWaWV3JykpO1xyXG5cclxuYXBwLmRpcmVjdGl2ZSgnZm9ybWlvRWxlbWVudCcsIHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9mb3JtaW9FbGVtZW50JykpO1xyXG5cclxuYXBwLmRpcmVjdGl2ZSgnZm9ybWlvV2l6YXJkJywgcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2Zvcm1pb1dpemFyZCcpKTtcclxuXHJcbmFwcC5kaXJlY3RpdmUoJ2Zvcm1pb0JpbmRIdG1sJywgcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2Zvcm1pb0JpbmRIdG1sLmpzJykpO1xyXG5cclxuLyoqXHJcbiAqIEZpbHRlciB0byBmbGF0dGVuIGZvcm0gY29tcG9uZW50cy5cclxuICovXHJcbmFwcC5maWx0ZXIoJ2ZsYXR0ZW5Db21wb25lbnRzJywgcmVxdWlyZSgnLi9maWx0ZXJzL2ZsYXR0ZW5Db21wb25lbnRzJykpO1xyXG5hcHAuZmlsdGVyKCd0YWJsZUNvbXBvbmVudHMnLCByZXF1aXJlKCcuL2ZpbHRlcnMvdGFibGVDb21wb25lbnRzJykpO1xyXG5hcHAuZmlsdGVyKCd0YWJsZVZpZXcnLCByZXF1aXJlKCcuL2ZpbHRlcnMvdGFibGVWaWV3JykpO1xyXG5hcHAuZmlsdGVyKCd0YWJsZUZpZWxkVmlldycsIHJlcXVpcmUoJy4vZmlsdGVycy90YWJsZUZpZWxkVmlldycpKTtcclxuYXBwLmZpbHRlcignc2FmZWh0bWwnLCByZXF1aXJlKCcuL2ZpbHRlcnMvc2FmZWh0bWwnKSk7XHJcbmFwcC5maWx0ZXIoJ2Zvcm1pb1RyYW5zbGF0ZScsIHJlcXVpcmUoJy4vZmlsdGVycy90cmFuc2xhdGUnKSk7XHJcbmFwcC5maWx0ZXIoJ3RydXN0QXNSZXNvdXJjZVVybCcsIHJlcXVpcmUoJy4vZmlsdGVycy90cnVzdHVybCcpKTtcclxuYXBwLmNvbmZpZyhbXHJcbiAgJyRodHRwUHJvdmlkZXInLFxyXG4gICckaW5qZWN0b3InLFxyXG4gIGZ1bmN0aW9uKFxyXG4gICAgJGh0dHBQcm92aWRlcixcclxuICAgICRpbmplY3RvclxyXG4gICkge1xyXG4gICAgaWYgKCEkaHR0cFByb3ZpZGVyLmRlZmF1bHRzLmhlYWRlcnMuZ2V0KSB7XHJcbiAgICAgICRodHRwUHJvdmlkZXIuZGVmYXVsdHMuaGVhZGVycy5nZXQgPSB7fTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBNYWtlIHN1cmUgdGhhdCBuZ0FuaW1hdGUgZG9lc24ndCBtZXNzIHVwIGxvYWRlci5cclxuICAgIHRyeSB7XHJcbiAgICAgICRpbmplY3Rvci5nZXQoJyRhbmltYXRlUHJvdmlkZXInKS5jbGFzc05hbWVGaWx0ZXIoL14oKD8hKGZhLXNwaW5uZXJ8Z2x5cGhpY29uLXNwaW4pKS4pKiQvKTtcclxuICAgIH1cclxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWVtcHR5ICovXHJcbiAgICBjYXRjaCAoZXJyKSB7fVxyXG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1lbXB0eSAqL1xyXG5cclxuICAgIC8vIERpc2FibGUgSUUgY2FjaGluZyBmb3IgR0VUIHJlcXVlc3RzLlxyXG4gICAgJGh0dHBQcm92aWRlci5kZWZhdWx0cy5oZWFkZXJzLmdldFsnQ2FjaGUtQ29udHJvbCddID0gJ25vLWNhY2hlJztcclxuICAgICRodHRwUHJvdmlkZXIuZGVmYXVsdHMuaGVhZGVycy5nZXQuUHJhZ21hID0gJ25vLWNhY2hlJztcclxuICAgICRodHRwUHJvdmlkZXIuaW50ZXJjZXB0b3JzLnB1c2goJ2Zvcm1pb0ludGVyY2VwdG9yJyk7XHJcbiAgfVxyXG5dKTtcclxuXHJcbmFwcC5ydW4oW1xyXG4gICckdGVtcGxhdGVDYWNoZScsXHJcbiAgJyRyb290U2NvcGUnLFxyXG4gICckd2luZG93JyxcclxuICBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSwgJHJvb3RTY29wZSwgJHdpbmRvdykge1xyXG4gICAgJHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgdmFyIGV2ZW50RGF0YSA9IG51bGw7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgZXZlbnREYXRhID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcclxuICAgICAgfVxyXG4gICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgZXZlbnREYXRhID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoZXZlbnREYXRhICYmIGV2ZW50RGF0YS5uYW1lKSB7XHJcbiAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdpZnJhbWUtJyArIGV2ZW50RGF0YS5uYW1lLCBldmVudERhdGEuZGF0YSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFRoZSB0ZW1wbGF0ZSBmb3IgdGhlIGZvcm1pbyBmb3Jtcy5cclxuICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvLmh0bWwnLFxyXG4gICAgICBcIjxkaXY+XFxyXFxuICA8aSBzdHlsZT1cXFwiZm9udC1zaXplOiAyZW07XFxcIiBuZy1pZj1cXFwiZm9ybUxvYWRpbmdcXFwiIG5nLWNsYXNzPVxcXCJ7J2Zvcm1pby1oaWRkZW4nOiAhZm9ybUxvYWRpbmd9XFxcIiBjbGFzcz1cXFwiZm9ybWlvLWxvYWRpbmcgZ2x5cGhpY29uIGdseXBoaWNvbi1yZWZyZXNoIGdseXBoaWNvbi1zcGluXFxcIj48L2k+XFxyXFxuICA8Zm9ybWlvLXdpemFyZCBuZy1pZj1cXFwiZm9ybS5kaXNwbGF5ID09PSAnd2l6YXJkJ1xcXCIgc3JjPVxcXCJzcmNcXFwiIGZvcm09XFxcImZvcm1cXFwiIHN1Ym1pc3Npb249XFxcInN1Ym1pc3Npb25cXFwiIGZvcm0tYWN0aW9uPVxcXCJmb3JtQWN0aW9uXFxcIiByZWFkLW9ubHk9XFxcInJlYWRPbmx5XFxcIiBoaWRlLWNvbXBvbmVudHM9XFxcImhpZGVDb21wb25lbnRzXFxcIiBkaXNhYmxlLWNvbXBvbmVudHM9XFxcImRpc2FibGVDb21wb25lbnRzXFxcIiBmb3JtaW8tb3B0aW9ucz1cXFwiZm9ybWlvT3B0aW9uc1xcXCIgc3RvcmFnZT1cXFwiZm9ybS5uYW1lXFxcIj48L2Zvcm1pby13aXphcmQ+XFxyXFxuICA8ZGl2IG5nLWlmPVxcXCJmb3JtLmRpc3BsYXkgPT09ICdwZGYnICYmIGZvcm0uc2V0dGluZ3MucGRmXFxcIiBzdHlsZT1cXFwicG9zaXRpb246cmVsYXRpdmU7XFxcIj5cXHJcXG4gICAgPHNwYW4gc3R5bGU9XFxcInBvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjEwcHg7dG9wOjEwcHg7Y3Vyc29yOnBvaW50ZXI7XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IG5vLWRpc2FibGVcXFwiIG5nLWNsaWNrPVxcXCJ6b29tSW4oKVxcXCI+PHNwYW5uIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLXpvb20taW5cXFwiPjwvc3Bhbm4+PC9zcGFuPlxcclxcbiAgICA8c3BhbiBzdHlsZT1cXFwicG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MTBweDt0b3A6NjBweDtjdXJzb3I6cG9pbnRlcjtcXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHQgbm8tZGlzYWJsZVxcXCIgbmctY2xpY2s9XFxcInpvb21PdXQoKVxcXCI+PHNwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tem9vbS1vdXRcXFwiPjwvc3Bhbj48L3NwYW4+XFxyXFxuICAgIDxhIG5nLWlmPVxcXCJkb3dubG9hZFVybFxcXCIgc3R5bGU9XFxcInBvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjEwcHg7dG9wOjExMHB4O2N1cnNvcjpwb2ludGVyO1xcXCIgY2xhc3M9XFxcImJ0biBidG4tcHJpbWFyeSBuby1kaXNhYmxlXFxcIiBocmVmPVxcXCJ7eyBkb3dubG9hZFVybCB8IHRydXN0QXNSZXNvdXJjZVVybCB9fVxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPjxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNsb3VkLWRvd25sb2FkXFxcIj48L3NwYW4+PC9hPlxcclxcbiAgICA8aWZyYW1lIHNyYz1cXFwie3sgZ2V0SWZyYW1lU3JjKGZvcm0uc2V0dGluZ3MucGRmKSB8IHRydXN0QXNSZXNvdXJjZVVybCB9fVxcXCIgc2VhbWxlc3MgY2xhc3M9XFxcImZvcm1pby1pZnJhbWVcXFwiPjwvaWZyYW1lPlxcclxcbiAgICA8YnV0dG9uIG5nLWlmPVxcXCIhcmVhZE9ubHkgJiYgIWZvcm0uYnVpbGRlclxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1wcmltYXJ5XFxcIiBuZy1jbGljaz1cXFwic3VibWl0SUZyYW1lRm9ybSgpXFxcIj5TdWJtaXQ8L2J1dHRvbj5cXHJcXG4gIDwvZGl2PlxcclxcbiAgPGZvcm0gbmctaWY9XFxcIiFmb3JtLmRpc3BsYXkgfHwgKGZvcm0uZGlzcGxheSA9PT0gJ2Zvcm0nKVxcXCIgcm9sZT1cXFwiZm9ybVxcXCIgbmFtZT1cXFwiZm9ybWlvRm9ybVxcXCIgbmctc3VibWl0PVxcXCJvblN1Ym1pdChmb3JtaW9Gb3JtKVxcXCIgbm92YWxpZGF0ZT5cXHJcXG4gICAgPGRpdiBuZy1yZXBlYXQ9XFxcImFsZXJ0IGluIGZvcm1pb0FsZXJ0cyB0cmFjayBieSAkaW5kZXhcXFwiIGNsYXNzPVxcXCJhbGVydCBhbGVydC17eyBhbGVydC50eXBlIH19XFxcIiByb2xlPVxcXCJhbGVydFxcXCIgbmctaWY9XFxcIjo6IWJ1aWxkZXJcXFwiPlxcclxcbiAgICAgIHt7IGFsZXJ0Lm1lc3NhZ2UgfCBmb3JtaW9UcmFuc2xhdGU6bnVsbDpidWlsZGVyIH19XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8IS0tIERPIE5PVCBQVVQgXFxcInRyYWNrIGJ5ICRpbmRleFxcXCIgSEVSRSBTSU5DRSBEWU5BTUlDQUxMWSBBRERJTkcvUkVNT1ZJTkcgQ09NUE9ORU5UUyBXSUxMIEJSRUFLIC0tPlxcclxcbiAgICA8Zm9ybWlvLWNvbXBvbmVudFxcclxcbiAgICAgIG5nLXJlcGVhdD1cXFwiY29tcG9uZW50IGluIGZvcm0uY29tcG9uZW50cyB0cmFjayBieSAkaW5kZXhcXFwiXFxyXFxuICAgICAgY29tcG9uZW50PVxcXCJjb21wb25lbnRcXFwiXFxyXFxuICAgICAgbmctaWY9XFxcImJ1aWxkZXIgPyAnOjp0cnVlJyA6IGlzVmlzaWJsZShjb21wb25lbnQpXFxcIlxcclxcbiAgICAgIGRhdGE9XFxcInN1Ym1pc3Npb24uZGF0YVxcXCJcXHJcXG4gICAgICBmb3JtaW8tZm9ybT1cXFwiZm9ybWlvRm9ybVxcXCJcXHJcXG4gICAgICBmb3JtaW89XFxcImZvcm1pb1xcXCJcXHJcXG4gICAgICBzdWJtaXNzaW9uPVxcXCJzdWJtaXNzaW9uXFxcIlxcclxcbiAgICAgIGhpZGUtY29tcG9uZW50cz1cXFwiaGlkZUNvbXBvbmVudHNcXFwiXFxyXFxuICAgICAgcmVhZC1vbmx5PVxcXCJpc0Rpc2FibGVkKGNvbXBvbmVudCwgc3VibWlzc2lvbi5kYXRhKVxcXCJcXHJcXG4gICAgICBidWlsZGVyPVxcXCJidWlsZGVyXFxcIlxcclxcbiAgICA+PC9mb3JtaW8tY29tcG9uZW50PlxcclxcbiAgPC9mb3JtPlxcclxcbjwvZGl2PlxcclxcblwiXHJcbiAgICApO1xyXG5cclxuICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvLXdpemFyZC5odG1sJyxcclxuICAgICAgXCI8ZGl2IGNsYXNzPVxcXCJmb3JtaW8td2l6YXJkLXdyYXBwZXJcXFwiPlxcclxcbiAgPGRpdiBjbGFzcz1cXFwicm93IGJzLXdpemFyZFxcXCIgc3R5bGU9XFxcImJvcmRlci1ib3R0b206MDtcXFwiIG5nLWNsYXNzPVxcXCJ7aGFzVGl0bGVzOiBoYXNUaXRsZXN9XFxcIj5cXHJcXG4gICAgPGRpdiBuZy1jbGFzcz1cXFwie2Rpc2FibGVkOiAoJGluZGV4ID4gY3VycmVudFBhZ2UpICYmICFmb3JtaW9PcHRpb25zLndpemFyZEZyZWVOYXZpZ2F0aW9uLCBhY3RpdmU6ICgkaW5kZXggPT0gY3VycmVudFBhZ2UpLCBjb21wbGV0ZTogKCRpbmRleCA8IGN1cnJlbnRQYWdlKSwgbm9UaXRsZTogIXBhZ2UudGl0bGV9XFxcIiBjbGFzcz1cXFwie3sgY29sY2xhc3MgfX0gYnMtd2l6YXJkLXN0ZXBcXFwiIG5nLXJlcGVhdD1cXFwicGFnZSBpbiBwYWdlcyB0cmFjayBieSAkaW5kZXhcXFwiPlxcclxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImJzLXdpemFyZC1zdGVwbnVtLXdyYXBwZXJcXFwiPlxcclxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidGV4dC1jZW50ZXIgYnMtd2l6YXJkLXN0ZXBudW1cXFwiIG5nLWlmPVxcXCJwYWdlLnRpdGxlXFxcIj57eyBwYWdlLnRpdGxlIH19PC9kaXY+XFxyXFxuICAgICAgPC9kaXY+XFxyXFxuICAgICAgPGRpdiBjbGFzcz1cXFwicHJvZ3Jlc3NcXFwiPjxkaXYgY2xhc3M9XFxcInByb2dyZXNzLWJhciBwcm9ncmVzcy1iYXItcHJpbWFyeVxcXCI+PC9kaXY+PC9kaXY+XFxyXFxuICAgICAgPGEgbmctY2xpY2s9XFxcImdvdG8oJGluZGV4KVxcXCIgY2xhc3M9XFxcImJzLXdpemFyZC1kb3QgYmctcHJpbWFyeVxcXCI+PGRpdiBjbGFzcz1cXFwiYnMtd2l6YXJkLWRvdC1pbm5lclxcXCJcXHJcXG4gICAgICAgIG5nLWNsYXNzPVxcXCJ7XFxyXFxuICAgICAgICAgICdiZy1zdWNjZXNzJzogIXBhZ2VIYXNFcnJvcnNbJGluZGV4XSxcXHJcXG4gICAgICAgICAgJ2JnLWRhbmdlcic6IHBhZ2VIYXNFcnJvcnNbJGluZGV4XSxcXHJcXG4gICAgICAgICAgJ2JnLXdhcm5pbmcnOiAhcGFnZVdhc1Zpc2l0ZWRbJGluZGV4XSAmJiBjdXJyZW50UGFnZSA+ICRpbmRleFxcclxcbiAgICAgICAgfVxcXCI+PC9kaXY+PC9hPlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gIDwvZGl2PlxcclxcbiAgPHN0eWxlIHR5cGU9XFxcInRleHQvY3NzXFxcIj4uYnMtd2l6YXJkID4gLmJzLXdpemFyZC1zdGVwOmZpcnN0LWNoaWxkIHsgbWFyZ2luLWxlZnQ6IHt7IG1hcmdpbiB9fSU7IH08L3N0eWxlPlxcclxcbiAgPGkgbmctc2hvdz1cXFwiIXdpemFyZExvYWRlZFxcXCIgaWQ9XFxcImZvcm1pby1sb2FkaW5nXFxcIiBzdHlsZT1cXFwiZm9udC1zaXplOiAyZW07XFxcIiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1yZWZyZXNoIGdseXBoaWNvbi1zcGluXFxcIj48L2k+XFxyXFxuICA8ZGl2IG5nLXJlcGVhdD1cXFwiYWxlcnQgaW4gZm9ybWlvQWxlcnRzIHRyYWNrIGJ5ICRpbmRleFxcXCIgY2xhc3M9XFxcImFsZXJ0IGFsZXJ0LXt7IGFsZXJ0LnR5cGUgfX1cXFwiIHJvbGU9XFxcImFsZXJ0XFxcIj57eyBhbGVydC5tZXNzYWdlIHwgZm9ybWlvVHJhbnNsYXRlOm51bGw6YnVpbGRlciB9fTwvZGl2PlxcclxcbiAgPGRpdiBjbGFzcz1cXFwiZm9ybWlvLXdpemFyZFxcXCI+XFxyXFxuICAgIDxmb3JtaW9cXHJcXG4gICAgICBuZy1pZj1cXFwid2l6YXJkTG9hZGVkXFxcIlxcclxcbiAgICAgIHN1Ym1pc3Npb249XFxcInN1Ym1pc3Npb25cXFwiXFxyXFxuICAgICAgZm9ybT1cXFwicGFnZVxcXCJcXHJcXG4gICAgICB1cmw9XFxcInVybFxcXCJcXHJcXG4gICAgICByZWFkLW9ubHk9XFxcInJlYWRPbmx5XFxcIlxcclxcbiAgICAgIGhpZGUtY29tcG9uZW50cz1cXFwiaGlkZUNvbXBvbmVudHNcXFwiXFxyXFxuICAgICAgZGlzYWJsZS1jb21wb25lbnRzPVxcXCJkaXNhYmxlQ29tcG9uZW50c1xcXCJcXHJcXG4gICAgICBmb3JtaW8tb3B0aW9ucz1cXFwiZm9ybWlvT3B0aW9uc1xcXCJcXHJcXG4gICAgICBpZD1cXFwiZm9ybWlvLXdpemFyZC1mb3JtXFxcIlxcclxcbiAgICA+PC9mb3JtaW8+XFxyXFxuICA8L2Rpdj5cXHJcXG4gIDx1bCBuZy1zaG93PVxcXCJ3aXphcmRMb2FkZWRcXFwiIGNsYXNzPVxcXCJsaXN0LWlubGluZVxcXCI+XFxyXFxuICAgIDxsaT48YSBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0XFxcIiBuZy1jbGljaz1cXFwiY2FuY2VsKClcXFwiPkNhbmNlbDwvYT48L2xpPlxcclxcbiAgICA8bGkgbmctaWY9XFxcImN1cnJlbnRQYWdlID4gMFxcXCI+PGEgY2xhc3M9XFxcImJ0biBidG4tcHJpbWFyeVxcXCIgbmctY2xpY2s9XFxcInByZXYoKVxcXCI+UHJldmlvdXM8L2E+PC9saT5cXHJcXG4gICAgPGxpIG5nLWlmPVxcXCJjdXJyZW50UGFnZSA8IChwYWdlcy5sZW5ndGggLSAxKVxcXCI+XFxyXFxuICAgICAgPGEgY2xhc3M9XFxcImJ0biBidG4tcHJpbWFyeVxcXCIgbmctY2xpY2s9XFxcIm5leHQoKVxcXCI+TmV4dDwvYT5cXHJcXG4gICAgPC9saT5cXHJcXG4gICAgPGxpIG5nLWlmPVxcXCJjdXJyZW50UGFnZSA+PSAocGFnZXMubGVuZ3RoIC0gMSlcXFwiPlxcclxcbiAgICAgIDxhIGNsYXNzPVxcXCJidG4gYnRuLXByaW1hcnlcXFwiIG5nLWNsaWNrPVxcXCJzdWJtaXQoKVxcXCI+U3VibWl0IEZvcm08L2E+XFxyXFxuICAgIDwvbGk+XFxyXFxuICA8L3VsPlxcclxcbjwvZGl2PlxcclxcblwiXHJcbiAgICApO1xyXG5cclxuICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvLWRlbGV0ZS5odG1sJyxcclxuICAgICAgXCI8Zm9ybSByb2xlPVxcXCJmb3JtXFxcIj5cXHJcXG4gIDxkaXYgbmctcmVwZWF0PVxcXCJhbGVydCBpbiBmb3JtaW9BbGVydHMgdHJhY2sgYnkgJGluZGV4XFxcIiBjbGFzcz1cXFwiYWxlcnQgYWxlcnQte3sgYWxlcnQudHlwZSB9fVxcXCIgcm9sZT1cXFwiYWxlcnRcXFwiPlxcclxcbiAgICB7eyBhbGVydC5tZXNzYWdlIHwgZm9ybWlvVHJhbnNsYXRlOm51bGw6YnVpbGRlciB9fVxcclxcbiAgPC9kaXY+XFxyXFxuICA8aDM+e3sgZGVsZXRlTWVzc2FnZSB8IGZvcm1pb1RyYW5zbGF0ZTpudWxsOmJ1aWxkZXIgfX08L2gzPlxcclxcbiAgPGRpdiBjbGFzcz1cXFwiYnRuLXRvb2xiYXJcXFwiPlxcclxcbiAgICA8YnV0dG9uIG5nLWNsaWNrPVxcXCJvbkRlbGV0ZSgpXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kYW5nZXJcXFwiPnt7ICdZZXMnIHwgZm9ybWlvVHJhbnNsYXRlOm51bGw6YnVpbGRlciB9fTwvYnV0dG9uPlxcclxcbiAgICA8YnV0dG9uIG5nLWNsaWNrPVxcXCJvbkNhbmNlbCgpXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0XFxcIj57eyAnTm8nIHwgZm9ybWlvVHJhbnNsYXRlOm51bGw6YnVpbGRlciB9fTwvYnV0dG9uPlxcclxcbiAgPC9kaXY+XFxyXFxuPC9mb3JtPlxcclxcblwiXHJcbiAgICApO1xyXG5cclxuICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL3N1Ym1pc3Npb24uaHRtbCcsXHJcbiAgICAgIFwiPGRpdj5cXHJcXG4gIDxkaXYgbmctcmVwZWF0PVxcXCJjb21wb25lbnQgaW4gZm9ybS5jb21wb25lbnRzIHRyYWNrIGJ5ICRpbmRleFxcXCIgbmctaWY9XFxcInN1Ym1pc3Npb24gJiYgc3VibWlzc2lvbi5kYXRhXFxcIj5cXHJcXG4gICAgPGZvcm1pby1jb21wb25lbnQtdmlld1xcclxcbiAgICAgIGZvcm09XFxcImZvcm1cXFwiXFxyXFxuICAgICAgY29tcG9uZW50PVxcXCJjb21wb25lbnRcXFwiXFxyXFxuICAgICAgZGF0YT1cXFwic3VibWlzc2lvbi5kYXRhXFxcIlxcclxcbiAgICAgIGlnbm9yZT1cXFwiaWdub3JlXFxcIlxcclxcbiAgICAgIHN1Ym1pc3Npb249XFxcInN1Ym1pc3Npb25cXFwiXFxyXFxuICAgICAgbmctaWY9XFxcImJ1aWxkZXIgPyAnOjp0cnVlJyA6IGlzVmlzaWJsZShjb21wb25lbnQpXFxcIlxcclxcbiAgICAgIGJ1aWxkZXI9XFxcImJ1aWxkZXJcXFwiXFxyXFxuICAgID48L2Zvcm1pby1jb21wb25lbnQtdmlldz5cXHJcXG4gIDwvZGl2PlxcclxcbjwvZGl2PlxcclxcblwiXHJcbiAgICApO1xyXG5cclxuICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL3N1Ym1pc3Npb25zLmh0bWwnLFxyXG4gICAgICBcIjxkaXY+XFxyXFxuICA8ZGl2IG5nLXJlcGVhdD1cXFwiYWxlcnQgaW4gZm9ybWlvQWxlcnRzIHRyYWNrIGJ5ICRpbmRleFxcXCIgY2xhc3M9XFxcImFsZXJ0IGFsZXJ0LXt7IGFsZXJ0LnR5cGUgfX1cXFwiIHJvbGU9XFxcImFsZXJ0XFxcIj5cXHJcXG4gICAge3sgYWxlcnQubWVzc2FnZSB8IGZvcm1pb1RyYW5zbGF0ZTpudWxsOmJ1aWxkZXIgfX1cXHJcXG4gIDwvZGl2PlxcclxcbiAgPHRhYmxlIGNsYXNzPVxcXCJ0YWJsZVxcXCI+XFxyXFxuICAgIDx0aGVhZD5cXHJcXG4gICAgICA8dHI+XFxyXFxuICAgICAgICA8dGggbmctcmVwZWF0PVxcXCJjb21wb25lbnQgaW4gZm9ybS5jb21wb25lbnRzIHwgZmxhdHRlbkNvbXBvbmVudHMgdHJhY2sgYnkgJGluZGV4XFxcIiBuZy1pZj1cXFwidGFibGVWaWV3KGNvbXBvbmVudClcXFwiPnt7IGNvbXBvbmVudC5sYWJlbCB8fCBjb21wb25lbnQua2V5IH19PC90aD5cXHJcXG4gICAgICAgIDx0aD5TdWJtaXR0ZWQ8L3RoPlxcclxcbiAgICAgICAgPHRoPlVwZGF0ZWQ8L3RoPlxcclxcbiAgICAgICAgPHRoPk9wZXJhdGlvbnM8L3RoPlxcclxcbiAgICAgIDwvdHI+XFxyXFxuICAgIDwvdGhlYWQ+XFxyXFxuICAgIDx0Ym9keT5cXHJcXG4gICAgICA8dHIgbmctcmVwZWF0PVxcXCJzdWJtaXNzaW9uIGluIHN1Ym1pc3Npb25zIHRyYWNrIGJ5ICRpbmRleFxcXCIgY2xhc3M9XFxcImZvcm1pby1zdWJtaXNzaW9uXFxcIiBuZy1jbGljaz1cXFwiJGVtaXQoJ3N1Ym1pc3Npb25WaWV3Jywgc3VibWlzc2lvbilcXFwiPlxcclxcbiAgICAgICAgPHRkIG5nLXJlcGVhdD1cXFwiY29tcG9uZW50IGluIGZvcm0uY29tcG9uZW50cyB8IGZsYXR0ZW5Db21wb25lbnRzIHRyYWNrIGJ5ICRpbmRleFxcXCIgbmctaWY9XFxcInRhYmxlVmlldyhjb21wb25lbnQpXFxcIj57eyBzdWJtaXNzaW9uLmRhdGEgfCB0YWJsZVZpZXc6Y29tcG9uZW50IH19PC90ZD5cXHJcXG4gICAgICAgIDx0ZD57eyBzdWJtaXNzaW9uLmNyZWF0ZWQgfCBhbURhdGVGb3JtYXQ6J2wsIGg6bW06c3MgYScgfX08L3RkPlxcclxcbiAgICAgICAgPHRkPnt7IHN1Ym1pc3Npb24ubW9kaWZpZWQgfCBhbURhdGVGb3JtYXQ6J2wsIGg6bW06c3MgYScgfX08L3RkPlxcclxcbiAgICAgICAgPHRkPlxcclxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJidXR0b24tZ3JvdXBcXFwiIHN0eWxlPVxcXCJkaXNwbGF5OmZsZXg7XFxcIj5cXHJcXG4gICAgICAgICAgICA8YSBuZy1jbGljaz1cXFwiJGVtaXQoJ3N1Ym1pc3Npb25WaWV3Jywgc3VibWlzc2lvbik7ICRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcXFwiIGNsYXNzPVxcXCJidG4gYnRuLXByaW1hcnkgYnRuLXhzXFxcIj48c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1leWUtb3BlblxcXCI+PC9zcGFuPjwvYT4mbmJzcDtcXHJcXG4gICAgICAgICAgICA8YSBuZy1jbGljaz1cXFwiJGVtaXQoJ3N1Ym1pc3Npb25FZGl0Jywgc3VibWlzc2lvbik7ICRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHQgYnRuLXhzXFxcIj48c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1lZGl0XFxcIj48L3NwYW4+PC9hPiZuYnNwO1xcclxcbiAgICAgICAgICAgIDxhIG5nLWNsaWNrPVxcXCIkZW1pdCgnc3VibWlzc2lvbkRlbGV0ZScsIHN1Ym1pc3Npb24pOyAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kYW5nZXIgYnRuLXhzXFxcIj48c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1yZW1vdmUtY2lyY2xlXFxcIj48L3NwYW4+PC9hPlxcclxcbiAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDwvdGQ+XFxyXFxuICAgICAgPC90cj5cXHJcXG4gICAgPC90Ym9keT5cXHJcXG4gIDwvdGFibGU+XFxyXFxuICA8cGFnaW5hdGlvblxcclxcbiAgICBuZy1pZj1cXFwic3VibWlzc2lvbnMuc2VydmVyQ291bnQgPiBwZXJQYWdlXFxcIlxcclxcbiAgICBuZy1tb2RlbD1cXFwiY3VycmVudFBhZ2VcXFwiXFxyXFxuICAgIG5nLWNoYW5nZT1cXFwicGFnZUNoYW5nZWQoY3VycmVudFBhZ2UpXFxcIlxcclxcbiAgICB0b3RhbC1pdGVtcz1cXFwic3VibWlzc2lvbnMuc2VydmVyQ291bnRcXFwiXFxyXFxuICAgIGl0ZW1zLXBlci1wYWdlPVxcXCJwZXJQYWdlXFxcIlxcclxcbiAgICBkaXJlY3Rpb24tbGlua3M9XFxcImZhbHNlXFxcIlxcclxcbiAgICBib3VuZGFyeS1saW5rcz1cXFwidHJ1ZVxcXCJcXHJcXG4gICAgZmlyc3QtdGV4dD1cXFwiJmxhcXVvO1xcXCJcXHJcXG4gICAgbGFzdC10ZXh0PVxcXCImcmFxdW87XFxcIlxcclxcbiAgICA+XFxyXFxuICA8L3BhZ2luYXRpb24+XFxyXFxuPC9kaXY+XFxyXFxuXCJcclxuICAgICk7XHJcblxyXG4gICAgLy8gQSBmb3JtaW8gY29tcG9uZW50IHRlbXBsYXRlLlxyXG4gICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50Lmh0bWwnLFxyXG4gICAgICBcIjxkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXAgZm9ybS1maWVsZC10eXBlLXt7IGNvbXBvbmVudC50eXBlIH19IGZvcm1pby1jb21wb25lbnQte3sgY29tcG9uZW50LmtleSB9fSB7e2NvbXBvbmVudC5jdXN0b21DbGFzc319XFxcIiBpZD1cXFwiZm9ybS1ncm91cC17eyBjb21wb25lbnRJZCB9fVxcXCJcXHJcXG4gICAgIG5nLWNsYXNzPVxcXCJ7J2hhcy1mZWVkYmFjayAnOiAoY29tcG9uZW50LmhpZGVMYWJlbCA9PT0gdHJ1ZSB8fCBjb21wb25lbnQubGFiZWwgPT09ICcnIHx8ICFjb21wb25lbnQubGFiZWwpICYmIGNvbXBvbmVudC52YWxpZGF0ZS5yZXF1aXJlZCxcXHJcXG4gICAgICAgICAgICAgJ2hhcy1lcnJvcic6IGZvcm1pb0Zvcm1bY29tcG9uZW50SWRdLiRpbnZhbGlkICYmICFmb3JtaW9Gb3JtW2NvbXBvbmVudElkXS4kcHJpc3RpbmUgfVxcXCJcXHJcXG4gICAgIG5nLXN0eWxlPVxcXCJjb21wb25lbnQuc3R5bGVcXFwiXFxyXFxuICAgICBuZy1oaWRlPVxcXCJjb21wb25lbnQuaGlkZGVuXFxcIj5cXHJcXG4gIDxmb3JtaW8tZWxlbWVudD48L2Zvcm1pby1lbGVtZW50PlxcclxcbjwvZGl2PlxcclxcblxcclxcblwiXHJcbiAgICApO1xyXG5cclxuICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudC12aWV3Lmh0bWwnLFxyXG4gICAgICBcIjxkaXYgbmFtZT1cXFwie3sgY29tcG9uZW50SWQgfX1cXFwiIGNsYXNzPVxcXCJmb3JtLWdyb3VwIGhhcy1mZWVkYmFjayBmb3JtLWZpZWxkLXR5cGUte3sgY29tcG9uZW50LnR5cGUgfX0ge3tjb21wb25lbnQuY3VzdG9tQ2xhc3N9fSBmb3JtaW8tY29tcG9uZW50LXt7IGNvbXBvbmVudC5rZXkgfX1cXFwiIGlkPVxcXCJmb3JtLWdyb3VwLXt7IGNvbXBvbmVudElkIH19XFxcIiBuZy1zdHlsZT1cXFwiY29tcG9uZW50LnN0eWxlXFxcIj5cXHJcXG4gIDxmb3JtaW8tZWxlbWVudD48L2Zvcm1pby1lbGVtZW50PlxcclxcbjwvZGl2PlxcclxcblwiXHJcbiAgICApO1xyXG5cclxuICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2VsZW1lbnQtdmlldy5odG1sJyxcclxuICAgICAgXCI8ZGl2PlxcclxcbiAgPGRpdiBuZy1pZj1cXFwiY29tcG9uZW50LmxhYmVsXFxcIj48c3Ryb25nPnt7IGNvbXBvbmVudC5sYWJlbCB9fTwvc3Ryb25nPjwvZGl2PlxcclxcbiAgPGRpdiBmb3JtaW8tYmluZC1odG1sPVxcXCJkYXRhIHwgdGFibGVWaWV3OmNvbXBvbmVudFxcXCI+PC9kaXY+XFxyXFxuPC9kaXY+XFxyXFxuXCJcclxuICAgICk7XHJcblxyXG4gICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vZXJyb3JzLmh0bWwnLFxyXG4gICAgICBcIjxkaXYgbmctc2hvdz1cXFwiZm9ybWlvRm9ybVtjb21wb25lbnRJZF0uJGVycm9yICYmICFmb3JtaW9Gb3JtW2NvbXBvbmVudElkXS4kcHJpc3RpbmVcXFwiPlxcclxcbiAgPHAgY2xhc3M9XFxcImhlbHAtYmxvY2tcXFwiIG5nLXNob3c9XFxcImZvcm1pb0Zvcm1bY29tcG9uZW50SWRdLiRlcnJvci5lbWFpbFxcXCI+e3sgY29tcG9uZW50LmxhYmVsIHx8IGNvbXBvbmVudC5wbGFjZWhvbGRlciB8fCBjb21wb25lbnQua2V5IH19IHt7J211c3QgYmUgYSB2YWxpZCBlbWFpbCcgfCBmb3JtaW9UcmFuc2xhdGU6bnVsbDpidWlsZGVyfX0uPC9wPlxcclxcbiAgPHAgY2xhc3M9XFxcImhlbHAtYmxvY2tcXFwiIG5nLXNob3c9XFxcImZvcm1pb0Zvcm1bY29tcG9uZW50SWRdLiRlcnJvci5yZXF1aXJlZFxcXCI+e3sgY29tcG9uZW50LmxhYmVsIHx8IGNvbXBvbmVudC5wbGFjZWhvbGRlciB8fCBjb21wb25lbnQua2V5IH19IHt7J2lzIHJlcXVpcmVkJyB8IGZvcm1pb1RyYW5zbGF0ZTpudWxsOmJ1aWxkZXJ9fS48L3A+XFxyXFxuICA8cCBjbGFzcz1cXFwiaGVscC1ibG9ja1xcXCIgbmctc2hvdz1cXFwiZm9ybWlvRm9ybVtjb21wb25lbnRJZF0uJGVycm9yLm51bWJlclxcXCI+e3sgY29tcG9uZW50LmxhYmVsIHx8IGNvbXBvbmVudC5wbGFjZWhvbGRlciB8fCBjb21wb25lbnQua2V5IH19IHt7J211c3QgYmUgYSBudW1iZXInIHwgZm9ybWlvVHJhbnNsYXRlOm51bGw6YnVpbGRlcn19LjwvcD5cXHJcXG4gIDxwIGNsYXNzPVxcXCJoZWxwLWJsb2NrXFxcIiBuZy1zaG93PVxcXCJmb3JtaW9Gb3JtW2NvbXBvbmVudElkXS4kZXJyb3IubWF4bGVuZ3RoXFxcIj57eyBjb21wb25lbnQubGFiZWwgfHwgY29tcG9uZW50LnBsYWNlaG9sZGVyIHx8IGNvbXBvbmVudC5rZXkgfX0ge3snbXVzdCBiZSBzaG9ydGVyIHRoYW4nIHwgZm9ybWlvVHJhbnNsYXRlOm51bGw6YnVpbGRlcn19IHt7IGNvbXBvbmVudC52YWxpZGF0ZS5tYXhMZW5ndGggKyAxIH19IHt7J2NoYXJhY3RlcnMnIHwgZm9ybWlvVHJhbnNsYXRlOm51bGw6YnVpbGRlcn19LjwvcD5cXHJcXG4gIDxwIGNsYXNzPVxcXCJoZWxwLWJsb2NrXFxcIiBuZy1zaG93PVxcXCJmb3JtaW9Gb3JtW2NvbXBvbmVudElkXS4kZXJyb3IubWlubGVuZ3RoXFxcIj57eyBjb21wb25lbnQubGFiZWwgfHwgY29tcG9uZW50LnBsYWNlaG9sZGVyIHx8IGNvbXBvbmVudC5rZXkgfX0ge3snbXVzdCBiZSBsb25nZXIgdGhhbicgfCBmb3JtaW9UcmFuc2xhdGU6bnVsbDpidWlsZGVyfX0ge3sgY29tcG9uZW50LnZhbGlkYXRlLm1pbkxlbmd0aCAtIDEgfX0ge3snY2hhcmFjdGVycycgfCBmb3JtaW9UcmFuc2xhdGU6bnVsbDpidWlsZGVyfX0uPC9wPlxcclxcbiAgPHAgY2xhc3M9XFxcImhlbHAtYmxvY2tcXFwiIG5nLXNob3c9XFxcImZvcm1pb0Zvcm1bY29tcG9uZW50SWRdLiRlcnJvci5taW5cXFwiPnt7IGNvbXBvbmVudC5sYWJlbCB8fCBjb21wb25lbnQucGxhY2Vob2xkZXIgfHwgY29tcG9uZW50LmtleSB9fSB7eydtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0bycgfCBmb3JtaW9UcmFuc2xhdGU6bnVsbDpidWlsZGVyfX0ge3sgY29tcG9uZW50LnZhbGlkYXRlLm1pbiB9fS48L3A+XFxyXFxuICA8cCBjbGFzcz1cXFwiaGVscC1ibG9ja1xcXCIgbmctc2hvdz1cXFwiZm9ybWlvRm9ybVtjb21wb25lbnRJZF0uJGVycm9yLm1heFxcXCI+e3sgY29tcG9uZW50LmxhYmVsIHx8IGNvbXBvbmVudC5wbGFjZWhvbGRlciB8fCBjb21wb25lbnQua2V5IH19IHt7J211c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvJyB8IGZvcm1pb1RyYW5zbGF0ZTpudWxsOmJ1aWxkZXJ9fSB7eyBjb21wb25lbnQudmFsaWRhdGUubWF4IH19LjwvcD5cXHJcXG4gIDxwIGNsYXNzPVxcXCJoZWxwLWJsb2NrXFxcIiBuZy1zaG93PVxcXCJmb3JtaW9Gb3JtW2NvbXBvbmVudElkXS4kZXJyb3IuY3VzdG9tXFxcIj57eyBjb21wb25lbnQuY3VzdG9tRXJyb3IgfCBmb3JtaW9UcmFuc2xhdGUgfX08L3A+XFxyXFxuICA8cCBjbGFzcz1cXFwiaGVscC1ibG9ja1xcXCIgbmctc2hvdz1cXFwiZm9ybWlvRm9ybVtjb21wb25lbnRJZF0uJGVycm9yLnBhdHRlcm5cXFwiPnt7IGNvbXBvbmVudC5sYWJlbCB8fCBjb21wb25lbnQucGxhY2Vob2xkZXIgfHwgY29tcG9uZW50LmtleSB9fSB7eydkb2VzIG5vdCBtYXRjaCB0aGUgcGF0dGVybicgfCBmb3JtaW9UcmFuc2xhdGU6bnVsbDpidWlsZGVyfX0ge3sgY29tcG9uZW50LnZhbGlkYXRlLnBhdHRlcm4gfX08L3A+XFxyXFxuICA8cCBjbGFzcz1cXFwiaGVscC1ibG9ja1xcXCIgbmctc2hvdz1cXFwiZm9ybWlvRm9ybVtjb21wb25lbnRJZF0uJGVycm9yLmRheVxcXCI+e3sgY29tcG9uZW50LmxhYmVsIHx8IGNvbXBvbmVudC5wbGFjZWhvbGRlciB8fCBjb21wb25lbnQua2V5IH19IHt7J211c3QgYmUgYSB2YWxpZCBkYXRlJyB8IGZvcm1pb1RyYW5zbGF0ZTpudWxsOmJ1aWxkZXJ9fS48L3A+XFxyXFxuPC9kaXY+XFxyXFxuXCJcclxuICAgICk7XHJcbiAgfVxyXG5dKTtcclxuXHJcbnJlcXVpcmUoJy4vY29tcG9uZW50cycpO1xyXG4iLCIvKiFcclxuICogRXZlbnRFbWl0dGVyMlxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vaGlqMW54L0V2ZW50RW1pdHRlcjJcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDEzIGhpajFueFxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXHJcbiAqL1xyXG47IWZ1bmN0aW9uKHVuZGVmaW5lZCkge1xyXG5cclxuICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgPyBBcnJheS5pc0FycmF5IDogZnVuY3Rpb24gX2lzQXJyYXkob2JqKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBBcnJheV1cIjtcclxuICB9O1xyXG4gIHZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XHJcblxyXG4gIGZ1bmN0aW9uIGluaXQoKSB7XHJcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcclxuICAgIGlmICh0aGlzLl9jb25mKSB7XHJcbiAgICAgIGNvbmZpZ3VyZS5jYWxsKHRoaXMsIHRoaXMuX2NvbmYpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY29uZmlndXJlKGNvbmYpIHtcclxuICAgIGlmIChjb25mKSB7XHJcbiAgICAgIHRoaXMuX2NvbmYgPSBjb25mO1xyXG5cclxuICAgICAgY29uZi5kZWxpbWl0ZXIgJiYgKHRoaXMuZGVsaW1pdGVyID0gY29uZi5kZWxpbWl0ZXIpO1xyXG4gICAgICB0aGlzLl9ldmVudHMubWF4TGlzdGVuZXJzID0gY29uZi5tYXhMaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCA/IGNvbmYubWF4TGlzdGVuZXJzIDogZGVmYXVsdE1heExpc3RlbmVycztcclxuICAgICAgY29uZi53aWxkY2FyZCAmJiAodGhpcy53aWxkY2FyZCA9IGNvbmYud2lsZGNhcmQpO1xyXG4gICAgICBjb25mLm5ld0xpc3RlbmVyICYmICh0aGlzLm5ld0xpc3RlbmVyID0gY29uZi5uZXdMaXN0ZW5lcik7XHJcbiAgICAgIGNvbmYudmVyYm9zZU1lbW9yeUxlYWsgJiYgKHRoaXMudmVyYm9zZU1lbW9yeUxlYWsgPSBjb25mLnZlcmJvc2VNZW1vcnlMZWFrKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLndpbGRjYXJkKSB7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lclRyZWUgPSB7fTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fZXZlbnRzLm1heExpc3RlbmVycyA9IGRlZmF1bHRNYXhMaXN0ZW5lcnM7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBsb2dQb3NzaWJsZU1lbW9yeUxlYWsoY291bnQsIGV2ZW50TmFtZSkge1xyXG4gICAgdmFyIGVycm9yTXNnID0gJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xyXG4gICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xyXG4gICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nO1xyXG5cclxuICAgIGlmKHRoaXMudmVyYm9zZU1lbW9yeUxlYWspe1xyXG4gICAgICBlcnJvck1zZyArPSAnIEV2ZW50IG5hbWU6ICVzLic7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3JNc2csIGNvdW50LCBldmVudE5hbWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc29sZS5lcnJvcihlcnJvck1zZywgY291bnQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjb25zb2xlLnRyYWNlKXtcclxuICAgICAgY29uc29sZS50cmFjZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKGNvbmYpIHtcclxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xyXG4gICAgdGhpcy5uZXdMaXN0ZW5lciA9IGZhbHNlO1xyXG4gICAgdGhpcy52ZXJib3NlTWVtb3J5TGVhayA9IGZhbHNlO1xyXG4gICAgY29uZmlndXJlLmNhbGwodGhpcywgY29uZik7XHJcbiAgfVxyXG4gIEV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIyID0gRXZlbnRFbWl0dGVyOyAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgZXhwb3J0aW5nIEV2ZW50RW1pdHRlciBwcm9wZXJ0eVxyXG5cclxuICAvL1xyXG4gIC8vIEF0dGVudGlvbiwgZnVuY3Rpb24gcmV0dXJuIHR5cGUgbm93IGlzIGFycmF5LCBhbHdheXMgIVxyXG4gIC8vIEl0IGhhcyB6ZXJvIGVsZW1lbnRzIGlmIG5vIGFueSBtYXRjaGVzIGZvdW5kIGFuZCBvbmUgb3IgbW9yZVxyXG4gIC8vIGVsZW1lbnRzIChsZWFmcykgaWYgdGhlcmUgYXJlIG1hdGNoZXNcclxuICAvL1xyXG4gIGZ1bmN0aW9uIHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgdHJlZSwgaSkge1xyXG4gICAgaWYgKCF0cmVlKSB7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIHZhciBsaXN0ZW5lcnM9W10sIGxlYWYsIGxlbiwgYnJhbmNoLCB4VHJlZSwgeHhUcmVlLCBpc29sYXRlZEJyYW5jaCwgZW5kUmVhY2hlZCxcclxuICAgICAgICB0eXBlTGVuZ3RoID0gdHlwZS5sZW5ndGgsIGN1cnJlbnRUeXBlID0gdHlwZVtpXSwgbmV4dFR5cGUgPSB0eXBlW2krMV07XHJcbiAgICBpZiAoaSA9PT0gdHlwZUxlbmd0aCAmJiB0cmVlLl9saXN0ZW5lcnMpIHtcclxuICAgICAgLy9cclxuICAgICAgLy8gSWYgYXQgdGhlIGVuZCBvZiB0aGUgZXZlbnQocykgbGlzdCBhbmQgdGhlIHRyZWUgaGFzIGxpc3RlbmVyc1xyXG4gICAgICAvLyBpbnZva2UgdGhvc2UgbGlzdGVuZXJzLlxyXG4gICAgICAvL1xyXG4gICAgICBpZiAodHlwZW9mIHRyZWUuX2xpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGhhbmRsZXJzICYmIGhhbmRsZXJzLnB1c2godHJlZS5fbGlzdGVuZXJzKTtcclxuICAgICAgICByZXR1cm4gW3RyZWVdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvciAobGVhZiA9IDAsIGxlbiA9IHRyZWUuX2xpc3RlbmVycy5sZW5ndGg7IGxlYWYgPCBsZW47IGxlYWYrKykge1xyXG4gICAgICAgICAgaGFuZGxlcnMgJiYgaGFuZGxlcnMucHVzaCh0cmVlLl9saXN0ZW5lcnNbbGVhZl0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW3RyZWVdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKChjdXJyZW50VHlwZSA9PT0gJyonIHx8IGN1cnJlbnRUeXBlID09PSAnKionKSB8fCB0cmVlW2N1cnJlbnRUeXBlXSkge1xyXG4gICAgICAvL1xyXG4gICAgICAvLyBJZiB0aGUgZXZlbnQgZW1pdHRlZCBpcyAnKicgYXQgdGhpcyBwYXJ0XHJcbiAgICAgIC8vIG9yIHRoZXJlIGlzIGEgY29uY3JldGUgbWF0Y2ggYXQgdGhpcyBwYXRjaFxyXG4gICAgICAvL1xyXG4gICAgICBpZiAoY3VycmVudFR5cGUgPT09ICcqJykge1xyXG4gICAgICAgIGZvciAoYnJhbmNoIGluIHRyZWUpIHtcclxuICAgICAgICAgIGlmIChicmFuY2ggIT09ICdfbGlzdGVuZXJzJyAmJiB0cmVlLmhhc093blByb3BlcnR5KGJyYW5jaCkpIHtcclxuICAgICAgICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmNvbmNhdChzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHRyZWVbYnJhbmNoXSwgaSsxKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsaXN0ZW5lcnM7XHJcbiAgICAgIH0gZWxzZSBpZihjdXJyZW50VHlwZSA9PT0gJyoqJykge1xyXG4gICAgICAgIGVuZFJlYWNoZWQgPSAoaSsxID09PSB0eXBlTGVuZ3RoIHx8IChpKzIgPT09IHR5cGVMZW5ndGggJiYgbmV4dFR5cGUgPT09ICcqJykpO1xyXG4gICAgICAgIGlmKGVuZFJlYWNoZWQgJiYgdHJlZS5fbGlzdGVuZXJzKSB7XHJcbiAgICAgICAgICAvLyBUaGUgbmV4dCBlbGVtZW50IGhhcyBhIF9saXN0ZW5lcnMsIGFkZCBpdCB0byB0aGUgaGFuZGxlcnMuXHJcbiAgICAgICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuY29uY2F0KHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgdHJlZSwgdHlwZUxlbmd0aCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChicmFuY2ggaW4gdHJlZSkge1xyXG4gICAgICAgICAgaWYgKGJyYW5jaCAhPT0gJ19saXN0ZW5lcnMnICYmIHRyZWUuaGFzT3duUHJvcGVydHkoYnJhbmNoKSkge1xyXG4gICAgICAgICAgICBpZihicmFuY2ggPT09ICcqJyB8fCBicmFuY2ggPT09ICcqKicpIHtcclxuICAgICAgICAgICAgICBpZih0cmVlW2JyYW5jaF0uX2xpc3RlbmVycyAmJiAhZW5kUmVhY2hlZCkge1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmNvbmNhdChzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHRyZWVbYnJhbmNoXSwgdHlwZUxlbmd0aCkpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuY29uY2F0KHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgdHJlZVticmFuY2hdLCBpKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZihicmFuY2ggPT09IG5leHRUeXBlKSB7XHJcbiAgICAgICAgICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmNvbmNhdChzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHRyZWVbYnJhbmNoXSwgaSsyKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgLy8gTm8gbWF0Y2ggb24gdGhpcyBvbmUsIHNoaWZ0IGludG8gdGhlIHRyZWUgYnV0IG5vdCBpbiB0aGUgdHlwZSBhcnJheS5cclxuICAgICAgICAgICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuY29uY2F0KHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgdHJlZVticmFuY2hdLCBpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGxpc3RlbmVycztcclxuICAgICAgfVxyXG5cclxuICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmNvbmNhdChzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHRyZWVbY3VycmVudFR5cGVdLCBpKzEpKTtcclxuICAgIH1cclxuXHJcbiAgICB4VHJlZSA9IHRyZWVbJyonXTtcclxuICAgIGlmICh4VHJlZSkge1xyXG4gICAgICAvL1xyXG4gICAgICAvLyBJZiB0aGUgbGlzdGVuZXIgdHJlZSB3aWxsIGFsbG93IGFueSBtYXRjaCBmb3IgdGhpcyBwYXJ0LFxyXG4gICAgICAvLyB0aGVuIHJlY3Vyc2l2ZWx5IGV4cGxvcmUgYWxsIGJyYW5jaGVzIG9mIHRoZSB0cmVlXHJcbiAgICAgIC8vXHJcbiAgICAgIHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgeFRyZWUsIGkrMSk7XHJcbiAgICB9XHJcblxyXG4gICAgeHhUcmVlID0gdHJlZVsnKionXTtcclxuICAgIGlmKHh4VHJlZSkge1xyXG4gICAgICBpZihpIDwgdHlwZUxlbmd0aCkge1xyXG4gICAgICAgIGlmKHh4VHJlZS5fbGlzdGVuZXJzKSB7XHJcbiAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgbGlzdGVuZXIgb24gYSAnKionLCBpdCB3aWxsIGNhdGNoIGFsbCwgc28gYWRkIGl0cyBoYW5kbGVyLlxyXG4gICAgICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB4eFRyZWUsIHR5cGVMZW5ndGgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQnVpbGQgYXJyYXlzIG9mIG1hdGNoaW5nIG5leHQgYnJhbmNoZXMgYW5kIG90aGVycy5cclxuICAgICAgICBmb3IoYnJhbmNoIGluIHh4VHJlZSkge1xyXG4gICAgICAgICAgaWYoYnJhbmNoICE9PSAnX2xpc3RlbmVycycgJiYgeHhUcmVlLmhhc093blByb3BlcnR5KGJyYW5jaCkpIHtcclxuICAgICAgICAgICAgaWYoYnJhbmNoID09PSBuZXh0VHlwZSkge1xyXG4gICAgICAgICAgICAgIC8vIFdlIGtub3cgdGhlIG5leHQgZWxlbWVudCB3aWxsIG1hdGNoLCBzbyBqdW1wIHR3aWNlLlxyXG4gICAgICAgICAgICAgIHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgeHhUcmVlW2JyYW5jaF0sIGkrMik7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZihicmFuY2ggPT09IGN1cnJlbnRUeXBlKSB7XHJcbiAgICAgICAgICAgICAgLy8gQ3VycmVudCBub2RlIG1hdGNoZXMsIG1vdmUgaW50byB0aGUgdHJlZS5cclxuICAgICAgICAgICAgICBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHh4VHJlZVticmFuY2hdLCBpKzEpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGlzb2xhdGVkQnJhbmNoID0ge307XHJcbiAgICAgICAgICAgICAgaXNvbGF0ZWRCcmFuY2hbYnJhbmNoXSA9IHh4VHJlZVticmFuY2hdO1xyXG4gICAgICAgICAgICAgIHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgeyAnKionOiBpc29sYXRlZEJyYW5jaCB9LCBpKzEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYoeHhUcmVlLl9saXN0ZW5lcnMpIHtcclxuICAgICAgICAvLyBXZSBoYXZlIHJlYWNoZWQgdGhlIGVuZCBhbmQgc3RpbGwgb24gYSAnKionXHJcbiAgICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB4eFRyZWUsIHR5cGVMZW5ndGgpO1xyXG4gICAgICB9IGVsc2UgaWYoeHhUcmVlWycqJ10gJiYgeHhUcmVlWycqJ10uX2xpc3RlbmVycykge1xyXG4gICAgICAgIHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgeHhUcmVlWycqJ10sIHR5cGVMZW5ndGgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGxpc3RlbmVycztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdyb3dMaXN0ZW5lclRyZWUodHlwZSwgbGlzdGVuZXIpIHtcclxuXHJcbiAgICB0eXBlID0gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnID8gdHlwZS5zcGxpdCh0aGlzLmRlbGltaXRlcikgOiB0eXBlLnNsaWNlKCk7XHJcblxyXG4gICAgLy9cclxuICAgIC8vIExvb2tzIGZvciB0d28gY29uc2VjdXRpdmUgJyoqJywgaWYgc28sIGRvbid0IGFkZCB0aGUgZXZlbnQgYXQgYWxsLlxyXG4gICAgLy9cclxuICAgIGZvcih2YXIgaSA9IDAsIGxlbiA9IHR5cGUubGVuZ3RoOyBpKzEgPCBsZW47IGkrKykge1xyXG4gICAgICBpZih0eXBlW2ldID09PSAnKionICYmIHR5cGVbaSsxXSA9PT0gJyoqJykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciB0cmVlID0gdGhpcy5saXN0ZW5lclRyZWU7XHJcbiAgICB2YXIgbmFtZSA9IHR5cGUuc2hpZnQoKTtcclxuXHJcbiAgICB3aGlsZSAobmFtZSAhPT0gdW5kZWZpbmVkKSB7XHJcblxyXG4gICAgICBpZiAoIXRyZWVbbmFtZV0pIHtcclxuICAgICAgICB0cmVlW25hbWVdID0ge307XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRyZWUgPSB0cmVlW25hbWVdO1xyXG5cclxuICAgICAgaWYgKHR5cGUubGVuZ3RoID09PSAwKSB7XHJcblxyXG4gICAgICAgIGlmICghdHJlZS5fbGlzdGVuZXJzKSB7XHJcbiAgICAgICAgICB0cmVlLl9saXN0ZW5lcnMgPSBsaXN0ZW5lcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICBpZiAodHlwZW9mIHRyZWUuX2xpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0cmVlLl9saXN0ZW5lcnMgPSBbdHJlZS5fbGlzdGVuZXJzXTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB0cmVlLl9saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XHJcblxyXG4gICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAhdHJlZS5fbGlzdGVuZXJzLndhcm5lZCAmJlxyXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMubWF4TGlzdGVuZXJzID4gMCAmJlxyXG4gICAgICAgICAgICB0cmVlLl9saXN0ZW5lcnMubGVuZ3RoID4gdGhpcy5fZXZlbnRzLm1heExpc3RlbmVyc1xyXG4gICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHRyZWUuX2xpc3RlbmVycy53YXJuZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBsb2dQb3NzaWJsZU1lbW9yeUxlYWsuY2FsbCh0aGlzLCB0cmVlLl9saXN0ZW5lcnMubGVuZ3RoLCBuYW1lKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgbmFtZSA9IHR5cGUuc2hpZnQoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhblxyXG4gIC8vIDEwIGxpc3RlbmVycyBhcmUgYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaFxyXG4gIC8vIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxyXG4gIC8vXHJcbiAgLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXHJcbiAgLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXHJcblxyXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZGVsaW1pdGVyID0gJy4nO1xyXG5cclxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcclxuICAgIGlmIChuICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhpcy5fZXZlbnRzIHx8IGluaXQuY2FsbCh0aGlzKTtcclxuICAgICAgdGhpcy5fZXZlbnRzLm1heExpc3RlbmVycyA9IG47XHJcbiAgICAgIGlmICghdGhpcy5fY29uZikgdGhpcy5fY29uZiA9IHt9O1xyXG4gICAgICB0aGlzLl9jb25mLm1heExpc3RlbmVycyA9IG47XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudCA9ICcnO1xyXG5cclxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pIHtcclxuICAgIHRoaXMubWFueShldmVudCwgMSwgZm4pO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5tYW55ID0gZnVuY3Rpb24oZXZlbnQsIHR0bCwgZm4pIHtcclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWFueSBvbmx5IGFjY2VwdHMgaW5zdGFuY2VzIG9mIEZ1bmN0aW9uJyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbGlzdGVuZXIoKSB7XHJcbiAgICAgIGlmICgtLXR0bCA9PT0gMCkge1xyXG4gICAgICAgIHNlbGYub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XHJcbiAgICAgIH1cclxuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH1cclxuXHJcbiAgICBsaXN0ZW5lci5fb3JpZ2luID0gZm47XHJcblxyXG4gICAgdGhpcy5vbihldmVudCwgbGlzdGVuZXIpO1xyXG5cclxuICAgIHJldHVybiBzZWxmO1xyXG4gIH07XHJcblxyXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHRoaXMuX2V2ZW50cyB8fCBpbml0LmNhbGwodGhpcyk7XHJcblxyXG4gICAgdmFyIHR5cGUgPSBhcmd1bWVudHNbMF07XHJcblxyXG4gICAgaWYgKHR5cGUgPT09ICduZXdMaXN0ZW5lcicgJiYgIXRoaXMubmV3TGlzdGVuZXIpIHtcclxuICAgICAgaWYgKCF0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgYWwgPSBhcmd1bWVudHMubGVuZ3RoO1xyXG4gICAgdmFyIGFyZ3MsbCxpLGo7XHJcbiAgICB2YXIgaGFuZGxlcjtcclxuXHJcbiAgICBpZiAodGhpcy5fYWxsICYmIHRoaXMuX2FsbC5sZW5ndGgpIHtcclxuICAgICAgaGFuZGxlciA9IHRoaXMuX2FsbC5zbGljZSgpO1xyXG4gICAgICBpZiAoYWwgPiAzKSB7XHJcbiAgICAgICAgYXJncyA9IG5ldyBBcnJheShhbCk7XHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGFsOyBqKyspIGFyZ3Nbal0gPSBhcmd1bWVudHNbal07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBoYW5kbGVyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIHRoaXMuZXZlbnQgPSB0eXBlO1xyXG4gICAgICAgIHN3aXRjaCAoYWwpIHtcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICBoYW5kbGVyW2ldLmNhbGwodGhpcywgdHlwZSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICBoYW5kbGVyW2ldLmNhbGwodGhpcywgdHlwZSwgYXJndW1lbnRzWzFdKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgIGhhbmRsZXJbaV0uY2FsbCh0aGlzLCB0eXBlLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgaGFuZGxlcltpXS5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy53aWxkY2FyZCkge1xyXG4gICAgICBoYW5kbGVyID0gW107XHJcbiAgICAgIHZhciBucyA9IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IHR5cGUuc3BsaXQodGhpcy5kZWxpbWl0ZXIpIDogdHlwZS5zbGljZSgpO1xyXG4gICAgICBzZWFyY2hMaXN0ZW5lclRyZWUuY2FsbCh0aGlzLCBoYW5kbGVyLCBucywgdGhpcy5saXN0ZW5lclRyZWUsIDApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudCA9IHR5cGU7XHJcbiAgICAgICAgc3dpdGNoIChhbCkge1xyXG4gICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBhcmdzID0gbmV3IEFycmF5KGFsIC0gMSk7XHJcbiAgICAgICAgICBmb3IgKGogPSAxOyBqIDwgYWw7IGorKykgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XHJcbiAgICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfSBlbHNlIGlmIChoYW5kbGVyKSB7XHJcbiAgICAgICAgLy8gbmVlZCB0byBtYWtlIGNvcHkgb2YgaGFuZGxlcnMgYmVjYXVzZSBsaXN0IGNhbiBjaGFuZ2UgaW4gdGhlIG1pZGRsZVxyXG4gICAgICAgIC8vIG9mIGVtaXQgY2FsbFxyXG4gICAgICAgIGhhbmRsZXIgPSBoYW5kbGVyLnNsaWNlKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoaGFuZGxlciAmJiBoYW5kbGVyLmxlbmd0aCkge1xyXG4gICAgICBpZiAoYWwgPiAzKSB7XHJcbiAgICAgICAgYXJncyA9IG5ldyBBcnJheShhbCAtIDEpO1xyXG4gICAgICAgIGZvciAoaiA9IDE7IGogPCBhbDsgaisrKSBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcclxuICAgICAgfVxyXG4gICAgICBmb3IgKGkgPSAwLCBsID0gaGFuZGxlci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICB0aGlzLmV2ZW50ID0gdHlwZTtcclxuICAgICAgICBzd2l0Y2ggKGFsKSB7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgaGFuZGxlcltpXS5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgaGFuZGxlcltpXS5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICBoYW5kbGVyW2ldLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIGhhbmRsZXJbaV0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSBlbHNlIGlmICghdGhpcy5fYWxsICYmIHR5cGUgPT09ICdlcnJvcicpIHtcclxuICAgICAgaWYgKGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgdGhyb3cgYXJndW1lbnRzWzFdOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuY2F1Z2h0LCB1bnNwZWNpZmllZCAnZXJyb3InIGV2ZW50LlwiKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICEhdGhpcy5fYWxsO1xyXG4gIH07XHJcblxyXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdEFzeW5jID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgdGhpcy5fZXZlbnRzIHx8IGluaXQuY2FsbCh0aGlzKTtcclxuXHJcbiAgICB2YXIgdHlwZSA9IGFyZ3VtZW50c1swXTtcclxuXHJcbiAgICBpZiAodHlwZSA9PT0gJ25ld0xpc3RlbmVyJyAmJiAhdGhpcy5uZXdMaXN0ZW5lcikge1xyXG4gICAgICAgIGlmICghdGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUoW2ZhbHNlXSk7IH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgcHJvbWlzZXM9IFtdO1xyXG5cclxuICAgIHZhciBhbCA9IGFyZ3VtZW50cy5sZW5ndGg7XHJcbiAgICB2YXIgYXJncyxsLGksajtcclxuICAgIHZhciBoYW5kbGVyO1xyXG5cclxuICAgIGlmICh0aGlzLl9hbGwpIHtcclxuICAgICAgaWYgKGFsID4gMykge1xyXG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkoYWwpO1xyXG4gICAgICAgIGZvciAoaiA9IDE7IGogPCBhbDsgaisrKSBhcmdzW2pdID0gYXJndW1lbnRzW2pdO1xyXG4gICAgICB9XHJcbiAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLl9hbGwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudCA9IHR5cGU7XHJcbiAgICAgICAgc3dpdGNoIChhbCkge1xyXG4gICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5fYWxsW2ldLmNhbGwodGhpcywgdHlwZSkpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLl9hbGxbaV0uY2FsbCh0aGlzLCB0eXBlLCBhcmd1bWVudHNbMV0pKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5fYWxsW2ldLmNhbGwodGhpcywgdHlwZSwgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuX2FsbFtpXS5hcHBseSh0aGlzLCBhcmdzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMud2lsZGNhcmQpIHtcclxuICAgICAgaGFuZGxlciA9IFtdO1xyXG4gICAgICB2YXIgbnMgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgPyB0eXBlLnNwbGl0KHRoaXMuZGVsaW1pdGVyKSA6IHR5cGUuc2xpY2UoKTtcclxuICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlLmNhbGwodGhpcywgaGFuZGxlciwgbnMsIHRoaXMubGlzdGVuZXJUcmVlLCAwKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHRoaXMuZXZlbnQgPSB0eXBlO1xyXG4gICAgICBzd2l0Y2ggKGFsKSB7XHJcbiAgICAgIGNhc2UgMTpcclxuICAgICAgICBwcm9taXNlcy5wdXNoKGhhbmRsZXIuY2FsbCh0aGlzKSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgMjpcclxuICAgICAgICBwcm9taXNlcy5wdXNoKGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAzOlxyXG4gICAgICAgIHByb21pc2VzLnB1c2goaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgYXJncyA9IG5ldyBBcnJheShhbCAtIDEpO1xyXG4gICAgICAgIGZvciAoaiA9IDE7IGogPCBhbDsgaisrKSBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcclxuICAgICAgICBwcm9taXNlcy5wdXNoKGhhbmRsZXIuYXBwbHkodGhpcywgYXJncykpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGhhbmRsZXIgJiYgaGFuZGxlci5sZW5ndGgpIHtcclxuICAgICAgaWYgKGFsID4gMykge1xyXG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkoYWwgLSAxKTtcclxuICAgICAgICBmb3IgKGogPSAxOyBqIDwgYWw7IGorKykgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XHJcbiAgICAgIH1cclxuICAgICAgZm9yIChpID0gMCwgbCA9IGhhbmRsZXIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudCA9IHR5cGU7XHJcbiAgICAgICAgc3dpdGNoIChhbCkge1xyXG4gICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgIHByb21pc2VzLnB1c2goaGFuZGxlcltpXS5jYWxsKHRoaXMpKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgIHByb21pc2VzLnB1c2goaGFuZGxlcltpXS5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSkpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgcHJvbWlzZXMucHVzaChoYW5kbGVyW2ldLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKGhhbmRsZXJbaV0uYXBwbHkodGhpcywgYXJncykpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICghdGhpcy5fYWxsICYmIHR5cGUgPT09ICdlcnJvcicpIHtcclxuICAgICAgaWYgKGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGFyZ3VtZW50c1sxXSk7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFwiVW5jYXVnaHQsIHVuc3BlY2lmaWVkICdlcnJvcicgZXZlbnQuXCIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcclxuICB9O1xyXG5cclxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcclxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aGlzLm9uQW55KHR5cGUpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignb24gb25seSBhY2NlcHRzIGluc3RhbmNlcyBvZiBGdW5jdGlvbicpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fZXZlbnRzIHx8IGluaXQuY2FsbCh0aGlzKTtcclxuXHJcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09IFwibmV3TGlzdGVuZXJzXCIhIEJlZm9yZVxyXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lcnNcIi5cclxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XHJcblxyXG4gICAgaWYgKHRoaXMud2lsZGNhcmQpIHtcclxuICAgICAgZ3Jvd0xpc3RlbmVyVHJlZS5jYWxsKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pIHtcclxuICAgICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXHJcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5fZXZlbnRzW3R5cGVdID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgLy8gQ2hhbmdlIHRvIGFycmF5LlxyXG4gICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXHJcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcclxuXHJcbiAgICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXHJcbiAgICAgIGlmIChcclxuICAgICAgICAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCAmJlxyXG4gICAgICAgIHRoaXMuX2V2ZW50cy5tYXhMaXN0ZW5lcnMgPiAwICYmXHJcbiAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IHRoaXMuX2V2ZW50cy5tYXhMaXN0ZW5lcnNcclxuICAgICAgKSB7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XHJcbiAgICAgICAgbG9nUG9zc2libGVNZW1vcnlMZWFrLmNhbGwodGhpcywgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCwgdHlwZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uQW55ID0gZnVuY3Rpb24oZm4pIHtcclxuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbkFueSBvbmx5IGFjY2VwdHMgaW5zdGFuY2VzIG9mIEZ1bmN0aW9uJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF0aGlzLl9hbGwpIHtcclxuICAgICAgdGhpcy5fYWxsID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWRkIHRoZSBmdW5jdGlvbiB0byB0aGUgZXZlbnQgbGlzdGVuZXIgY29sbGVjdGlvbi5cclxuICAgIHRoaXMuX2FsbC5wdXNoKGZuKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xyXG5cclxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XHJcbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVtb3ZlTGlzdGVuZXIgb25seSB0YWtlcyBpbnN0YW5jZXMgb2YgRnVuY3Rpb24nKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaGFuZGxlcnMsbGVhZnM9W107XHJcblxyXG4gICAgaWYodGhpcy53aWxkY2FyZCkge1xyXG4gICAgICB2YXIgbnMgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgPyB0eXBlLnNwbGl0KHRoaXMuZGVsaW1pdGVyKSA6IHR5cGUuc2xpY2UoKTtcclxuICAgICAgbGVhZnMgPSBzZWFyY2hMaXN0ZW5lclRyZWUuY2FsbCh0aGlzLCBudWxsLCBucywgdGhpcy5saXN0ZW5lclRyZWUsIDApO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIC8vIGRvZXMgbm90IHVzZSBsaXN0ZW5lcnMoKSwgc28gbm8gc2lkZSBlZmZlY3Qgb2YgY3JlYXRpbmcgX2V2ZW50c1t0eXBlXVxyXG4gICAgICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSkgcmV0dXJuIHRoaXM7XHJcbiAgICAgIGhhbmRsZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG4gICAgICBsZWFmcy5wdXNoKHtfbGlzdGVuZXJzOmhhbmRsZXJzfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yICh2YXIgaUxlYWY9MDsgaUxlYWY8bGVhZnMubGVuZ3RoOyBpTGVhZisrKSB7XHJcbiAgICAgIHZhciBsZWFmID0gbGVhZnNbaUxlYWZdO1xyXG4gICAgICBoYW5kbGVycyA9IGxlYWYuX2xpc3RlbmVycztcclxuICAgICAgaWYgKGlzQXJyYXkoaGFuZGxlcnMpKSB7XHJcblxyXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IC0xO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGlmIChoYW5kbGVyc1tpXSA9PT0gbGlzdGVuZXIgfHxcclxuICAgICAgICAgICAgKGhhbmRsZXJzW2ldLmxpc3RlbmVyICYmIGhhbmRsZXJzW2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikgfHxcclxuICAgICAgICAgICAgKGhhbmRsZXJzW2ldLl9vcmlnaW4gJiYgaGFuZGxlcnNbaV0uX29yaWdpbiA9PT0gbGlzdGVuZXIpKSB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHRoaXMud2lsZGNhcmQpIHtcclxuICAgICAgICAgIGxlYWYuX2xpc3RlbmVycy5zcGxpY2UocG9zaXRpb24sIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5zcGxpY2UocG9zaXRpb24sIDEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGhhbmRsZXJzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgaWYodGhpcy53aWxkY2FyZCkge1xyXG4gICAgICAgICAgICBkZWxldGUgbGVhZi5fbGlzdGVuZXJzO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmVtaXQoXCJyZW1vdmVMaXN0ZW5lclwiLCB0eXBlLCBsaXN0ZW5lcik7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKGhhbmRsZXJzID09PSBsaXN0ZW5lciB8fFxyXG4gICAgICAgIChoYW5kbGVycy5saXN0ZW5lciAmJiBoYW5kbGVycy5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHx8XHJcbiAgICAgICAgKGhhbmRsZXJzLl9vcmlnaW4gJiYgaGFuZGxlcnMuX29yaWdpbiA9PT0gbGlzdGVuZXIpKSB7XHJcbiAgICAgICAgaWYodGhpcy53aWxkY2FyZCkge1xyXG4gICAgICAgICAgZGVsZXRlIGxlYWYuX2xpc3RlbmVycztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5lbWl0KFwicmVtb3ZlTGlzdGVuZXJcIiwgdHlwZSwgbGlzdGVuZXIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlbHlHYXJiYWdlQ29sbGVjdChyb290KSB7XHJcbiAgICAgIGlmIChyb290ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyb290KTtcclxuICAgICAgZm9yICh2YXIgaSBpbiBrZXlzKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XHJcbiAgICAgICAgdmFyIG9iaiA9IHJvb3Rba2V5XTtcclxuICAgICAgICBpZiAoKG9iaiBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB8fCAodHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIikgfHwgKG9iaiA9PT0gbnVsbCkpXHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICBpZiAoT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICByZWN1cnNpdmVseUdhcmJhZ2VDb2xsZWN0KHJvb3Rba2V5XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgZGVsZXRlIHJvb3Rba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJlY3Vyc2l2ZWx5R2FyYmFnZUNvbGxlY3QodGhpcy5saXN0ZW5lclRyZWUpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmQW55ID0gZnVuY3Rpb24oZm4pIHtcclxuICAgIHZhciBpID0gMCwgbCA9IDAsIGZucztcclxuICAgIGlmIChmbiAmJiB0aGlzLl9hbGwgJiYgdGhpcy5fYWxsLmxlbmd0aCA+IDApIHtcclxuICAgICAgZm5zID0gdGhpcy5fYWxsO1xyXG4gICAgICBmb3IoaSA9IDAsIGwgPSBmbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWYoZm4gPT09IGZuc1tpXSkge1xyXG4gICAgICAgICAgZm5zLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgIHRoaXMuZW1pdChcInJlbW92ZUxpc3RlbmVyQW55XCIsIGZuKTtcclxuICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZm5zID0gdGhpcy5fYWxsO1xyXG4gICAgICBmb3IoaSA9IDAsIGwgPSBmbnMubGVuZ3RoOyBpIDwgbDsgaSsrKVxyXG4gICAgICAgIHRoaXMuZW1pdChcInJlbW92ZUxpc3RlbmVyQW55XCIsIGZuc1tpXSk7XHJcbiAgICAgIHRoaXMuX2FsbCA9IFtdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmO1xyXG5cclxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICF0aGlzLl9ldmVudHMgfHwgaW5pdC5jYWxsKHRoaXMpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy53aWxkY2FyZCkge1xyXG4gICAgICB2YXIgbnMgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgPyB0eXBlLnNwbGl0KHRoaXMuZGVsaW1pdGVyKSA6IHR5cGUuc2xpY2UoKTtcclxuICAgICAgdmFyIGxlYWZzID0gc2VhcmNoTGlzdGVuZXJUcmVlLmNhbGwodGhpcywgbnVsbCwgbnMsIHRoaXMubGlzdGVuZXJUcmVlLCAwKTtcclxuXHJcbiAgICAgIGZvciAodmFyIGlMZWFmPTA7IGlMZWFmPGxlYWZzLmxlbmd0aDsgaUxlYWYrKykge1xyXG4gICAgICAgIHZhciBsZWFmID0gbGVhZnNbaUxlYWZdO1xyXG4gICAgICAgIGxlYWYuX2xpc3RlbmVycyA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50cykge1xyXG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XHJcbiAgICBpZiAodGhpcy53aWxkY2FyZCkge1xyXG4gICAgICB2YXIgaGFuZGxlcnMgPSBbXTtcclxuICAgICAgdmFyIG5zID0gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnID8gdHlwZS5zcGxpdCh0aGlzLmRlbGltaXRlcikgOiB0eXBlLnNsaWNlKCk7XHJcbiAgICAgIHNlYXJjaExpc3RlbmVyVHJlZS5jYWxsKHRoaXMsIGhhbmRsZXJzLCBucywgdGhpcy5saXN0ZW5lclRyZWUsIDApO1xyXG4gICAgICByZXR1cm4gaGFuZGxlcnM7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fZXZlbnRzIHx8IGluaXQuY2FsbCh0aGlzKTtcclxuXHJcbiAgICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSkgdGhpcy5fZXZlbnRzW3R5cGVdID0gW107XHJcbiAgICBpZiAoIWlzQXJyYXkodGhpcy5fZXZlbnRzW3R5cGVdKSkge1xyXG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLl9ldmVudHNbdHlwZV07XHJcbiAgfTtcclxuXHJcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xyXG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcclxuICB9O1xyXG5cclxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyc0FueSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIGlmKHRoaXMuX2FsbCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fYWxsO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuXHJcbiAgfTtcclxuXHJcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cclxuICAgIGRlZmluZShmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIEV2ZW50RW1pdHRlcjtcclxuICAgIH0pO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAvLyBDb21tb25KU1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XHJcbiAgfVxyXG4gIGVsc2Uge1xyXG4gICAgLy8gQnJvd3NlciBnbG9iYWwuXHJcbiAgICB3aW5kb3cuRXZlbnRFbWl0dGVyMiA9IEV2ZW50RW1pdHRlcjtcclxuICB9XHJcbn0oKTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBJbnRlbnRpb25hbGx5IHVzZSBuYXRpdmUtcHJvbWlzZS1vbmx5IGhlcmUuLi4gT3RoZXIgcHJvbWlzZSBsaWJyYXJpZXMgKGVzNi1wcm9taXNlKVxuLy8gZHVjay1wdW5jaCB0aGUgZ2xvYmFsIFByb21pc2UgZGVmaW5pdGlvbiB3aGljaCBtZXNzZXMgdXAgQW5ndWxhciAyIHNpbmNlIGl0XG4vLyBhbHNvIGR1Y2stcHVuY2hlcyB0aGUgZ2xvYmFsIFByb21pc2UgZGVmaW5pdGlvbi4gRm9yIG5vdywga2VlcCBuYXRpdmUtcHJvbWlzZS1vbmx5LlxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBQcm9taXNlID0gcmVxdWlyZShcIm5hdGl2ZS1wcm9taXNlLW9ubHlcIik7XG5yZXF1aXJlKCd3aGF0d2ctZmV0Y2gnKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudGVtaXR0ZXIyJykuRXZlbnRFbWl0dGVyMjtcbnZhciBjb3B5ID0gcmVxdWlyZSgnc2hhbGxvdy1jb3B5Jyk7XG5cbi8qKlxuICogVGhlIEZvcm1pbyBpbnRlcmZhY2UgY2xhc3MuXG4gKlxuICogICBsZXQgZm9ybWlvID0gbmV3IEZvcm1pbygnaHR0cHM6Ly9leGFtcGxlcy5mb3JtLmlvL2V4YW1wbGUnKTtcbiAqL1xuXG52YXIgRm9ybWlvID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGb3JtaW8ocGF0aCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRm9ybWlvKTtcblxuICAgIC8vIEVuc3VyZSB3ZSBoYXZlIGFuIGluc3RhbmNlIG9mIEZvcm1pby5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRm9ybWlvKSkge1xuICAgICAgcmV0dXJuIG5ldyBGb3JtaW8ocGF0aCk7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBvdXIgdmFyaWFibGVzLlxuICAgIHRoaXMuYmFzZSA9ICcnO1xuICAgIHRoaXMucHJvamVjdHNVcmwgPSAnJztcbiAgICB0aGlzLnByb2plY3RVcmwgPSAnJztcbiAgICB0aGlzLnByb2plY3RJZCA9ICcnO1xuICAgIHRoaXMuZm9ybVVybCA9ICcnO1xuICAgIHRoaXMuZm9ybXNVcmwgPSAnJztcbiAgICB0aGlzLmZvcm1JZCA9ICcnO1xuICAgIHRoaXMuc3VibWlzc2lvbnNVcmwgPSAnJztcbiAgICB0aGlzLnN1Ym1pc3Npb25VcmwgPSAnJztcbiAgICB0aGlzLnN1Ym1pc3Npb25JZCA9ICcnO1xuICAgIHRoaXMuYWN0aW9uc1VybCA9ICcnO1xuICAgIHRoaXMuYWN0aW9uSWQgPSAnJztcbiAgICB0aGlzLmFjdGlvblVybCA9ICcnO1xuICAgIHRoaXMucXVlcnkgPSAnJztcblxuICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KCdiYXNlJykpIHtcbiAgICAgIHRoaXMuYmFzZSA9IG9wdGlvbnMuYmFzZTtcbiAgICB9IGVsc2UgaWYgKEZvcm1pby5iYXNlVXJsKSB7XG4gICAgICB0aGlzLmJhc2UgPSBGb3JtaW8uYmFzZVVybDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5iYXNlID0gd2luZG93LmxvY2F0aW9uLmhyZWYubWF0Y2goL2h0dHBbc10/OlxcL1xcL2FwaS4vKVswXTtcbiAgICB9XG5cbiAgICBpZiAoIXBhdGgpIHtcbiAgICAgIC8vIEFsbG93IHVzZXIgdG8gY3JlYXRlIG5ldyBwcm9qZWN0cyBpZiB0aGlzIHdhcyBpbnN0YW50aWF0ZWQgd2l0aG91dFxuICAgICAgLy8gYSB1cmxcbiAgICAgIHRoaXMucHJvamVjdFVybCA9IHRoaXMuYmFzZSArICcvcHJvamVjdCc7XG4gICAgICB0aGlzLnByb2plY3RzVXJsID0gdGhpcy5iYXNlICsgJy9wcm9qZWN0JztcbiAgICAgIHRoaXMucHJvamVjdElkID0gZmFsc2U7XG4gICAgICB0aGlzLnF1ZXJ5ID0gJyc7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3Byb2plY3QnKSkge1xuICAgICAgdGhpcy5wcm9qZWN0VXJsID0gb3B0aW9ucy5wcm9qZWN0O1xuICAgIH1cblxuICAgIHZhciBwcm9qZWN0ID0gdGhpcy5wcm9qZWN0VXJsIHx8IEZvcm1pby5wcm9qZWN0VXJsO1xuXG4gICAgLy8gVGhlIGJhc2VVUkwgaXMgdGhlIHNhbWUgYXMgdGhlIHByb2plY3RVcmwuIFRoaXMgaXMgYWxtb3N0IGNlcnRhaW5seSBhZ2FpbnN0XG4gICAgLy8gdGhlIE9wZW4gU291cmNlIHNlcnZlci5cbiAgICBpZiAocHJvamVjdCAmJiB0aGlzLmJhc2UgPT09IHByb2plY3QpIHtcbiAgICAgIHRoaXMubm9Qcm9qZWN0ID0gdHJ1ZTtcbiAgICAgIHRoaXMucHJvamVjdFVybCA9IHRoaXMuYmFzZTtcbiAgICB9XG5cbiAgICAvLyBOb3JtYWxpemUgdG8gYW4gYWJzb2x1dGUgcGF0aC5cbiAgICBpZiAocGF0aC5pbmRleE9mKCdodHRwJykgIT09IDAgJiYgcGF0aC5pbmRleE9mKCcvLycpICE9PSAwKSB7XG4gICAgICBwYXRoID0gdGhpcy5iYXNlICsgcGF0aDtcbiAgICB9XG5cbiAgICB2YXIgaG9zdHBhcnRzID0gRm9ybWlvLmdldFVybFBhcnRzKHBhdGgpO1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgIHZhciBob3N0TmFtZSA9IGhvc3RwYXJ0c1sxXSArIGhvc3RwYXJ0c1syXTtcbiAgICBwYXRoID0gaG9zdHBhcnRzLmxlbmd0aCA+IDMgPyBob3N0cGFydHNbM10gOiAnJztcbiAgICB2YXIgcXVlcnlwYXJ0cyA9IHBhdGguc3BsaXQoJz8nKTtcbiAgICBpZiAocXVlcnlwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICBwYXRoID0gcXVlcnlwYXJ0c1swXTtcbiAgICAgIHRoaXMucXVlcnkgPSAnPycgKyBxdWVyeXBhcnRzWzFdO1xuICAgIH1cblxuICAgIC8vIFJlZ2lzdGVyIGEgc3BlY2lmaWMgcGF0aC5cbiAgICB2YXIgcmVnaXN0ZXJQYXRoID0gZnVuY3Rpb24gcmVnaXN0ZXJQYXRoKG5hbWUsIGJhc2UpIHtcbiAgICAgIF90aGlzW25hbWUgKyAnc1VybCddID0gYmFzZSArICcvJyArIG5hbWU7XG4gICAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKCdcXC8nICsgbmFtZSArICdcXC8oW14vXSspJyk7XG4gICAgICBpZiAocGF0aC5zZWFyY2gocmVnZXgpICE9PSAtMSkge1xuICAgICAgICBwYXJ0cyA9IHBhdGgubWF0Y2gocmVnZXgpO1xuICAgICAgICBfdGhpc1tuYW1lICsgJ1VybCddID0gcGFydHMgPyBiYXNlICsgcGFydHNbMF0gOiAnJztcbiAgICAgICAgX3RoaXNbbmFtZSArICdJZCddID0gcGFydHMubGVuZ3RoID4gMSA/IHBhcnRzWzFdIDogJyc7XG4gICAgICAgIGJhc2UgKz0gcGFydHNbMF07XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZTtcbiAgICB9O1xuXG4gICAgLy8gUmVnaXN0ZXIgYW4gYXJyYXkgb2YgaXRlbXMuXG4gICAgdmFyIHJlZ2lzdGVySXRlbXMgPSBmdW5jdGlvbiByZWdpc3Rlckl0ZW1zKGl0ZW1zLCBiYXNlLCBzdGF0aWNCYXNlKSB7XG4gICAgICBmb3IgKHZhciBpIGluIGl0ZW1zKSB7XG4gICAgICAgIGlmIChpdGVtcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgIHZhciBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgcmVnaXN0ZXJJdGVtcyhpdGVtLCBiYXNlLCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG5ld0Jhc2UgPSByZWdpc3RlclBhdGgoaXRlbSwgYmFzZSk7XG4gICAgICAgICAgICBiYXNlID0gc3RhdGljQmFzZSA/IGJhc2UgOiBuZXdCYXNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoIXRoaXMucHJvamVjdFVybCB8fCB0aGlzLnByb2plY3RVcmwgPT09IHRoaXMuYmFzZSkge1xuICAgICAgdGhpcy5wcm9qZWN0VXJsID0gaG9zdE5hbWU7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm5vUHJvamVjdCkge1xuICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBwcm9qZWN0VXJsIGFuZCBwcm9qZWN0SWRcbiAgICAgIGlmIChwYXRoLnNlYXJjaCgvKF58XFwvKShwcm9qZWN0KSgkfFxcLykvKSAhPT0gLTEpIHtcbiAgICAgICAgLy8gR2V0IHByb2plY3QgaWQgYXMgcHJvamVjdC86cHJvamVjdElkLlxuICAgICAgICByZWdpc3Rlckl0ZW1zKFsncHJvamVjdCddLCBob3N0TmFtZSk7XG4gICAgICB9IGVsc2UgaWYgKGhvc3ROYW1lID09PSB0aGlzLmJhc2UpIHtcbiAgICAgICAgLy8gR2V0IHByb2plY3QgaWQgYXMgZmlyc3QgcGFydCBvZiBwYXRoIChzdWJkaXJlY3RvcnkpLlxuICAgICAgICBpZiAoaG9zdHBhcnRzLmxlbmd0aCA+IDMgJiYgcGF0aC5zcGxpdCgnLycpLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB2YXIgcGF0aFBhcnRzID0gcGF0aC5zcGxpdCgnLycpO1xuICAgICAgICAgIHBhdGhQYXJ0cy5zaGlmdCgpOyAvLyBUaHJvdyBhd2F5IHRoZSBmaXJzdCAvLlxuICAgICAgICAgIHRoaXMucHJvamVjdElkID0gcGF0aFBhcnRzLnNoaWZ0KCk7XG4gICAgICAgICAgcGF0aCA9ICcvJyArIHBhdGhQYXJ0cy5qb2luKCcvJyk7XG4gICAgICAgICAgdGhpcy5wcm9qZWN0VXJsID0gaG9zdE5hbWUgKyAnLycgKyB0aGlzLnByb2plY3RJZDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gR2V0IHByb2plY3QgaWQgZnJvbSBzdWJkb21haW4uXG4gICAgICAgIGlmIChob3N0cGFydHMubGVuZ3RoID4gMiAmJiAoaG9zdHBhcnRzWzJdLnNwbGl0KCcuJykubGVuZ3RoID4gMiB8fCBob3N0TmFtZS5pbmRleE9mKCdsb2NhbGhvc3QnKSAhPT0gLTEpKSB7XG4gICAgICAgICAgdGhpcy5wcm9qZWN0VXJsID0gaG9zdE5hbWU7XG4gICAgICAgICAgdGhpcy5wcm9qZWN0SWQgPSBob3N0cGFydHNbMl0uc3BsaXQoJy4nKVswXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5wcm9qZWN0c1VybCA9IHRoaXMucHJvamVjdHNVcmwgfHwgdGhpcy5iYXNlICsgJy9wcm9qZWN0JztcbiAgICB9XG5cbiAgICAvLyBDb25maWd1cmUgRm9ybSB1cmxzIGFuZCBmb3JtIGlkcy5cbiAgICBpZiAocGF0aC5zZWFyY2goLyhefFxcLykocHJvamVjdHxmb3JtKSgkfFxcLykvKSAhPT0gLTEpIHtcbiAgICAgIHJlZ2lzdGVySXRlbXMoWydmb3JtJywgWydzdWJtaXNzaW9uJywgJ2FjdGlvbiddXSwgdGhpcy5wcm9qZWN0VXJsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN1YlJlZ0V4ID0gbmV3IFJlZ0V4cCgnXFwvKHN1Ym1pc3Npb258YWN0aW9uKSgkfFxcLy4qKScpO1xuICAgICAgdmFyIHN1YnMgPSBwYXRoLm1hdGNoKHN1YlJlZ0V4KTtcbiAgICAgIHRoaXMucGF0aFR5cGUgPSBzdWJzICYmIHN1YnMubGVuZ3RoID4gMSA/IHN1YnNbMV0gOiAnJztcbiAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2Uoc3ViUmVnRXgsICcnKTtcbiAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG4gICAgICB0aGlzLmZvcm1zVXJsID0gdGhpcy5wcm9qZWN0VXJsICsgJy9mb3JtJztcbiAgICAgIHRoaXMuZm9ybVVybCA9IHRoaXMucHJvamVjdFVybCArIHBhdGg7XG4gICAgICB0aGlzLmZvcm1JZCA9IHBhdGgucmVwbGFjZSgvXlxcLyt8XFwvKyQvZywgJycpO1xuICAgICAgdmFyIGl0ZW1zID0gWydzdWJtaXNzaW9uJywgJ2FjdGlvbiddO1xuICAgICAgZm9yICh2YXIgaSBpbiBpdGVtcykge1xuICAgICAgICBpZiAoaXRlbXMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICAgIHRoaXNbaXRlbSArICdzVXJsJ10gPSB0aGlzLnByb2plY3RVcmwgKyBwYXRoICsgJy8nICsgaXRlbTtcbiAgICAgICAgICBpZiAodGhpcy5wYXRoVHlwZSA9PT0gaXRlbSAmJiBzdWJzLmxlbmd0aCA+IDIgJiYgc3Vic1syXSkge1xuICAgICAgICAgICAgdGhpc1tpdGVtICsgJ0lkJ10gPSBzdWJzWzJdLnJlcGxhY2UoL15cXC8rfFxcLyskL2csICcnKTtcbiAgICAgICAgICAgIHRoaXNbaXRlbSArICdVcmwnXSA9IHRoaXMucHJvamVjdFVybCArIHBhdGggKyBzdWJzWzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldCB0aGUgYXBwIHVybCBpZiBpdCBpcyBub3Qgc2V0LlxuICAgIGlmICghRm9ybWlvLnByb2plY3RVcmxTZXQpIHtcbiAgICAgIEZvcm1pby5wcm9qZWN0VXJsID0gdGhpcy5wcm9qZWN0VXJsO1xuICAgIH1cbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhGb3JtaW8sIFt7XG4gICAga2V5OiAnZGVsZXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlbGV0ZSh0eXBlLCBvcHRzKSB7XG4gICAgICB2YXIgX2lkID0gdHlwZSArICdJZCc7XG4gICAgICB2YXIgX3VybCA9IHR5cGUgKyAnVXJsJztcbiAgICAgIGlmICghdGhpc1tfaWRdKSB7XG4gICAgICAgIFByb21pc2UucmVqZWN0KCdOb3RoaW5nIHRvIGRlbGV0ZScpO1xuICAgICAgfVxuICAgICAgRm9ybWlvLmNhY2hlID0ge307XG4gICAgICByZXR1cm4gdGhpcy5tYWtlUmVxdWVzdCh0eXBlLCB0aGlzW191cmxdLCAnZGVsZXRlJywgbnVsbCwgb3B0cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW5kZXgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmRleCh0eXBlLCBxdWVyeSwgb3B0cykge1xuICAgICAgdmFyIF91cmwgPSB0eXBlICsgJ1VybCc7XG4gICAgICBxdWVyeSA9IHF1ZXJ5IHx8ICcnO1xuICAgICAgaWYgKHF1ZXJ5ICYmICh0eXBlb2YgcXVlcnkgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHF1ZXJ5KSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHF1ZXJ5ID0gJz8nICsgRm9ybWlvLnNlcmlhbGl6ZShxdWVyeS5wYXJhbXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubWFrZVJlcXVlc3QodHlwZSwgdGhpc1tfdXJsXSArIHF1ZXJ5LCAnZ2V0JywgbnVsbCwgb3B0cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2F2ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNhdmUodHlwZSwgZGF0YSwgb3B0cykge1xuICAgICAgdmFyIF9pZCA9IHR5cGUgKyAnSWQnO1xuICAgICAgdmFyIF91cmwgPSB0eXBlICsgJ1VybCc7XG4gICAgICB2YXIgbWV0aG9kID0gdGhpc1tfaWRdIHx8IGRhdGEuX2lkID8gJ3B1dCcgOiAncG9zdCc7XG4gICAgICB2YXIgcmVxVXJsID0gdGhpc1tfaWRdID8gdGhpc1tfdXJsXSA6IHRoaXNbdHlwZSArICdzVXJsJ107XG4gICAgICBpZiAoIXRoaXNbX2lkXSAmJiBkYXRhLl9pZCAmJiBtZXRob2QgPT09ICdwdXQnICYmIHJlcVVybC5pbmRleE9mKGRhdGEuX2lkKSA9PT0gLTEpIHtcbiAgICAgICAgcmVxVXJsICs9ICcvJyArIGRhdGEuX2lkO1xuICAgICAgfVxuICAgICAgRm9ybWlvLmNhY2hlID0ge307XG4gICAgICByZXR1cm4gdGhpcy5tYWtlUmVxdWVzdCh0eXBlLCByZXFVcmwgKyB0aGlzLnF1ZXJ5LCBtZXRob2QsIGRhdGEsIG9wdHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xvYWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkKHR5cGUsIHF1ZXJ5LCBvcHRzKSB7XG4gICAgICB2YXIgX2lkID0gdHlwZSArICdJZCc7XG4gICAgICB2YXIgX3VybCA9IHR5cGUgKyAnVXJsJztcbiAgICAgIGlmIChxdWVyeSAmJiAodHlwZW9mIHF1ZXJ5ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihxdWVyeSkpID09PSAnb2JqZWN0Jykge1xuICAgICAgICBxdWVyeSA9IEZvcm1pby5zZXJpYWxpemUocXVlcnkucGFyYW1zKTtcbiAgICAgIH1cbiAgICAgIGlmIChxdWVyeSkge1xuICAgICAgICBxdWVyeSA9IHRoaXMucXVlcnkgPyB0aGlzLnF1ZXJ5ICsgJyYnICsgcXVlcnkgOiAnPycgKyBxdWVyeTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXJ5ID0gdGhpcy5xdWVyeTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpc1tfaWRdKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnTWlzc2luZyAnICsgX2lkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm1ha2VSZXF1ZXN0KHR5cGUsIHRoaXNbX3VybF0gKyBxdWVyeSwgJ2dldCcsIG51bGwsIG9wdHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ21ha2VSZXF1ZXN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFrZVJlcXVlc3QodHlwZSwgdXJsLCBtZXRob2QsIGRhdGEsIG9wdHMpIHtcbiAgICAgIG1ldGhvZCA9IChtZXRob2QgfHwgJ0dFVCcpLnRvVXBwZXJDYXNlKCk7XG4gICAgICBpZiAoIW9wdHMgfHwgKHR5cGVvZiBvcHRzID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvcHRzKSkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIG9wdHMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlcXVlc3RBcmdzID0ge1xuICAgICAgICBmb3JtaW86IHRoaXMsXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIHVybDogdXJsLFxuICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgb3B0czogb3B0c1xuICAgICAgfTtcblxuICAgICAgdmFyIHJlcXVlc3QgPSBGb3JtaW8ucGx1Z2luV2FpdCgncHJlUmVxdWVzdCcsIHJlcXVlc3RBcmdzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEZvcm1pby5wbHVnaW5HZXQoJ3JlcXVlc3QnLCByZXF1ZXN0QXJncykudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIEZvcm1pby5yZXF1ZXN0KHVybCwgbWV0aG9kLCBkYXRhLCBvcHRzLmhlYWRlciwgb3B0cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBGb3JtaW8ucGx1Z2luQWx0ZXIoJ3dyYXBSZXF1ZXN0UHJvbWlzZScsIHJlcXVlc3QsIHJlcXVlc3RBcmdzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsb2FkUHJvamVjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWRQcm9qZWN0KHF1ZXJ5LCBvcHRzKSB7XG4gICAgICByZXR1cm4gdGhpcy5sb2FkKCdwcm9qZWN0JywgcXVlcnksIG9wdHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NhdmVQcm9qZWN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2F2ZVByb2plY3QoZGF0YSwgb3B0cykge1xuICAgICAgcmV0dXJuIHRoaXMuc2F2ZSgncHJvamVjdCcsIGRhdGEsIG9wdHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RlbGV0ZVByb2plY3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVQcm9qZWN0KG9wdHMpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlbGV0ZSgncHJvamVjdCcsIG9wdHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xvYWRGb3JtJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZEZvcm0ocXVlcnksIG9wdHMpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvYWQoJ2Zvcm0nLCBxdWVyeSwgb3B0cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2F2ZUZvcm0nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzYXZlRm9ybShkYXRhLCBvcHRzKSB7XG4gICAgICByZXR1cm4gdGhpcy5zYXZlKCdmb3JtJywgZGF0YSwgb3B0cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVsZXRlRm9ybScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZUZvcm0ob3B0cykge1xuICAgICAgcmV0dXJuIHRoaXMuZGVsZXRlKCdmb3JtJywgb3B0cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbG9hZEZvcm1zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZEZvcm1zKHF1ZXJ5LCBvcHRzKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmRleCgnZm9ybXMnLCBxdWVyeSwgb3B0cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbG9hZFN1Ym1pc3Npb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkU3VibWlzc2lvbihxdWVyeSwgb3B0cykge1xuICAgICAgcmV0dXJuIHRoaXMubG9hZCgnc3VibWlzc2lvbicsIHF1ZXJ5LCBvcHRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzYXZlU3VibWlzc2lvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNhdmVTdWJtaXNzaW9uKGRhdGEsIG9wdHMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNhdmUoJ3N1Ym1pc3Npb24nLCBkYXRhLCBvcHRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZWxldGVTdWJtaXNzaW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlU3VibWlzc2lvbihvcHRzKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWxldGUoJ3N1Ym1pc3Npb24nLCBvcHRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsb2FkU3VibWlzc2lvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkU3VibWlzc2lvbnMocXVlcnksIG9wdHMpIHtcbiAgICAgIHJldHVybiB0aGlzLmluZGV4KCdzdWJtaXNzaW9ucycsIHF1ZXJ5LCBvcHRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsb2FkQWN0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZEFjdGlvbihxdWVyeSwgb3B0cykge1xuICAgICAgcmV0dXJuIHRoaXMubG9hZCgnYWN0aW9uJywgcXVlcnksIG9wdHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NhdmVBY3Rpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzYXZlQWN0aW9uKGRhdGEsIG9wdHMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNhdmUoJ2FjdGlvbicsIGRhdGEsIG9wdHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RlbGV0ZUFjdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZUFjdGlvbihvcHRzKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWxldGUoJ2FjdGlvbicsIG9wdHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xvYWRBY3Rpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZEFjdGlvbnMocXVlcnksIG9wdHMpIHtcbiAgICAgIHJldHVybiB0aGlzLmluZGV4KCdhY3Rpb25zJywgcXVlcnksIG9wdHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2F2YWlsYWJsZUFjdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdmFpbGFibGVBY3Rpb25zKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWFrZVJlcXVlc3QoJ2F2YWlsYWJsZUFjdGlvbnMnLCB0aGlzLmZvcm1VcmwgKyAnL2FjdGlvbnMnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhY3Rpb25JbmZvJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWN0aW9uSW5mbyhuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYWtlUmVxdWVzdCgnYWN0aW9uSW5mbycsIHRoaXMuZm9ybVVybCArICcvYWN0aW9ucy8nICsgbmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHRlbXBvcmFyeSBhdXRoZW50aWNhdGlvbiB0b2tlbiBmb3Igc2luZ2xlIHB1cnBvc2UgdG9rZW4gZ2VuZXJhdGlvbi5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0VGVtcFRva2VuJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGVtcFRva2VuKGV4cGlyZSwgYWxsb3dlZCkge1xuICAgICAgdmFyIHRva2VuID0gRm9ybWlvLmdldFRva2VuKCk7XG4gICAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnWW91IG11c3QgYmUgYXV0aGVudGljYXRlZCB0byBnZW5lcmF0ZSBhIHRlbXBvcmFyeSBhdXRoIHRva2VuLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubWFrZVJlcXVlc3QoJ3RlbXBUb2tlbicsIHRoaXMucHJvamVjdFVybCArICcvdG9rZW4nLCAnR0VUJywgbnVsbCwge1xuICAgICAgICBoZWFkZXI6IG5ldyBIZWFkZXJzKHtcbiAgICAgICAgICAneC1leHBpcmUnOiBleHBpcmUsXG4gICAgICAgICAgJ3gtYWxsb3cnOiBhbGxvd2VkXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1cGxvYWRGaWxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBsb2FkRmlsZShzdG9yYWdlLCBmaWxlLCBmaWxlTmFtZSwgZGlyLCBwcm9ncmVzc0NhbGxiYWNrLCB1cmwpIHtcbiAgICAgIHZhciByZXF1ZXN0QXJncyA9IHtcbiAgICAgICAgcHJvdmlkZXI6IHN0b3JhZ2UsXG4gICAgICAgIG1ldGhvZDogJ3VwbG9hZCcsXG4gICAgICAgIGZpbGU6IGZpbGUsXG4gICAgICAgIGZpbGVOYW1lOiBmaWxlTmFtZSxcbiAgICAgICAgZGlyOiBkaXJcbiAgICAgIH07XG4gICAgICB2YXIgcmVxdWVzdCA9IEZvcm1pby5wbHVnaW5XYWl0KCdwcmVSZXF1ZXN0JywgcmVxdWVzdEFyZ3MpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gRm9ybWlvLnBsdWdpbkdldCgnZmlsZVJlcXVlc3QnLCByZXF1ZXN0QXJncykudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgaWYgKHN0b3JhZ2UgJiYgKHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIGlmIChGb3JtaW8ucHJvdmlkZXJzLnN0b3JhZ2UuaGFzT3duUHJvcGVydHkoc3RvcmFnZSkpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3ZpZGVyID0gbmV3IEZvcm1pby5wcm92aWRlcnMuc3RvcmFnZVtzdG9yYWdlXSh0aGlzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLnVwbG9hZEZpbGUoZmlsZSwgZmlsZU5hbWUsIGRpciwgcHJvZ3Jlc3NDYWxsYmFjaywgdXJsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93ICdTdG9yYWdlIHByb3ZpZGVyIG5vdCBmb3VuZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQgfHwgeyB1cmw6ICcnIH07XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICByZXR1cm4gRm9ybWlvLnBsdWdpbkFsdGVyKCd3cmFwRmlsZVJlcXVlc3RQcm9taXNlJywgcmVxdWVzdCwgcmVxdWVzdEFyZ3MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rvd25sb2FkRmlsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvd25sb2FkRmlsZShmaWxlKSB7XG4gICAgICB2YXIgcmVxdWVzdEFyZ3MgPSB7XG4gICAgICAgIG1ldGhvZDogJ2Rvd25sb2FkJyxcbiAgICAgICAgZmlsZTogZmlsZVxuICAgICAgfTtcblxuICAgICAgdmFyIHJlcXVlc3QgPSBGb3JtaW8ucGx1Z2luV2FpdCgncHJlUmVxdWVzdCcsIHJlcXVlc3RBcmdzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEZvcm1pby5wbHVnaW5HZXQoJ2ZpbGVSZXF1ZXN0JywgcmVxdWVzdEFyZ3MpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgIGlmIChmaWxlLnN0b3JhZ2UgJiYgKHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIGlmIChGb3JtaW8ucHJvdmlkZXJzLnN0b3JhZ2UuaGFzT3duUHJvcGVydHkoZmlsZS5zdG9yYWdlKSkge1xuICAgICAgICAgICAgICB2YXIgcHJvdmlkZXIgPSBuZXcgRm9ybWlvLnByb3ZpZGVycy5zdG9yYWdlW2ZpbGUuc3RvcmFnZV0odGhpcyk7XG4gICAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5kb3dubG9hZEZpbGUoZmlsZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyAnU3RvcmFnZSBwcm92aWRlciBub3QgZm91bmQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0IHx8IHsgdXJsOiAnJyB9O1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgcmV0dXJuIEZvcm1pby5wbHVnaW5BbHRlcignd3JhcEZpbGVSZXF1ZXN0UHJvbWlzZScsIHJlcXVlc3QsIHJlcXVlc3RBcmdzKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ2xvYWRQcm9qZWN0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWRQcm9qZWN0cyhxdWVyeSwgb3B0cykge1xuICAgICAgcXVlcnkgPSBxdWVyeSB8fCAnJztcbiAgICAgIGlmICgodHlwZW9mIHF1ZXJ5ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihxdWVyeSkpID09PSAnb2JqZWN0Jykge1xuICAgICAgICBxdWVyeSA9ICc/JyArIHNlcmlhbGl6ZShxdWVyeS5wYXJhbXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEZvcm1pby5tYWtlU3RhdGljUmVxdWVzdChGb3JtaW8uYmFzZVVybCArICcvcHJvamVjdCcgKyBxdWVyeSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0VXJsUGFydHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRVcmxQYXJ0cyh1cmwpIHtcbiAgICAgIHZhciByZWdleCA9ICdeKGh0dHBbc10/OlxcXFwvXFxcXC8pJztcbiAgICAgIGlmICh0aGlzLmJhc2UgJiYgdXJsLmluZGV4T2YodGhpcy5iYXNlKSA9PT0gMCkge1xuICAgICAgICByZWdleCArPSAnKCcgKyB0aGlzLmJhc2UucmVwbGFjZSgvXmh0dHBbc10/OlxcL1xcLy8sICcnKSArICcpJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZ2V4ICs9ICcoW14vXSspJztcbiAgICAgIH1cbiAgICAgIHJlZ2V4ICs9ICcoJHxcXFxcLy4qKSc7XG4gICAgICByZXR1cm4gdXJsLm1hdGNoKG5ldyBSZWdFeHAocmVnZXgpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXJpYWxpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUob2JqKSB7XG4gICAgICB2YXIgc3RyID0gW107XG4gICAgICBmb3IgKHZhciBwIGluIG9iaikge1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgICAgc3RyLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KHApICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQob2JqW3BdKSk7XG4gICAgICAgIH1cbiAgICAgIH1yZXR1cm4gc3RyLmpvaW4oXCImXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ21ha2VTdGF0aWNSZXF1ZXN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFrZVN0YXRpY1JlcXVlc3QodXJsLCBtZXRob2QsIGRhdGEsIG9wdHMpIHtcbiAgICAgIG1ldGhvZCA9IChtZXRob2QgfHwgJ0dFVCcpLnRvVXBwZXJDYXNlKCk7XG4gICAgICBpZiAoIW9wdHMgfHwgKHR5cGVvZiBvcHRzID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvcHRzKSkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIG9wdHMgPSB7fTtcbiAgICAgIH1cbiAgICAgIHZhciByZXF1ZXN0QXJncyA9IHtcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9O1xuXG4gICAgICB2YXIgcmVxdWVzdCA9IEZvcm1pby5wbHVnaW5XYWl0KCdwcmVSZXF1ZXN0JywgcmVxdWVzdEFyZ3MpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gRm9ybWlvLnBsdWdpbkdldCgnc3RhdGljUmVxdWVzdCcsIHJlcXVlc3RBcmdzKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gRm9ybWlvLnJlcXVlc3QodXJsLCBtZXRob2QsIGRhdGEsIG9wdHMuaGVhZGVyLCBvcHRzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIEZvcm1pby5wbHVnaW5BbHRlcignd3JhcFN0YXRpY1JlcXVlc3RQcm9taXNlJywgcmVxdWVzdCwgcmVxdWVzdEFyZ3MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlcXVlc3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXF1ZXN0KHVybCwgbWV0aG9kLCBkYXRhLCBoZWFkZXIsIG9wdHMpIHtcbiAgICAgIGlmICghdXJsKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnTm8gdXJsIHByb3ZpZGVkJyk7XG4gICAgICB9XG4gICAgICBtZXRob2QgPSAobWV0aG9kIHx8ICdHRVQnKS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAvLyBGb3IgcmV2ZXJzZSBjb21wYXRpYmlsaXR5LCBpZiB0aGV5IHByb3ZpZGVkIHRoZSBpZ25vcmVDYWNoZSBwYXJhbWV0ZXIsXG4gICAgICAvLyB0aGVuIGNoYW5nZSBpdCBiYWNrIHRvIHRoZSBvcHRpb25zIGZvcm1hdCB3aGVyZSB0aGF0IGlzIGEgcGFyYW1ldGVyLlxuICAgICAgaWYgKHR5cGVvZiBvcHRzID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgb3B0cyA9IHsgaWdub3JlQ2FjaGU6IG9wdHMgfTtcbiAgICAgIH1cbiAgICAgIGlmICghb3B0cyB8fCAodHlwZW9mIG9wdHMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9wdHMpKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgb3B0cyA9IHt9O1xuICAgICAgfVxuXG4gICAgICB2YXIgY2FjaGVLZXkgPSBidG9hKHVybCk7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIC8vIEdldCB0aGUgY2FjaGVkIHByb21pc2UgdG8gc2F2ZSBtdWx0aXBsZSBsb2Fkcy5cbiAgICAgICAgaWYgKCFvcHRzLmlnbm9yZUNhY2hlICYmIG1ldGhvZCA9PT0gJ0dFVCcgJiYgRm9ybWlvLmNhY2hlLmhhc093blByb3BlcnR5KGNhY2hlS2V5KSkge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKEZvcm1pby5jYWNoZVtjYWNoZUtleV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlcXVlc3RUb2tlbiA9ICcnO1xuICAgICAgICByZXNvbHZlKG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAvLyBTZXQgdXAgYW5kIGZldGNoIHJlcXVlc3RcbiAgICAgICAgICB2YXIgaGVhZGVycyA9IGhlYWRlciB8fCBuZXcgSGVhZGVycyh7XG4gICAgICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgJ0NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PVVURi04J1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciB0b2tlbiA9IEZvcm1pby5nZXRUb2tlbigpO1xuICAgICAgICAgIGlmICh0b2tlbiAmJiAhb3B0cy5ub1Rva2VuKSB7XG4gICAgICAgICAgICBoZWFkZXJzLmFwcGVuZCgneC1qd3QtdG9rZW4nLCB0b2tlbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgICBtb2RlOiAnY29ycydcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICBvcHRpb25zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXF1ZXN0VG9rZW4gPSBoZWFkZXJzLmdldCgneC1qd3QtdG9rZW4nKTtcbiAgICAgICAgICByZXNvbHZlKGZldGNoKHVybCwgb3B0aW9ucykpO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgZXJyLm1lc3NhZ2UgPSAnQ291bGQgbm90IGNvbm5lY3QgdG8gQVBJIHNlcnZlciAoJyArIGVyci5tZXNzYWdlICsgJyknO1xuICAgICAgICAgIGVyci5uZXR3b3JrRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0NDApIHtcbiAgICAgICAgICAgICAgRm9ybWlvLnNldFRva2VuKG51bGwpO1xuICAgICAgICAgICAgICBGb3JtaW8uZXZlbnRzLmVtaXQoJ2Zvcm1pby5zZXNzaW9uRXhwaXJlZCcsIHJlc3BvbnNlLmJvZHkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMSkge1xuICAgICAgICAgICAgICBGb3JtaW8uZXZlbnRzLmVtaXQoJ2Zvcm1pby51bmF1dGhvcml6ZWQnLCByZXNwb25zZS5ib2R5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBhcnNlIGFuZCByZXR1cm4gdGhlIGVycm9yIGFzIGEgcmVqZWN0ZWQgcHJvbWlzZSB0byByZWplY3QgdGhpcyBwcm9taXNlXG4gICAgICAgICAgICByZXR1cm4gKHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKS5pbmRleE9mKCdhcHBsaWNhdGlvbi9qc29uJykgIT09IC0xID8gcmVzcG9uc2UuanNvbigpIDogcmVzcG9uc2UudGV4dCgpKS50aGVuKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEhhbmRsZSBmZXRjaCByZXN1bHRzXG4gICAgICAgICAgdmFyIHRva2VuID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtand0LXRva2VuJyk7XG5cbiAgICAgICAgICAvLyBJbiBzb21lIHN0cmFuZ2UgY2FzZXMsIHRoZSBmZXRjaCBsaWJyYXJ5IHdpbGwgcmV0dXJuIGFuIHgtand0LXRva2VuIHdpdGhvdXQgc2VuZGluZ1xuICAgICAgICAgIC8vIG9uZSB0byB0aGUgc2VydmVyLiBUaGlzIGhhcyBldmVuIGJlZW4gZGVidWdnZWQgb24gdGhlIHNlcnZlciB0byB2ZXJpZnkgdGhhdCBubyB0b2tlblxuICAgICAgICAgIC8vIHdhcyBpbnRyb2R1Y2VkIHdpdGggdGhlIHJlcXVlc3QsIGJ1dCB0aGUgcmVzcG9uc2UgY29udGFpbnMgYSB0b2tlbi4gVGhpcyBpcyBhbiBJbnZhbGlkXG4gICAgICAgICAgLy8gY2FzZSB3aGVyZSB3ZSBkbyBub3Qgc2VuZCBhbiB4LWp3dC10b2tlbiBhbmQgZ2V0IG9uZSBpbiByZXR1cm4gZm9yIGFueSBHRVQgcmVxdWVzdC5cbiAgICAgICAgICB2YXIgdG9rZW5JbnRyb2R1Y2VkID0gZmFsc2U7XG4gICAgICAgICAgaWYgKG1ldGhvZCA9PT0gJ0dFVCcgJiYgIXJlcXVlc3RUb2tlbiAmJiB0b2tlbiAmJiB1cmwuaW5kZXhPZigndG9rZW49JykgPT09IC0xICYmIHVybC5pbmRleE9mKCd4LWp3dC10b2tlbj0nID09PSAtMSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignVG9rZW4gd2FzIGludHJvZHVjZWQgaW4gcmVxdWVzdC4nKTtcbiAgICAgICAgICAgIHRva2VuSW50cm9kdWNlZCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA+PSAyMDAgJiYgcmVzcG9uc2Uuc3RhdHVzIDwgMzAwICYmIHRva2VuICYmIHRva2VuICE9PSAnJyAmJiAhdG9rZW5JbnRyb2R1Y2VkKSB7XG4gICAgICAgICAgICBGb3JtaW8uc2V0VG9rZW4odG9rZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyAyMDQgaXMgbm8gY29udGVudC4gRG9uJ3QgdHJ5IHRvIC5qc29uKCkgaXQuXG4gICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA0KSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAocmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSAhPT0gLTEgPyByZXNwb25zZS5qc29uKCkgOiByZXNwb25zZS50ZXh0KCkpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgLy8gQWRkIHNvbWUgY29udGVudC1yYW5nZSBtZXRhZGF0YSB0byB0aGUgcmVzdWx0IGhlcmVcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXJhbmdlJyk7XG4gICAgICAgICAgICBpZiAocmFuZ2UgJiYgKHR5cGVvZiByZXN1bHQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHJlc3VsdCkpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICByYW5nZSA9IHJhbmdlLnNwbGl0KCcvJyk7XG4gICAgICAgICAgICAgIGlmIChyYW5nZVswXSAhPT0gJyonKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNraXBMaW1pdCA9IHJhbmdlWzBdLnNwbGl0KCctJyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNraXAgPSBOdW1iZXIoc2tpcExpbWl0WzBdKTtcbiAgICAgICAgICAgICAgICByZXN1bHQubGltaXQgPSBza2lwTGltaXRbMV0gLSBza2lwTGltaXRbMF0gKyAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdC5zZXJ2ZXJDb3VudCA9IHJhbmdlWzFdID09PSAnKicgPyByYW5nZVsxXSA6IE51bWJlcihyYW5nZVsxXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghb3B0cy5nZXRIZWFkZXJzKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBoZWFkZXJzID0ge307XG4gICAgICAgICAgICByZXNwb25zZS5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGtleSkge1xuICAgICAgICAgICAgICBoZWFkZXJzW2tleV0gPSBpdGVtO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoeyByZXN1bHQ6IHJlc3VsdCwgaGVhZGVyczogaGVhZGVycyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgaWYgKGVyciA9PT0gJ0JhZCBUb2tlbicpIHtcbiAgICAgICAgICAgIEZvcm1pby5zZXRUb2tlbihudWxsKTtcbiAgICAgICAgICAgIEZvcm1pby5ldmVudHMuZW1pdCgnZm9ybWlvLmJhZFRva2VuJywgZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKEZvcm1pby5jYWNoZS5oYXNPd25Qcm9wZXJ0eShjYWNoZUtleSkpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBmYWlsZWQgcHJvbWlzZXMgZnJvbSBjYWNoZVxuICAgICAgICAgICAgZGVsZXRlIEZvcm1pby5jYWNoZVtjYWNoZUtleV07XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFByb3BhZ2F0ZSBlcnJvciBzbyBjbGllbnQgY2FuIGhhbmRsZSBhY2NvcmRpbmdseVxuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSkpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIC8vIFNhdmUgdGhlIGNhY2hlXG4gICAgICAgIGlmIChtZXRob2QgPT09ICdHRVQnKSB7XG4gICAgICAgICAgRm9ybWlvLmNhY2hlW2NhY2hlS2V5XSA9IFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2hhbGxvdyBjb3B5IHJlc3VsdCBzbyBtb2RpZmljYXRpb25zIGRvbid0IGVuZCB1cCBpbiBjYWNoZVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdENvcHkgPSByZXN1bHQubWFwKGNvcHkpO1xuICAgICAgICAgIHJlc3VsdENvcHkuc2tpcCA9IHJlc3VsdC5za2lwO1xuICAgICAgICAgIHJlc3VsdENvcHkubGltaXQgPSByZXN1bHQubGltaXQ7XG4gICAgICAgICAgcmVzdWx0Q29weS5zZXJ2ZXJDb3VudCA9IHJlc3VsdC5zZXJ2ZXJDb3VudDtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0Q29weTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29weShyZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2V0VG9rZW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRUb2tlbih0b2tlbikge1xuICAgICAgdG9rZW4gPSB0b2tlbiB8fCAnJztcbiAgICAgIGlmICh0b2tlbiA9PT0gdGhpcy50b2tlbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgIEZvcm1pby5zZXRVc2VyKG51bGwpO1xuICAgICAgICAvLyBpT1MgaW4gcHJpdmF0ZSBicm93c2UgbW9kZSB3aWxsIHRocm93IGFuIGVycm9yIGJ1dCB3ZSBjYW4ndCBkZXRlY3QgYWhlYWQgb2YgdGltZSB0aGF0IHdlIGFyZSBpbiBwcml2YXRlIG1vZGUuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdmb3JtaW9Ub2tlbicpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGlPUyBpbiBwcml2YXRlIGJyb3dzZSBtb2RlIHdpbGwgdGhyb3cgYW4gZXJyb3IgYnV0IHdlIGNhbid0IGRldGVjdCBhaGVhZCBvZiB0aW1lIHRoYXQgd2UgYXJlIGluIHByaXZhdGUgbW9kZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdmb3JtaW9Ub2tlbicsIHRva2VuKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBEbyBub3RoaW5nLlxuICAgICAgfVxuICAgICAgcmV0dXJuIEZvcm1pby5jdXJyZW50VXNlcigpOyAvLyBSdW4gdGhpcyBzbyB1c2VyIGlzIHVwZGF0ZWQgaWYgbnVsbFxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFRva2VuJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VG9rZW4oKSB7XG4gICAgICBpZiAodGhpcy50b2tlbikge1xuICAgICAgICByZXR1cm4gdGhpcy50b2tlbjtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdmb3JtaW9Ub2tlbicpIHx8ICcnO1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldFVzZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRVc2VyKHVzZXIpIHtcbiAgICAgIGlmICghdXNlcikge1xuICAgICAgICB0aGlzLnNldFRva2VuKG51bGwpO1xuICAgICAgICAvLyBpT1MgaW4gcHJpdmF0ZSBicm93c2UgbW9kZSB3aWxsIHRocm93IGFuIGVycm9yIGJ1dCB3ZSBjYW4ndCBkZXRlY3QgYWhlYWQgb2YgdGltZSB0aGF0IHdlIGFyZSBpbiBwcml2YXRlIG1vZGUuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdmb3JtaW9Vc2VyJyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gaU9TIGluIHByaXZhdGUgYnJvd3NlIG1vZGUgd2lsbCB0aHJvdyBhbiBlcnJvciBidXQgd2UgY2FuJ3QgZGV0ZWN0IGFoZWFkIG9mIHRpbWUgdGhhdCB3ZSBhcmUgaW4gcHJpdmF0ZSBtb2RlLlxuICAgICAgdHJ5IHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2Zvcm1pb1VzZXInLCBKU09OLnN0cmluZ2lmeSh1c2VyKSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gRG8gbm90aGluZy5cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRVc2VyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VXNlcigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdmb3JtaW9Vc2VyJykgfHwgbnVsbCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXRCYXNlVXJsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0QmFzZVVybCh1cmwpIHtcbiAgICAgIEZvcm1pby5iYXNlVXJsID0gdXJsO1xuICAgICAgaWYgKCFGb3JtaW8ucHJvamVjdFVybFNldCkge1xuICAgICAgICBGb3JtaW8ucHJvamVjdFVybCA9IHVybDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRCYXNlVXJsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QmFzZVVybCgpIHtcbiAgICAgIHJldHVybiBGb3JtaW8uYmFzZVVybDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXRBcGlVcmwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRBcGlVcmwodXJsKSB7XG4gICAgICByZXR1cm4gRm9ybWlvLnNldEJhc2VVcmwodXJsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRBcGlVcmwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBcGlVcmwoKSB7XG4gICAgICByZXR1cm4gRm9ybWlvLmdldEJhc2VVcmwoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXRBcHBVcmwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRBcHBVcmwodXJsKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0Zvcm1pby5zZXRBcHBVcmwoKSBpcyBkZXByZWNhdGVkLiBVc2UgRm9ybWlvLnNldFByb2plY3RVcmwgaW5zdGVhZC4nKTtcbiAgICAgIEZvcm1pby5wcm9qZWN0VXJsID0gdXJsO1xuICAgICAgRm9ybWlvLnByb2plY3RVcmxTZXQgPSB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldFByb2plY3RVcmwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQcm9qZWN0VXJsKHVybCkge1xuICAgICAgRm9ybWlvLnByb2plY3RVcmwgPSB1cmw7XG4gICAgICBGb3JtaW8ucHJvamVjdFVybFNldCA9IHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0QXBwVXJsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXBwVXJsKCkge1xuICAgICAgY29uc29sZS53YXJuKCdGb3JtaW8uZ2V0QXBwVXJsKCkgaXMgZGVwcmVjYXRlZC4gVXNlIEZvcm1pby5nZXRQcm9qZWN0VXJsIGluc3RlYWQuJyk7XG4gICAgICByZXR1cm4gRm9ybWlvLnByb2plY3RVcmw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0UHJvamVjdFVybCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFByb2plY3RVcmwoKSB7XG4gICAgICByZXR1cm4gRm9ybWlvLnByb2plY3RVcmw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2xlYXJDYWNoZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyQ2FjaGUoKSB7XG4gICAgICBGb3JtaW8uY2FjaGUgPSB7fTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdub29wJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9vcCgpIHt9XG4gIH0sIHtcbiAgICBrZXk6ICdpZGVudGl0eScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVyZWdpc3RlclBsdWdpbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlcmVnaXN0ZXJQbHVnaW4ocGx1Z2luKSB7XG4gICAgICB2YXIgYmVmb3JlTGVuZ3RoID0gRm9ybWlvLnBsdWdpbnMubGVuZ3RoO1xuICAgICAgRm9ybWlvLnBsdWdpbnMgPSBGb3JtaW8ucGx1Z2lucy5maWx0ZXIoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgaWYgKHAgIT09IHBsdWdpbiAmJiBwLl9fbmFtZSAhPT0gcGx1Z2luKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgKHAuZGVyZWdpc3RlciB8fCBGb3JtaW8ubm9vcCkuY2FsbChwLCBGb3JtaW8pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBiZWZvcmVMZW5ndGggIT09IEZvcm1pby5wbHVnaW5zLmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZWdpc3RlclBsdWdpbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyUGx1Z2luKHBsdWdpbiwgbmFtZSkge1xuICAgICAgRm9ybWlvLnBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgICAgRm9ybWlvLnBsdWdpbnMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gKGIucHJpb3JpdHkgfHwgMCkgLSAoYS5wcmlvcml0eSB8fCAwKTtcbiAgICAgIH0pO1xuICAgICAgcGx1Z2luLl9fbmFtZSA9IG5hbWU7XG4gICAgICAocGx1Z2luLmluaXQgfHwgRm9ybWlvLm5vb3ApLmNhbGwocGx1Z2luLCBGb3JtaW8pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFBsdWdpbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBsdWdpbihuYW1lKSB7XG4gICAgICByZXR1cm4gRm9ybWlvLnBsdWdpbnMucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIHBsdWdpbikge1xuICAgICAgICBpZiAocmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICAgICAgICBpZiAocGx1Z2luLl9fbmFtZSA9PT0gbmFtZSkgcmV0dXJuIHBsdWdpbjtcbiAgICAgIH0sIG51bGwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3BsdWdpbldhaXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwbHVnaW5XYWl0KHBsdWdpbkZuKSB7XG4gICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChGb3JtaW8ucGx1Z2lucy5tYXAoZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICByZXR1cm4gKHBsdWdpbltwbHVnaW5Gbl0gfHwgRm9ybWlvLm5vb3ApLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgICB9KSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncGx1Z2luR2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGx1Z2luR2V0KHBsdWdpbkZuKSB7XG4gICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgIHZhciBjYWxsUGx1Z2luID0gZnVuY3Rpb24gY2FsbFBsdWdpbihpbmRleCwgcGx1Z2luRm4pIHtcbiAgICAgICAgdmFyIHBsdWdpbiA9IEZvcm1pby5wbHVnaW5zW2luZGV4XTtcbiAgICAgICAgaWYgKCFwbHVnaW4pIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKHBsdWdpbiAmJiBwbHVnaW5bcGx1Z2luRm5dIHx8IEZvcm1pby5ub29wKS5hcHBseShwbHVnaW4sIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSkpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgIGlmIChyZXN1bHQgIT09IG51bGwgJiYgcmVzdWx0ICE9PSB1bmRlZmluZWQpIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgcmV0dXJuIGNhbGxQbHVnaW4uYXBwbHkobnVsbCwgW2luZGV4ICsgMV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGNhbGxQbHVnaW4uYXBwbHkobnVsbCwgWzBdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncGx1Z2luQWx0ZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwbHVnaW5BbHRlcihwbHVnaW5GbiwgdmFsdWUpIHtcbiAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgICAgcmV0dXJuIEZvcm1pby5wbHVnaW5zLnJlZHVjZShmdW5jdGlvbiAodmFsdWUsIHBsdWdpbikge1xuICAgICAgICByZXR1cm4gKHBsdWdpbltwbHVnaW5Gbl0gfHwgRm9ybWlvLmlkZW50aXR5KS5hcHBseShwbHVnaW4sIFt2YWx1ZV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgIH0sIHZhbHVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjdXJyZW50VXNlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGN1cnJlbnRVc2VyKCkge1xuICAgICAgdmFyIHVybCA9IEZvcm1pby5iYXNlVXJsICsgJy9jdXJyZW50JztcbiAgICAgIHZhciB1c2VyID0gdGhpcy5nZXRVc2VyKCk7XG4gICAgICBpZiAodXNlcikge1xuICAgICAgICByZXR1cm4gRm9ybWlvLnBsdWdpbkFsdGVyKCd3cmFwU3RhdGljUmVxdWVzdFByb21pc2UnLCBQcm9taXNlLnJlc29sdmUodXNlciksIHtcbiAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICBtZXRob2Q6ICdHRVQnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdmFyIHRva2VuID0gdGhpcy5nZXRUb2tlbigpO1xuICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICByZXR1cm4gRm9ybWlvLnBsdWdpbkFsdGVyKCd3cmFwU3RhdGljUmVxdWVzdFByb21pc2UnLCBQcm9taXNlLnJlc29sdmUobnVsbCksIHtcbiAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICBtZXRob2Q6ICdHRVQnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEZvcm1pby5tYWtlU3RhdGljUmVxdWVzdCh1cmwpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIEZvcm1pby5zZXRVc2VyKHJlc3BvbnNlKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbG9nb3V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9nb3V0KCkge1xuICAgICAgRm9ybWlvLnNldFRva2VuKG51bGwpO1xuICAgICAgRm9ybWlvLnNldFVzZXIobnVsbCk7XG4gICAgICBGb3JtaW8uY2xlYXJDYWNoZSgpO1xuICAgICAgcmV0dXJuIEZvcm1pby5tYWtlU3RhdGljUmVxdWVzdChGb3JtaW8uYmFzZVVybCArICcvbG9nb3V0Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXR0YWNoIGFuIEhUTUwgZm9ybSB0byBGb3JtLmlvLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZvcm1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZm9ybScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm0oX2Zvcm0sIG9wdGlvbnMsIGRvbmUpIHtcbiAgICAgIC8vIEZpeCB0aGUgcGFyYW1ldGVycy5cbiAgICAgIGlmICghZG9uZSAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkb25lID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuXG4gICAgICBkb25lID0gZG9uZSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIC8vIElGIHRoZXkgcHJvdmlkZSBhIGpxdWVyeSBvYmplY3QsIHRoZW4gc2VsZWN0IHRoZSBlbGVtZW50LlxuICAgICAgaWYgKF9mb3JtLmpxdWVyeSkge1xuICAgICAgICBfZm9ybSA9IF9mb3JtWzBdO1xuICAgICAgfVxuICAgICAgaWYgKCFfZm9ybSkge1xuICAgICAgICByZXR1cm4gZG9uZSgnSW52YWxpZCBGb3JtJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBnZXRBY3Rpb24gPSBmdW5jdGlvbiBnZXRBY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmZvcm0gfHwgX2Zvcm0uZ2V0QXR0cmlidXRlKCdhY3Rpb24nKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0aGUgY3VycmVudCBzdWJtaXNzaW9uIG9iamVjdC5cbiAgICAgICAqIEByZXR1cm5zIHt7ZGF0YToge319fVxuICAgICAgICovXG4gICAgICB2YXIgZ2V0U3VibWlzc2lvbiA9IGZ1bmN0aW9uIGdldFN1Ym1pc3Npb24oKSB7XG4gICAgICAgIHZhciBzdWJtaXNzaW9uID0geyBkYXRhOiB7fSB9O1xuICAgICAgICB2YXIgc2V0VmFsdWUgPSBmdW5jdGlvbiBzZXRWYWx1ZShwYXRoLCB2YWx1ZSkge1xuICAgICAgICAgIHZhciBpc0FycmF5ID0gcGF0aC5zdWJzdHIoLTIpID09PSAnW10nO1xuICAgICAgICAgIGlmIChpc0FycmF5KSB7XG4gICAgICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKCdbXScsICcnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHBhdGhzID0gcGF0aC5yZXBsYWNlKC9cXFt8XFxdXFxbL2csICcuJykucmVwbGFjZSgvXFxdJC9nLCAnJykuc3BsaXQoJy4nKTtcbiAgICAgICAgICB2YXIgY3VycmVudCA9IHN1Ym1pc3Npb247XG4gICAgICAgICAgd2hpbGUgKHBhdGggPSBwYXRocy5zaGlmdCgpKSB7XG4gICAgICAgICAgICBpZiAoIXBhdGhzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICAgICAgICAgIGlmICghY3VycmVudFtwYXRoXSkge1xuICAgICAgICAgICAgICAgICAgY3VycmVudFtwYXRoXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50W3BhdGhdLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRbcGF0aF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKCFjdXJyZW50W3BhdGhdKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFtwYXRoXSA9IHt9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50W3BhdGhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBHZXQgdGhlIGZvcm0gZGF0YSBmcm9tIHRoaXMgZm9ybS5cbiAgICAgICAgdmFyIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKF9mb3JtKTtcbiAgICAgICAgdmFyIGVudHJpZXMgPSBmb3JtRGF0YS5lbnRyaWVzKCk7XG4gICAgICAgIHZhciBlbnRyeSA9IG51bGw7XG4gICAgICAgIHdoaWxlIChlbnRyeSA9IGVudHJpZXMubmV4dCgpLnZhbHVlKSB7XG4gICAgICAgICAgc2V0VmFsdWUoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VibWlzc2lvbjtcbiAgICAgIH07XG5cbiAgICAgIC8vIFN1Ym1pdHMgdGhlIGZvcm0uXG4gICAgICB2YXIgc3VibWl0ID0gZnVuY3Rpb24gc3VibWl0KGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFjdGlvbiA9IGdldEFjdGlvbigpO1xuICAgICAgICBpZiAoIWFjdGlvbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBuZXcgRm9ybWlvKGFjdGlvbikuc2F2ZVN1Ym1pc3Npb24oZ2V0U3VibWlzc2lvbigpKS50aGVuKGZ1bmN0aW9uIChzdWIpIHtcbiAgICAgICAgICBkb25lKG51bGwsIHN1Yik7XG4gICAgICAgIH0sIGRvbmUpO1xuICAgICAgfTtcblxuICAgICAgLy8gQXR0YWNoIGZvcm1pbyB0byB0aGUgcHJvdmlkZWQgZm9ybS5cbiAgICAgIGlmIChfZm9ybS5hdHRhY2hFdmVudCkge1xuICAgICAgICBfZm9ybS5hdHRhY2hFdmVudCgnc3VibWl0Jywgc3VibWl0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9mb3JtLmFkZEV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsIHN1Ym1pdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Ym1pdDogc3VibWl0LFxuICAgICAgICBnZXRBY3Rpb246IGdldEFjdGlvbixcbiAgICAgICAgZ2V0U3VibWlzc2lvbjogZ2V0U3VibWlzc2lvblxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmaWVsZERhdGEnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaWVsZERhdGEoZGF0YSwgY29tcG9uZW50KSB7XG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgaWYgKCFjb21wb25lbnQgfHwgIWNvbXBvbmVudC5rZXkpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9XG4gICAgICBpZiAoY29tcG9uZW50LmtleS5pbmRleE9mKCcuJykgIT09IC0xKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGRhdGE7XG4gICAgICAgIHZhciBwYXJ0cyA9IGNvbXBvbmVudC5rZXkuc3BsaXQoJy4nKTtcbiAgICAgICAgdmFyIGtleSA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAga2V5ID0gcGFydHNbaV07XG5cbiAgICAgICAgICAvLyBIYW5kbGUgbmVzdGVkIHJlc291cmNlc1xuICAgICAgICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnX2lkJykpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuZGF0YTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBSZXR1cm4gaWYgdGhlIGtleSBpcyBub3QgZm91bmQgb24gdGhlIHZhbHVlLlxuICAgICAgICAgIGlmICghdmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENvbnZlcnQgb2xkIHNpbmdsZSBmaWVsZCBkYXRhIGluIHN1Ym1pc3Npb25zIHRvIG11bHRpcGxlXG4gICAgICAgICAgaWYgKGtleSA9PT0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV0gJiYgY29tcG9uZW50Lm11bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlW2tleV0pKSB7XG4gICAgICAgICAgICB2YWx1ZVtrZXldID0gW3ZhbHVlW2tleV1dO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNldCB0aGUgdmFsdWUgb2YgdGhpcyBrZXkuXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENvbnZlcnQgb2xkIHNpbmdsZSBmaWVsZCBkYXRhIGluIHN1Ym1pc3Npb25zIHRvIG11bHRpcGxlXG4gICAgICAgIGlmIChjb21wb25lbnQubXVsdGlwbGUgJiYgIUFycmF5LmlzQXJyYXkoZGF0YVtjb21wb25lbnQua2V5XSkpIHtcbiAgICAgICAgICBkYXRhW2NvbXBvbmVudC5rZXldID0gW2RhdGFbY29tcG9uZW50LmtleV1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhW2NvbXBvbmVudC5rZXldO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGb3JtaW87XG59KCk7XG5cbi8vIERlZmluZSBhbGwgdGhlIHN0YXRpYyBwcm9wZXJ0aWVzLlxuXG5cbmV4cG9ydHMuRm9ybWlvID0gRm9ybWlvO1xuRm9ybWlvLmJhc2VVcmwgPSAnaHR0cHM6Ly9hcGkuZm9ybS5pbyc7XG5Gb3JtaW8ucHJvamVjdFVybCA9IEZvcm1pby5iYXNlVXJsO1xuRm9ybWlvLnByb2plY3RVcmxTZXQgPSBmYWxzZTtcbkZvcm1pby5wbHVnaW5zID0gW107XG5Gb3JtaW8uY2FjaGUgPSB7fTtcbkZvcm1pby5wcm92aWRlcnMgPSByZXF1aXJlKCcuL3Byb3ZpZGVycycpO1xuRm9ybWlvLmV2ZW50cyA9IG5ldyBFdmVudEVtaXR0ZXIoe1xuICB3aWxkY2FyZDogZmFsc2UsXG4gIG1heExpc3RlbmVyczogMFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLkZvcm1pbyA9IEZvcm1pbzsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzdG9yYWdlOiByZXF1aXJlKCcuL3N0b3JhZ2UnKVxufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBQcm9taXNlID0gcmVxdWlyZShcIm5hdGl2ZS1wcm9taXNlLW9ubHlcIik7XG52YXIgZHJvcGJveCA9IGZ1bmN0aW9uIGRyb3Bib3goZm9ybWlvKSB7XG4gIHJldHVybiB7XG4gICAgdXBsb2FkRmlsZTogZnVuY3Rpb24gdXBsb2FkRmlsZShmaWxlLCBmaWxlTmFtZSwgZGlyLCBwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAvLyBTZW5kIHRoZSBmaWxlIHdpdGggZGF0YS5cbiAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcHJvZ3Jlc3NDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHhoci51cGxvYWQub25wcm9ncmVzcyA9IHByb2dyZXNzQ2FsbGJhY2s7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmQgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgZmQuYXBwZW5kKCduYW1lJywgZmlsZU5hbWUpO1xuICAgICAgICBmZC5hcHBlbmQoJ2RpcicsIGRpcik7XG4gICAgICAgIGZkLmFwcGVuZCgnZmlsZScsIGZpbGUpO1xuXG4gICAgICAgIC8vIEZpcmUgb24gbmV0d29yayBlcnJvci5cbiAgICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgZXJyLm5ldHdvcmtFcnJvciA9IHRydWU7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH07XG5cbiAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCkge1xuICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2UpO1xuICAgICAgICAgICAgcmVzcG9uc2Uuc3RvcmFnZSA9ICdkcm9wYm94JztcbiAgICAgICAgICAgIHJlc3BvbnNlLnNpemUgPSBmaWxlLnNpemU7XG4gICAgICAgICAgICByZXNwb25zZS50eXBlID0gZmlsZS50eXBlO1xuICAgICAgICAgICAgcmVzcG9uc2UudXJsID0gcmVzcG9uc2UucGF0aF9sb3dlcjtcbiAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QoeGhyLnJlc3BvbnNlIHx8ICdVbmFibGUgdG8gdXBsb2FkIGZpbGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgeGhyLm9uYWJvcnQgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH07XG5cbiAgICAgICAgeGhyLm9wZW4oJ1BPU1QnLCBmb3JtaW8uZm9ybVVybCArICcvc3RvcmFnZS9kcm9wYm94Jyk7XG4gICAgICAgIHZhciB0b2tlbiA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2Zvcm1pb1Rva2VuJyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBTd2FsbG93IGVycm9yLlxuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCd4LWp3dC10b2tlbicsIHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICB4aHIuc2VuZChmZCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRvd25sb2FkRmlsZTogZnVuY3Rpb24gZG93bmxvYWRGaWxlKGZpbGUpIHtcbiAgICAgIHZhciB0b2tlbiA9IGZhbHNlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnZm9ybWlvVG9rZW4nKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gU3dhbGxvdyBlcnJvci5cbiAgICAgIH1cbiAgICAgIGZpbGUudXJsID0gZm9ybWlvLmZvcm1VcmwgKyAnL3N0b3JhZ2UvZHJvcGJveD9wYXRoX2xvd2VyPScgKyBmaWxlLnBhdGhfbG93ZXIgKyAodG9rZW4gPyAnJngtand0LXRva2VuPScgKyB0b2tlbiA6ICcnKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmlsZSk7XG4gICAgfVxuICB9O1xufTtcblxuZHJvcGJveC50aXRsZSA9ICdEcm9wYm94Jztcbm1vZHVsZS5leHBvcnRzID0gZHJvcGJveDsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkcm9wYm94OiByZXF1aXJlKCcuL2Ryb3Bib3guanMnKSxcbiAgczM6IHJlcXVpcmUoJy4vczMuanMnKSxcbiAgdXJsOiByZXF1aXJlKCcuL3VybC5qcycpXG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIFByb21pc2UgPSByZXF1aXJlKFwibmF0aXZlLXByb21pc2Utb25seVwiKTtcbnZhciBzMyA9IGZ1bmN0aW9uIHMzKGZvcm1pbykge1xuICByZXR1cm4ge1xuICAgIHVwbG9hZEZpbGU6IGZ1bmN0aW9uIHVwbG9hZEZpbGUoZmlsZSwgZmlsZU5hbWUsIGRpciwgcHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgLy8gU2VuZCB0aGUgcHJlIHJlc3BvbnNlIHRvIHNpZ24gdGhlIHVwbG9hZC5cbiAgICAgICAgdmFyIHByZSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICAgIHZhciBwcmVmZCA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICBwcmVmZC5hcHBlbmQoJ25hbWUnLCBmaWxlTmFtZSk7XG4gICAgICAgIHByZWZkLmFwcGVuZCgnc2l6ZScsIGZpbGUuc2l6ZSk7XG4gICAgICAgIHByZWZkLmFwcGVuZCgndHlwZScsIGZpbGUudHlwZSk7XG5cbiAgICAgICAgLy8gVGhpcyBvbmx5IGZpcmVzIG9uIGEgbmV0d29yayBlcnJvci5cbiAgICAgICAgcHJlLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgZXJyLm5ldHdvcmtFcnJvciA9IHRydWU7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH07XG5cbiAgICAgICAgcHJlLm9uYWJvcnQgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH07XG5cbiAgICAgICAgcHJlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAocHJlLnN0YXR1cyA+PSAyMDAgJiYgcHJlLnN0YXR1cyA8IDMwMCkge1xuICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gSlNPTi5wYXJzZShwcmUucmVzcG9uc2UpO1xuXG4gICAgICAgICAgICAvLyBTZW5kIHRoZSBmaWxlIHdpdGggZGF0YS5cbiAgICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9ncmVzc0NhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHhoci51cGxvYWQub25wcm9ncmVzcyA9IHByb2dyZXNzQ2FsbGJhY2s7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3BvbnNlLmRhdGEuZmlsZU5hbWUgPSBmaWxlTmFtZTtcbiAgICAgICAgICAgIHJlc3BvbnNlLmRhdGEua2V5ICs9IGRpciArIGZpbGVOYW1lO1xuXG4gICAgICAgICAgICB2YXIgZmQgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiByZXNwb25zZS5kYXRhKSB7XG4gICAgICAgICAgICAgIGZkLmFwcGVuZChrZXksIHJlc3BvbnNlLmRhdGFba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmZC5hcHBlbmQoJ2ZpbGUnLCBmaWxlKTtcblxuICAgICAgICAgICAgLy8gRmlyZSBvbiBuZXR3b3JrIGVycm9yLlxuICAgICAgICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgIGVyci5uZXR3b3JrRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICBzdG9yYWdlOiAnczMnLFxuICAgICAgICAgICAgICAgICAgbmFtZTogZmlsZU5hbWUsXG4gICAgICAgICAgICAgICAgICBidWNrZXQ6IHJlc3BvbnNlLmJ1Y2tldCxcbiAgICAgICAgICAgICAgICAgIGtleTogcmVzcG9uc2UuZGF0YS5rZXksXG4gICAgICAgICAgICAgICAgICB1cmw6IHJlc3BvbnNlLnVybCArIHJlc3BvbnNlLmRhdGEua2V5LFxuICAgICAgICAgICAgICAgICAgYWNsOiByZXNwb25zZS5kYXRhLmFjbCxcbiAgICAgICAgICAgICAgICAgIHNpemU6IGZpbGUuc2l6ZSxcbiAgICAgICAgICAgICAgICAgIHR5cGU6IGZpbGUudHlwZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdCh4aHIucmVzcG9uc2UgfHwgJ1VuYWJsZSB0byB1cGxvYWQgZmlsZScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB4aHIub25hYm9ydCA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB4aHIub3BlbignUE9TVCcsIHJlc3BvbnNlLnVybCk7XG5cbiAgICAgICAgICAgIHhoci5zZW5kKGZkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KHByZS5yZXNwb25zZSB8fCAnVW5hYmxlIHRvIHNpZ24gZmlsZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBwcmUub3BlbignUE9TVCcsIGZvcm1pby5mb3JtVXJsICsgJy9zdG9yYWdlL3MzJyk7XG5cbiAgICAgICAgcHJlLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICAgIHByZS5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD1VVEYtOCcpO1xuICAgICAgICB2YXIgdG9rZW4gPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdmb3JtaW9Ub2tlbicpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gc3dhbGxvdyBlcnJvci5cbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICBwcmUuc2V0UmVxdWVzdEhlYWRlcigneC1qd3QtdG9rZW4nLCB0b2tlbik7XG4gICAgICAgIH1cblxuICAgICAgICBwcmUuc2VuZChKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgbmFtZTogZmlsZU5hbWUsXG4gICAgICAgICAgc2l6ZTogZmlsZS5zaXplLFxuICAgICAgICAgIHR5cGU6IGZpbGUudHlwZVxuICAgICAgICB9KSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRvd25sb2FkRmlsZTogZnVuY3Rpb24gZG93bmxvYWRGaWxlKGZpbGUpIHtcbiAgICAgIGlmIChmaWxlLmFjbCAhPT0gJ3B1YmxpYy1yZWFkJykge1xuICAgICAgICByZXR1cm4gZm9ybWlvLm1ha2VSZXF1ZXN0KCdmaWxlJywgZm9ybWlvLmZvcm1VcmwgKyAnL3N0b3JhZ2UvczM/YnVja2V0PScgKyBmaWxlLmJ1Y2tldCArICcma2V5PScgKyBmaWxlLmtleSwgJ0dFVCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmaWxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuXG5zMy50aXRsZSA9ICdTMyc7XG5tb2R1bGUuZXhwb3J0cyA9IHMzOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIFByb21pc2UgPSByZXF1aXJlKFwibmF0aXZlLXByb21pc2Utb25seVwiKTtcbnZhciB1cmwgPSBmdW5jdGlvbiB1cmwoZm9ybWlvKSB7XG4gIHJldHVybiB7XG4gICAgdGl0bGU6ICdVcmwnLFxuICAgIG5hbWU6ICd1cmwnLFxuICAgIHVwbG9hZEZpbGU6IGZ1bmN0aW9uIHVwbG9hZEZpbGUoZmlsZSwgZmlsZU5hbWUsIGRpciwgcHJvZ3Jlc3NDYWxsYmFjaywgdXJsKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICBkaXI6IGRpcixcbiAgICAgICAgICBuYW1lOiBmaWxlTmFtZSxcbiAgICAgICAgICBmaWxlOiBmaWxlXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU2VuZCB0aGUgZmlsZSB3aXRoIGRhdGEuXG4gICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgICBpZiAodHlwZW9mIHByb2dyZXNzQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB4aHIudXBsb2FkLm9ucHJvZ3Jlc3MgPSBwcm9ncmVzc0NhbGxiYWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZkID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgZmQuYXBwZW5kKGtleSwgZGF0YVtrZXldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHtcbiAgICAgICAgICAgIC8vIE5lZWQgdG8gdGVzdCBpZiB4aHIucmVzcG9uc2UgaXMgZGVjb2RlZCBvciBub3QuXG4gICAgICAgICAgICB2YXIgcmVzcERhdGEgPSB7fTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJlc3BEYXRhID0gdHlwZW9mIHhoci5yZXNwb25zZSA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKHhoci5yZXNwb25zZSkgOiB7fTtcbiAgICAgICAgICAgICAgcmVzcERhdGEgPSByZXNwRGF0YSAmJiByZXNwRGF0YS5kYXRhID8gcmVzcERhdGEuZGF0YSA6IHt9O1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIHJlc3BEYXRhID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICBzdG9yYWdlOiAndXJsJyxcbiAgICAgICAgICAgICAgbmFtZTogZmlsZU5hbWUsXG4gICAgICAgICAgICAgIHVybDogeGhyLnJlc3BvbnNlVVJMICsgJy8nICsgZmlsZU5hbWUsXG4gICAgICAgICAgICAgIHNpemU6IGZpbGUuc2l6ZSxcbiAgICAgICAgICAgICAgdHlwZTogZmlsZS50eXBlLFxuICAgICAgICAgICAgICBkYXRhOiByZXNwRGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdCh4aHIucmVzcG9uc2UgfHwgJ1VuYWJsZSB0byB1cGxvYWQgZmlsZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBGaXJlIG9uIG5ldHdvcmsgZXJyb3IuXG4gICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJlamVjdCh4aHIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJlamVjdCh4aHIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHhoci5vcGVuKCdQT1NUJywgdXJsKTtcbiAgICAgICAgdmFyIHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2Zvcm1pb1Rva2VuJyk7XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCd4LWp3dC10b2tlbicsIHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICB4aHIuc2VuZChmZCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRvd25sb2FkRmlsZTogZnVuY3Rpb24gZG93bmxvYWRGaWxlKGZpbGUpIHtcbiAgICAgIC8vIFJldHVybiB0aGUgb3JpZ2luYWwgYXMgdGhlcmUgaXMgbm90aGluZyB0byBkby5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmlsZSk7XG4gICAgfVxuICB9O1xufTtcblxudXJsLnRpdGxlID0gJ1VybCc7XG5tb2R1bGUuZXhwb3J0cyA9IHVybDsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9qc29uTG9naWNKcyA9IHJlcXVpcmUoJ2pzb24tbG9naWMtanMnKTtcblxudmFyIF9qc29uTG9naWNKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9qc29uTG9naWNKcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBfZ2V0ID0gcmVxdWlyZSgnbG9kYXNoL2dldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLyoqXG4gICAqIERldGVybWluZSBpZiBhIGNvbXBvbmVudCBpcyBhIGxheW91dCBjb21wb25lbnQgb3Igbm90LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29tcG9uZW50XG4gICAqICAgVGhlIGNvbXBvbmVudCB0byBjaGVjay5cbiAgICpcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqICAgV2hldGhlciBvciBub3QgdGhlIGNvbXBvbmVudCBpcyBhIGxheW91dCBjb21wb25lbnQuXG4gICAqL1xuICBpc0xheW91dENvbXBvbmVudDogZnVuY3Rpb24gaXNMYXlvdXRDb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudC5jb2x1bW5zICYmIEFycmF5LmlzQXJyYXkoY29tcG9uZW50LmNvbHVtbnMpIHx8IGNvbXBvbmVudC5yb3dzICYmIEFycmF5LmlzQXJyYXkoY29tcG9uZW50LnJvd3MpIHx8IGNvbXBvbmVudC5jb21wb25lbnRzICYmIEFycmF5LmlzQXJyYXkoY29tcG9uZW50LmNvbXBvbmVudHMpID8gdHJ1ZSA6IGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJdGVyYXRlIHRocm91Z2ggZWFjaCBjb21wb25lbnQgd2l0aGluIGEgZm9ybS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbXBvbmVudHNcbiAgICogICBUaGUgY29tcG9uZW50cyB0byBpdGVyYXRlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKiAgIFRoZSBpdGVyYXRpb24gZnVuY3Rpb24gdG8gaW52b2tlIGZvciBlYWNoIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBpbmNsdWRlQWxsXG4gICAqICAgV2hldGhlciBvciBub3QgdG8gaW5jbHVkZSBsYXlvdXQgY29tcG9uZW50cy5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAgICogICBUaGUgY3VycmVudCBkYXRhIHBhdGggb2YgdGhlIGVsZW1lbnQuIEV4YW1wbGU6IGRhdGEudXNlci5maXJzdE5hbWVcbiAgICovXG4gIGVhY2hDb21wb25lbnQ6IGZ1bmN0aW9uIGVhY2hDb21wb25lbnQoY29tcG9uZW50cywgZm4sIGluY2x1ZGVBbGwsIHBhdGgpIHtcbiAgICBpZiAoIWNvbXBvbmVudHMpIHJldHVybjtcbiAgICBwYXRoID0gcGF0aCB8fCAnJztcbiAgICBjb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgdmFyIGhhc0NvbHVtbnMgPSBjb21wb25lbnQuY29sdW1ucyAmJiBBcnJheS5pc0FycmF5KGNvbXBvbmVudC5jb2x1bW5zKTtcbiAgICAgIHZhciBoYXNSb3dzID0gY29tcG9uZW50LnJvd3MgJiYgQXJyYXkuaXNBcnJheShjb21wb25lbnQucm93cyk7XG4gICAgICB2YXIgaGFzQ29tcHMgPSBjb21wb25lbnQuY29tcG9uZW50cyAmJiBBcnJheS5pc0FycmF5KGNvbXBvbmVudC5jb21wb25lbnRzKTtcbiAgICAgIHZhciBub1JlY3Vyc2UgPSBmYWxzZTtcbiAgICAgIHZhciBuZXdQYXRoID0gY29tcG9uZW50LmtleSA/IHBhdGggPyBwYXRoICsgJy4nICsgY29tcG9uZW50LmtleSA6IGNvbXBvbmVudC5rZXkgOiAnJztcblxuICAgICAgaWYgKGluY2x1ZGVBbGwgfHwgY29tcG9uZW50LnRyZWUgfHwgIWhhc0NvbHVtbnMgJiYgIWhhc1Jvd3MgJiYgIWhhc0NvbXBzKSB7XG4gICAgICAgIG5vUmVjdXJzZSA9IGZuKGNvbXBvbmVudCwgbmV3UGF0aCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdWJQYXRoID0gZnVuY3Rpb24gc3ViUGF0aCgpIHtcbiAgICAgICAgaWYgKGNvbXBvbmVudC5rZXkgJiYgKGNvbXBvbmVudC50eXBlID09PSAnZGF0YWdyaWQnIHx8IGNvbXBvbmVudC50eXBlID09PSAnY29udGFpbmVyJykpIHtcbiAgICAgICAgICByZXR1cm4gbmV3UGF0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH07XG5cbiAgICAgIGlmICghbm9SZWN1cnNlKSB7XG4gICAgICAgIGlmIChoYXNDb2x1bW5zKSB7XG4gICAgICAgICAgY29tcG9uZW50LmNvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgICAgICBlYWNoQ29tcG9uZW50KGNvbHVtbi5jb21wb25lbnRzLCBmbiwgaW5jbHVkZUFsbCwgc3ViUGF0aCgpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChoYXNSb3dzKSB7XG4gICAgICAgICAgW10uY29uY2F0LmFwcGx5KFtdLCBjb21wb25lbnQucm93cykuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICBlYWNoQ29tcG9uZW50KHJvdy5jb21wb25lbnRzLCBmbiwgaW5jbHVkZUFsbCwgc3ViUGF0aCgpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChoYXNDb21wcykge1xuICAgICAgICAgIGVhY2hDb21wb25lbnQoY29tcG9uZW50LmNvbXBvbmVudHMsIGZuLCBpbmNsdWRlQWxsLCBzdWJQYXRoKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBhIGNvbXBvbmVudCBieSBpdHMga2V5XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb21wb25lbnRzXG4gICAqICAgVGhlIGNvbXBvbmVudHMgdG8gaXRlcmF0ZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgKiAgIFRoZSBrZXkgb2YgdGhlIGNvbXBvbmVudCB0byBnZXQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqICAgVGhlIGNvbXBvbmVudCB0aGF0IG1hdGNoZXMgdGhlIGdpdmVuIGtleSwgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZC5cbiAgICovXG4gIGdldENvbXBvbmVudDogZnVuY3Rpb24gZ2V0Q29tcG9uZW50KGNvbXBvbmVudHMsIGtleSkge1xuICAgIHZhciByZXN1bHQ7XG4gICAgbW9kdWxlLmV4cG9ydHMuZWFjaENvbXBvbmVudChjb21wb25lbnRzLCBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICBpZiAoY29tcG9uZW50LmtleSA9PT0ga2V5KSB7XG4gICAgICAgIHJlc3VsdCA9IGNvbXBvbmVudDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBGbGF0dGVuIHRoZSBmb3JtIGNvbXBvbmVudHMgZm9yIGRhdGEgbWFuaXB1bGF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29tcG9uZW50c1xuICAgKiAgIFRoZSBjb21wb25lbnRzIHRvIGl0ZXJhdGUuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5jbHVkZUFsbFxuICAgKiAgIFdoZXRoZXIgb3Igbm90IHRvIGluY2x1ZGUgbGF5b3V0IGNvbXBvbmVudHMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqICAgVGhlIGZsYXR0ZW5lZCBjb21wb25lbnRzIG1hcC5cbiAgICovXG4gIGZsYXR0ZW5Db21wb25lbnRzOiBmdW5jdGlvbiBmbGF0dGVuQ29tcG9uZW50cyhjb21wb25lbnRzLCBpbmNsdWRlQWxsKSB7XG4gICAgdmFyIGZsYXR0ZW5lZCA9IHt9O1xuICAgIG1vZHVsZS5leHBvcnRzLmVhY2hDb21wb25lbnQoY29tcG9uZW50cywgZnVuY3Rpb24gKGNvbXBvbmVudCwgcGF0aCkge1xuICAgICAgZmxhdHRlbmVkW3BhdGhdID0gY29tcG9uZW50O1xuICAgIH0sIGluY2x1ZGVBbGwpO1xuICAgIHJldHVybiBmbGF0dGVuZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgaWYgdGhpcyBjb21wb25lbnQgaGFzIGEgY29uZGl0aW9uYWwgc3RhdGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0gY29tcG9uZW50IC0gVGhlIGNvbXBvbmVudCBKU09OIHNjaGVtYS5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59IC0gVFJVRSAtIFRoaXMgY29tcG9uZW50IGhhcyBhIGNvbmRpdGlvbmFsLCBGQUxTRSAtIE5vIGNvbmRpdGlvbmFsIHByb3ZpZGVkLlxuICAgKi9cbiAgaGFzQ29uZGl0aW9uOiBmdW5jdGlvbiBoYXNDb25kaXRpb24oY29tcG9uZW50KSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudC5oYXNPd25Qcm9wZXJ0eSgnY3VzdG9tQ29uZGl0aW9uYWwnKSAmJiBjb21wb25lbnQuY3VzdG9tQ29uZGl0aW9uYWwgfHwgY29tcG9uZW50Lmhhc093blByb3BlcnR5KCdjb25kaXRpb25hbCcpICYmIGNvbXBvbmVudC5jb25kaXRpb25hbCAmJiBjb21wb25lbnQuY29uZGl0aW9uYWwud2hlbiB8fCBjb21wb25lbnQuaGFzT3duUHJvcGVydHkoJ2NvbmRpdGlvbmFsJykgJiYgY29tcG9uZW50LmNvbmRpdGlvbmFsICYmIGNvbXBvbmVudC5jb25kaXRpb25hbC5qc29uO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3MgdGhlIGNvbmRpdGlvbnMgZm9yIGEgcHJvdmlkZWQgY29tcG9uZW50IGFuZCBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0gY29tcG9uZW50XG4gICAqICAgVGhlIGNvbXBvbmVudCB0byBjaGVjayBmb3IgdGhlIGNvbmRpdGlvbi5cbiAgICogQHBhcmFtIHJvd1xuICAgKiAgIFRoZSBkYXRhIHdpdGhpbiBhIHJvd1xuICAgKiBAcGFyYW0gZGF0YVxuICAgKiAgIFRoZSBmdWxsIHN1Ym1pc3Npb24gZGF0YS5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBjaGVja0NvbmRpdGlvbjogZnVuY3Rpb24gY2hlY2tDb25kaXRpb24oY29tcG9uZW50LCByb3csIGRhdGEpIHtcbiAgICBpZiAoY29tcG9uZW50Lmhhc093blByb3BlcnR5KCdjdXN0b21Db25kaXRpb25hbCcpICYmIGNvbXBvbmVudC5jdXN0b21Db25kaXRpb25hbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHNjcmlwdCA9ICcoZnVuY3Rpb24oKSB7IHZhciBzaG93ID0gdHJ1ZTsnO1xuICAgICAgICBzY3JpcHQgKz0gY29tcG9uZW50LmN1c3RvbUNvbmRpdGlvbmFsLnRvU3RyaW5nKCk7XG4gICAgICAgIHNjcmlwdCArPSAnOyByZXR1cm4gc2hvdzsgfSkoKSc7XG4gICAgICAgIHZhciByZXN1bHQgPSBldmFsKHNjcmlwdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQudG9TdHJpbmcoKSA9PT0gJ3RydWUnO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0FuIGVycm9yIG9jY3VycmVkIGluIGEgY3VzdG9tIGNvbmRpdGlvbmFsIHN0YXRlbWVudCBmb3IgY29tcG9uZW50ICcgKyBjb21wb25lbnQua2V5LCBlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb21wb25lbnQuaGFzT3duUHJvcGVydHkoJ2NvbmRpdGlvbmFsJykgJiYgY29tcG9uZW50LmNvbmRpdGlvbmFsICYmIGNvbXBvbmVudC5jb25kaXRpb25hbC53aGVuKSB7XG4gICAgICB2YXIgY29uZCA9IGNvbXBvbmVudC5jb25kaXRpb25hbDtcbiAgICAgIHZhciB2YWx1ZSA9IG51bGw7XG4gICAgICBpZiAocm93KSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5nZXRWYWx1ZSh7IGRhdGE6IHJvdyB9LCBjb25kLndoZW4pO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEgJiYgKHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5nZXRWYWx1ZSh7IGRhdGE6IGRhdGEgfSwgY29uZC53aGVuKTtcbiAgICAgIH1cbiAgICAgIC8vIEZPUi00MDAgLSBGaXggaXNzdWUgd2hlcmUgZmFsc2V5IHZhbHVlcyB3ZXJlIGJlaW5nIGV2YWx1YXRlZCBhcyBzaG93PXRydWVcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIFNwZWNpYWwgY2hlY2sgZm9yIHNlbGVjdGJveGVzIGNvbXBvbmVudC5cbiAgICAgIGlmICgodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWx1ZSkpID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5oYXNPd25Qcm9wZXJ0eShjb25kLmVxKSkge1xuICAgICAgICByZXR1cm4gdmFsdWVbY29uZC5lcV0udG9TdHJpbmcoKSA9PT0gY29uZC5zaG93LnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICAvLyBGT1ItMTc5IC0gQ2hlY2sgZm9yIG11bHRpcGxlIHZhbHVlcy5cbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5ICYmIHZhbHVlLmluZGV4T2YoY29uZC5lcSkgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBjb25kLnNob3cudG9TdHJpbmcoKSA9PT0gJ3RydWUnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKSA9PT0gY29uZC5lcS50b1N0cmluZygpID09PSAoY29uZC5zaG93LnRvU3RyaW5nKCkgPT09ICd0cnVlJyk7XG4gICAgfSBlbHNlIGlmIChjb21wb25lbnQuaGFzT3duUHJvcGVydHkoJ2NvbmRpdGlvbmFsJykgJiYgY29tcG9uZW50LmNvbmRpdGlvbmFsICYmIGNvbXBvbmVudC5jb25kaXRpb25hbC5qc29uKSB7XG4gICAgICByZXR1cm4gX2pzb25Mb2dpY0pzMi5kZWZhdWx0LmFwcGx5KGNvbXBvbmVudC5jb25kaXRpb25hbC5qc29uLCB7XG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIHJvdzogcm93XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IHRvIHNob3cuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgZm9yIGEgY29tcG9uZW50IGtleSwgaW4gdGhlIGdpdmVuIHN1Ym1pc3Npb24uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdWJtaXNzaW9uXG4gICAqICAgQSBzdWJtaXNzaW9uIG9iamVjdCB0byBzZWFyY2guXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICogICBBIGZvciBjb21wb25lbnRzIEFQSSBrZXkgdG8gc2VhcmNoIGZvci5cbiAgICovXG4gIGdldFZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZShzdWJtaXNzaW9uLCBrZXkpIHtcbiAgICB2YXIgZGF0YSA9IHN1Ym1pc3Npb24uZGF0YSB8fCB7fTtcblxuICAgIHZhciBzZWFyY2ggPSBmdW5jdGlvbiBzZWFyY2goZGF0YSkge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgdmFsdWU7XG5cbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKCh0eXBlb2YgZGF0YSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoZGF0YSkpID09PSAnb2JqZWN0JyAmJiAhKGRhdGEgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIHJldHVybiBkYXRhW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChfdHlwZW9mKGRhdGFba2V5c1tpXV0pID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdmFsdWUgPSBzZWFyY2goZGF0YVtrZXlzW2ldXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBzZWFyY2goZGF0YSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludGVycG9sYXRlIGEgc3RyaW5nIGFuZCBhZGQgZGF0YSByZXBsYWNlbWVudHMuXG4gICAqXG4gICAqIEBwYXJhbSBzdHJpbmdcbiAgICogQHBhcmFtIGRhdGFcbiAgICogQHJldHVybnMge1hNTHxzdHJpbmd8Knx2b2lkfVxuICAgKi9cbiAgaW50ZXJwb2xhdGU6IGZ1bmN0aW9uIGludGVycG9sYXRlKHN0cmluZywgZGF0YSkge1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvXFx7XFx7XFxzKihbXlxcc10qKVxccypcXH1cXH0vZywgZnVuY3Rpb24gKG1hdGNoLCB0b2tlbikge1xuICAgICAgcmV0dXJuIF9nZXQoZGF0YSwgdG9rZW4pO1xuICAgIH0pO1xuICB9XG59OyIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9idWlsZC91dGlscycpO1xuIiwiLyogZ2xvYmFscyBkZWZpbmUsbW9kdWxlICovXG4vKlxuVXNpbmcgYSBVbml2ZXJzYWwgTW9kdWxlIExvYWRlciB0aGF0IHNob3VsZCBiZSBicm93c2VyLCByZXF1aXJlLCBhbmQgQU1EIGZyaWVuZGx5XG5odHRwOi8vcmljb3N0YWNydXouY29tL2NoZWF0c2hlZXRzL3VtZGpzLmh0bWxcbiovXG47KGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZhY3RvcnkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5qc29uTG9naWMgPSBmYWN0b3J5KCk7XG4gIH1cbn0odGhpcywgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICAvKiBnbG9iYWxzIGNvbnNvbGU6ZmFsc2UgKi9cblxuICBpZiAoICEgQXJyYXkuaXNBcnJheSkge1xuICAgIEFycmF5LmlzQXJyYXkgPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJnKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBhcnJheVVuaXF1ZShhcnJheSkge1xuICAgIHZhciBhID0gW107XG4gICAgZm9yICh2YXIgaT0wLCBsPWFycmF5Lmxlbmd0aDsgaTxsOyBpKyspIHtcbiAgICAgIGlmIChhLmluZGV4T2YoYXJyYXlbaV0pID09PSAtMSkge1xuICAgICAgICBhLnB1c2goYXJyYXlbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfVxuXG4gIHZhciBqc29uTG9naWMgPSB7fTtcbiAgdmFyIG9wZXJhdGlvbnMgPSB7XG4gICAgXCI9PVwiOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gYSA9PSBiO1xuICAgIH0sXG4gICAgXCI9PT1cIjogZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgfSxcbiAgICBcIiE9XCI6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHJldHVybiBhICE9IGI7XG4gICAgfSxcbiAgICBcIiE9PVwiOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gYSAhPT0gYjtcbiAgICB9LFxuICAgIFwiPlwiOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gYSA+IGI7XG4gICAgfSxcbiAgICBcIj49XCI6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHJldHVybiBhID49IGI7XG4gICAgfSxcbiAgICBcIjxcIjogZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAgcmV0dXJuIChjID09PSB1bmRlZmluZWQpID8gYSA8IGIgOiAoYSA8IGIpICYmIChiIDwgYyk7XG4gICAgfSxcbiAgICBcIjw9XCI6IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgIHJldHVybiAoYyA9PT0gdW5kZWZpbmVkKSA/IGEgPD0gYiA6IChhIDw9IGIpICYmIChiIDw9IGMpO1xuICAgIH0sXG4gICAgXCIhIVwiOiBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4ganNvbkxvZ2ljLnRydXRoeShhKTtcbiAgICB9LFxuICAgIFwiIVwiOiBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gIWpzb25Mb2dpYy50cnV0aHkoYSk7XG4gICAgfSxcbiAgICBcIiVcIjogZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIGEgJSBiO1xuICAgIH0sXG4gICAgXCJsb2dcIjogZnVuY3Rpb24oYSkge1xuICAgICAgY29uc29sZS5sb2coYSk7IHJldHVybiBhO1xuICAgIH0sXG4gICAgXCJpblwiOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICBpZih0eXBlb2YgYi5pbmRleE9mID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gKGIuaW5kZXhPZihhKSAhPT0gLTEpO1xuICAgIH0sXG4gICAgXCJjYXRcIjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmpvaW4uY2FsbChhcmd1bWVudHMsIFwiXCIpO1xuICAgIH0sXG4gICAgXCIrXCI6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UuY2FsbChhcmd1bWVudHMsIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoYSwgMTApICsgcGFyc2VGbG9hdChiLCAxMCk7XG4gICAgICB9LCAwKTtcbiAgICB9LFxuICAgIFwiKlwiOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUucmVkdWNlLmNhbGwoYXJndW1lbnRzLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGEsIDEwKSAqIHBhcnNlRmxvYXQoYiwgMTApO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBcIi1cIjogZnVuY3Rpb24oYSwgYikge1xuICAgICAgaWYoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAtYTtcbiAgICAgIH1lbHNle1xuICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICB9XG4gICAgfSxcbiAgICBcIi9cIjogZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYSAvIGI7IH0sXG4gICAgXCJtaW5cIjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIFwibWF4XCI6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBcIm1lcmdlXCI6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UuY2FsbChhcmd1bWVudHMsIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuICAgICAgfSwgW10pO1xuICAgIH0sXG4gICAgXCJ2YXJcIjogZnVuY3Rpb24oYSwgYikge1xuICAgICAgdmFyIG5vdF9mb3VuZCA9IChiID09PSB1bmRlZmluZWQpID8gbnVsbCA6IGI7XG4gICAgICB2YXIgc3ViX3Byb3BzID0gU3RyaW5nKGEpLnNwbGl0KFwiLlwiKTtcbiAgICAgIHZhciBkYXRhID0gdGhpcztcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzdWJfcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gRGVzY2VuZGluZyBpbnRvIGRhdGFcbiAgICAgICAgZGF0YSA9IGRhdGFbc3ViX3Byb3BzW2ldXTtcbiAgICAgICAgaWYoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIG5vdF9mb3VuZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcbiAgICBcIm1pc3NpbmdcIjogZnVuY3Rpb24oKSB7XG4gICAgICAvKlxuICAgICAgTWlzc2luZyBjYW4gcmVjZWl2ZSBtYW55IGtleXMgYXMgbWFueSBhcmd1bWVudHMsIGxpa2Uge1wibWlzc2luZzpbMSwyXX1cbiAgICAgIE1pc3NpbmcgY2FuIGFsc28gcmVjZWl2ZSAqb25lKiBhcmd1bWVudCB0aGF0IGlzIGFuIGFycmF5IG9mIGtleXMsXG4gICAgICB3aGljaCB0eXBpY2FsbHkgaGFwcGVucyBpZiBpdCdzIGFjdHVhbGx5IGFjdGluZyBvbiB0aGUgb3V0cHV0IG9mIGFub3RoZXIgY29tbWFuZFxuICAgICAgKGxpa2UgJ2lmJyBvciAnbWVyZ2UnKVxuICAgICAgKi9cblxuICAgICAgdmFyIG1pc3NpbmcgPSBbXTtcbiAgICAgIHZhciBrZXlzID0gQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pID8gYXJndW1lbnRzWzBdIDogYXJndW1lbnRzO1xuXG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgdmFyIHZhbHVlID0ganNvbkxvZ2ljLmFwcGx5KHtcInZhclwiOiBrZXl9LCB0aGlzKTtcbiAgICAgICAgaWYodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICBtaXNzaW5nLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWlzc2luZztcbiAgICB9LFxuICAgIFwibWlzc2luZ19zb21lXCI6IGZ1bmN0aW9uKG5lZWRfY291bnQsIG9wdGlvbnMpIHtcbiAgICAgIC8vIG1pc3Npbmdfc29tZSB0YWtlcyB0d28gYXJndW1lbnRzLCBob3cgbWFueSAobWluaW11bSkgaXRlbXMgbXVzdCBiZSBwcmVzZW50LCBhbmQgYW4gYXJyYXkgb2Yga2V5cyAoanVzdCBsaWtlICdtaXNzaW5nJykgdG8gY2hlY2sgZm9yIHByZXNlbmNlLlxuICAgICAgdmFyIGFyZV9taXNzaW5nID0ganNvbkxvZ2ljLmFwcGx5KHtcIm1pc3NpbmdcIjogb3B0aW9uc30sIHRoaXMpO1xuXG4gICAgICBpZihvcHRpb25zLmxlbmd0aCAtIGFyZV9taXNzaW5nLmxlbmd0aCA+PSBuZWVkX2NvdW50KSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1lbHNle1xuICAgICAgICByZXR1cm4gYXJlX21pc3Npbmc7XG4gICAgICB9XG4gICAgfSxcbiAgICBcIm1ldGhvZFwiOiBmdW5jdGlvbihvYmosIG1ldGhvZCwgYXJncykge1xuICAgICAgcmV0dXJuIG9ialttZXRob2RdLmFwcGx5KG9iaiwgYXJncyk7XG4gICAgfSxcblxuICB9O1xuXG4gIGpzb25Mb2dpYy5pc19sb2dpYyA9IGZ1bmN0aW9uKGxvZ2ljKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGxvZ2ljICE9PSBudWxsICYmIHR5cGVvZiBsb2dpYyA9PT0gXCJvYmplY3RcIiAmJiAhIEFycmF5LmlzQXJyYXkobG9naWMpXG4gICAgKTtcbiAgfTtcblxuICAvKlxuICBUaGlzIGhlbHBlciB3aWxsIGRlZmVyIHRvIHRoZSBKc29uTG9naWMgc3BlYyBhcyBhIHRpZS1icmVha2VyIHdoZW4gZGlmZmVyZW50IGxhbmd1YWdlIGludGVycHJldGVycyBkZWZpbmUgZGlmZmVyZW50IGJlaGF2aW9yIGZvciB0aGUgdHJ1dGhpbmVzcyBvZiBwcmltaXRpdmVzLiAgRS5nLiwgUEhQIGNvbnNpZGVycyBlbXB0eSBhcnJheXMgdG8gYmUgZmFsc3ksIGJ1dCBKYXZhc2NyaXB0IGNvbnNpZGVycyB0aGVtIHRvIGJlIHRydXRoeS4gSnNvbkxvZ2ljLCBhcyBhbiBlY29zeXN0ZW0sIG5lZWRzIG9uZSBjb25zaXN0ZW50IGFuc3dlci5cblxuICBMaXRlcmFsIHwgSlMgICAgfCAgUEhQICB8ICBKc29uTG9naWNcbiAgLS0tLS0tLS0rLS0tLS0tLSstLS0tLS0tKy0tLS0tLS0tLS0tLS0tLVxuICBbXSAgICAgIHwgdHJ1ZSAgfCBmYWxzZSB8IGZhbHNlXG4gIFwiMFwiICAgICB8IHRydWUgIHwgZmFsc2UgfCB0cnVlXG4gICovXG4gIGpzb25Mb2dpYy50cnV0aHkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gISEgdmFsdWU7XG4gIH07XG5cblxuICBqc29uTG9naWMuZ2V0X29wZXJhdG9yID0gZnVuY3Rpb24obG9naWMpe1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhsb2dpYylbMF07XG4gIH07XG5cbiAganNvbkxvZ2ljLmdldF92YWx1ZXMgPSBmdW5jdGlvbihsb2dpYyl7XG4gICAgcmV0dXJuIGxvZ2ljWyBqc29uTG9naWMuZ2V0X29wZXJhdG9yKGxvZ2ljKSBdO1xuICB9O1xuXG4gIGpzb25Mb2dpYy5hcHBseSA9IGZ1bmN0aW9uKGxvZ2ljLCBkYXRhKSB7XG4gICAgLy8gRG9lcyB0aGlzIGFycmF5IGNvbnRhaW4gbG9naWM/IE9ubHkgb25lIHdheSB0byBmaW5kIG91dC5cbiAgICBpZihBcnJheS5pc0FycmF5KGxvZ2ljKSkge1xuICAgICAgcmV0dXJuIGxvZ2ljLm1hcChmdW5jdGlvbihsKSB7XG4gICAgICAgIHJldHVybiBqc29uTG9naWMuYXBwbHkobCwgZGF0YSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gWW91J3ZlIHJlY3Vyc2VkIHRvIGEgcHJpbWl0aXZlLCBzdG9wIVxuICAgIGlmKCAhIGpzb25Mb2dpYy5pc19sb2dpYyhsb2dpYykgKSB7XG4gICAgICByZXR1cm4gbG9naWM7XG4gICAgfVxuXG4gICAgZGF0YSA9IGRhdGEgfHwge307XG5cbiAgICB2YXIgb3AgPSBqc29uTG9naWMuZ2V0X29wZXJhdG9yKGxvZ2ljKTtcbiAgICB2YXIgdmFsdWVzID0gbG9naWNbb3BdO1xuICAgIHZhciBpO1xuICAgIHZhciBjdXJyZW50O1xuXG4gICAgLy8gZWFzeSBzeW50YXggZm9yIHVuYXJ5IG9wZXJhdG9ycywgbGlrZSB7XCJ2YXJcIiA6IFwieFwifSBpbnN0ZWFkIG9mIHN0cmljdCB7XCJ2YXJcIiA6IFtcInhcIl19XG4gICAgaWYoICEgQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICB2YWx1ZXMgPSBbdmFsdWVzXTtcbiAgICB9XG5cbiAgICAvLyAnaWYnLCAnYW5kJywgYW5kICdvcicgdmlvbGF0ZSB0aGUgbm9ybWFsIHJ1bGUgb2YgZGVwdGgtZmlyc3QgY2FsY3VsYXRpbmcgY29uc2VxdWVudHMsIGxldCBlYWNoIG1hbmFnZSByZWN1cnNpb24gYXMgbmVlZGVkLlxuICAgIGlmKG9wID09PSBcImlmXCIgfHwgb3AgPT0gXCI/OlwiKSB7XG4gICAgICAvKiAnaWYnIHNob3VsZCBiZSBjYWxsZWQgd2l0aCBhIG9kZCBudW1iZXIgb2YgcGFyYW1ldGVycywgMyBvciBncmVhdGVyXG4gICAgICBUaGlzIHdvcmtzIG9uIHRoZSBwYXR0ZXJuOlxuICAgICAgaWYoIDAgKXsgMSB9ZWxzZXsgMiB9O1xuICAgICAgaWYoIDAgKXsgMSB9ZWxzZSBpZiggMiApeyAzIH1lbHNleyA0IH07XG4gICAgICBpZiggMCApeyAxIH1lbHNlIGlmKCAyICl7IDMgfWVsc2UgaWYoIDQgKXsgNSB9ZWxzZXsgNiB9O1xuXG4gICAgICBUaGUgaW1wbGVtZW50YXRpb24gaXM6XG4gICAgICBGb3IgcGFpcnMgb2YgdmFsdWVzICgwLDEgdGhlbiAyLDMgdGhlbiA0LDUgZXRjKVxuICAgICAgSWYgdGhlIGZpcnN0IGV2YWx1YXRlcyB0cnV0aHksIGV2YWx1YXRlIGFuZCByZXR1cm4gdGhlIHNlY29uZFxuICAgICAgSWYgdGhlIGZpcnN0IGV2YWx1YXRlcyBmYWxzeSwganVtcCB0byB0aGUgbmV4dCBwYWlyIChlLmcsIDAsMSB0byAyLDMpXG4gICAgICBnaXZlbiBvbmUgcGFyYW1ldGVyLCBldmFsdWF0ZSBhbmQgcmV0dXJuIGl0LiAoaXQncyBhbiBFbHNlIGFuZCBhbGwgdGhlIElmL0Vsc2VJZiB3ZXJlIGZhbHNlKVxuICAgICAgZ2l2ZW4gMCBwYXJhbWV0ZXJzLCByZXR1cm4gTlVMTCAobm90IGdyZWF0IHByYWN0aWNlLCBidXQgdGhlcmUgd2FzIG5vIEVsc2UpXG4gICAgICAqL1xuICAgICAgZm9yKGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aCAtIDE7IGkgKz0gMikge1xuICAgICAgICBpZigganNvbkxvZ2ljLnRydXRoeSgganNvbkxvZ2ljLmFwcGx5KHZhbHVlc1tpXSwgZGF0YSkgKSApIHtcbiAgICAgICAgICByZXR1cm4ganNvbkxvZ2ljLmFwcGx5KHZhbHVlc1tpKzFdLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYodmFsdWVzLmxlbmd0aCA9PT0gaSsxKSByZXR1cm4ganNvbkxvZ2ljLmFwcGx5KHZhbHVlc1tpXSwgZGF0YSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9ZWxzZSBpZihvcCA9PT0gXCJhbmRcIikgeyAvLyBSZXR1cm4gZmlyc3QgZmFsc3ksIG9yIGxhc3RcbiAgICAgIGZvcihpPTA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKz0xKSB7XG4gICAgICAgIGN1cnJlbnQgPSBqc29uTG9naWMuYXBwbHkodmFsdWVzW2ldLCBkYXRhKTtcbiAgICAgICAgaWYoICEganNvbkxvZ2ljLnRydXRoeShjdXJyZW50KSkge1xuICAgICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VycmVudDsgLy8gTGFzdFxuICAgIH1lbHNlIGlmKG9wID09PSBcIm9yXCIpIHsvLyBSZXR1cm4gZmlyc3QgdHJ1dGh5LCBvciBsYXN0XG4gICAgICBmb3IoaT0wOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSs9MSkge1xuICAgICAgICBjdXJyZW50ID0ganNvbkxvZ2ljLmFwcGx5KHZhbHVlc1tpXSwgZGF0YSk7XG4gICAgICAgIGlmKCBqc29uTG9naWMudHJ1dGh5KGN1cnJlbnQpICkge1xuICAgICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VycmVudDsgLy8gTGFzdFxuICAgIH1cblxuXG4gICAgLy8gRXZlcnlvbmUgZWxzZSBnZXRzIGltbWVkaWF0ZSBkZXB0aC1maXJzdCByZWN1cnNpb25cbiAgICB2YWx1ZXMgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuIGpzb25Mb2dpYy5hcHBseSh2YWwsIGRhdGEpO1xuICAgIH0pO1xuXG5cbiAgICAvLyBUaGUgb3BlcmF0aW9uIGlzIGNhbGxlZCB3aXRoIFwiZGF0YVwiIGJvdW5kIHRvIGl0cyBcInRoaXNcIiBhbmQgXCJ2YWx1ZXNcIiBwYXNzZWQgYXMgYXJndW1lbnRzLlxuICAgIC8vIFN0cnVjdHVyZWQgY29tbWFuZHMgbGlrZSAlIG9yID4gY2FuIG5hbWUgZm9ybWFsIGFyZ3VtZW50cyB3aGlsZSBmbGV4aWJsZSBjb21tYW5kcyAobGlrZSBtaXNzaW5nIG9yIG1lcmdlKSBjYW4gb3BlcmF0ZSBvbiB0aGUgcHNldWRvLWFycmF5IGFyZ3VtZW50c1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0Z1bmN0aW9ucy9hcmd1bWVudHNcbiAgICBpZih0eXBlb2Ygb3BlcmF0aW9uc1tvcF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIG9wZXJhdGlvbnNbb3BdLmFwcGx5KGRhdGEsIHZhbHVlcyk7XG4gICAgfWVsc2UgaWYob3AuaW5kZXhPZihcIi5cIikgPiAwKSB7IC8vIENvbnRhaW5zIGEgZG90LCBhbmQgbm90IGluIHRoZSAwdGggcG9zaXRpb25cbiAgICAgIHZhciBzdWJfb3BzID0gU3RyaW5nKG9wKS5zcGxpdChcIi5cIik7XG4gICAgICB2YXIgb3BlcmF0aW9uID0gb3BlcmF0aW9ucztcbiAgICAgIGZvcihpID0gMDsgaSA8IHN1Yl9vcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gRGVzY2VuZGluZyBpbnRvIG9wZXJhdGlvbnNcbiAgICAgICAgb3BlcmF0aW9uID0gb3BlcmF0aW9uW3N1Yl9vcHNbaV1dO1xuICAgICAgICBpZihvcGVyYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBvcGVyYXRpb24gXCIgKyBvcCArXG4gICAgICAgICAgXCIgKGZhaWxlZCBhdCBcIiArIHN1Yl9vcHMuc2xpY2UoMCwgaSsxKS5qb2luKFwiLlwiKSArIFwiKVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3BlcmF0aW9uLmFwcGx5KGRhdGEsIHZhbHVlcyk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIG9wZXJhdGlvbiBcIiArIG9wICk7XG4gIH07XG5cbiAganNvbkxvZ2ljLnVzZXNfZGF0YSA9IGZ1bmN0aW9uKGxvZ2ljKSB7XG4gICAgdmFyIGNvbGxlY3Rpb24gPSBbXTtcblxuICAgIGlmKCBqc29uTG9naWMuaXNfbG9naWMobG9naWMpICkge1xuICAgICAgdmFyIG9wID0ganNvbkxvZ2ljLmdldF9vcGVyYXRvcihsb2dpYyk7XG4gICAgICB2YXIgdmFsdWVzID0gbG9naWNbb3BdO1xuXG4gICAgICBpZiggISBBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgdmFsdWVzID0gW3ZhbHVlc107XG4gICAgICB9XG5cbiAgICAgIGlmKG9wID09PSBcInZhclwiKSB7XG4gICAgICAgIC8vIFRoaXMgZG9lc24ndCBjb3ZlciB0aGUgY2FzZSB3aGVyZSB0aGUgYXJnIHRvIHZhciBpcyBpdHNlbGYgYSBydWxlLlxuICAgICAgICBjb2xsZWN0aW9uLnB1c2godmFsdWVzWzBdKTtcbiAgICAgIH1lbHNle1xuICAgICAgICAvLyBSZWN1cnNpb24hXG4gICAgICAgIHZhbHVlcy5tYXAoZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgY29sbGVjdGlvbi5wdXNoLmFwcGx5KGNvbGxlY3Rpb24sIGpzb25Mb2dpYy51c2VzX2RhdGEodmFsKSApO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlVbmlxdWUoY29sbGVjdGlvbik7XG4gIH07XG5cbiAganNvbkxvZ2ljLmFkZF9vcGVyYXRpb24gPSBmdW5jdGlvbihuYW1lLCBjb2RlKSB7XG4gICAgb3BlcmF0aW9uc1tuYW1lXSA9IGNvZGU7XG4gIH07XG5cblxuICBqc29uTG9naWMucnVsZV9saWtlID0gZnVuY3Rpb24ocnVsZSwgcGF0dGVybil7XG5cdFx0Ly9jb25zb2xlLmxvZyhcIklzIFwiLiBKU09OLnN0cmluZ2lmeShydWxlKSAuIFwiIGxpa2UgXCIgLiBKU09OLnN0cmluZ2lmeShwYXR0ZXJuKSAuIFwiP1wiKTtcblx0ICBpZihwYXR0ZXJuID09PSBydWxlKXsgcmV0dXJuIHRydWU7IH0gLy9UT0RPIDogRGVlcCBvYmplY3QgZXF1aXZhbGVuY3k/XG5cdCAgaWYocGF0dGVybiA9PT0gXCJAXCIpeyByZXR1cm4gdHJ1ZTsgfSAvL1dpbGRjYXJkIVxuXHQgIGlmKHBhdHRlcm4gPT09IFwibnVtYmVyXCIpeyByZXR1cm4gKHR5cGVvZiBydWxlID09PSAnbnVtYmVyJyk7IH1cblx0ICBpZihwYXR0ZXJuID09PSBcInN0cmluZ1wiKXsgcmV0dXJuICh0eXBlb2YgcnVsZSA9PT0gJ3N0cmluZycpOyB9XG5cdCAgaWYocGF0dGVybiA9PT0gXCJhcnJheVwiKXtcbiAgICAgIC8vIWxvZ2ljIHRlc3QgbWlnaHQgYmUgc3VwZXJmbHVvdXMgaW4gSmF2YVNjcmlwdFxuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocnVsZSkgJiYgISBqc29uTG9naWMuaXNfbG9naWMocnVsZSk7XG4gICAgfVxuXG5cdCAgaWYoanNvbkxvZ2ljLmlzX2xvZ2ljKHBhdHRlcm4pKXtcblx0ICAgIGlmKGpzb25Mb2dpYy5pc19sb2dpYyhydWxlKSl7XG5cdCAgICAgIHZhciBwYXR0ZXJuX29wID0ganNvbkxvZ2ljLmdldF9vcGVyYXRvcihwYXR0ZXJuKTtcbiAgICAgICAgdmFyIHJ1bGVfb3AgPSBqc29uTG9naWMuZ2V0X29wZXJhdG9yKHJ1bGUpO1xuXG5cdCAgICAgIGlmKHBhdHRlcm5fb3AgPT09IFwiQFwiIHx8IHBhdHRlcm5fb3AgPT09IHJ1bGVfb3Ape1xuXHRcdFx0XHRcdC8vZWNobyBcIlxcbk9wZXJhdG9ycyBtYXRjaCwgZ28gZGVlcGVyXFxuXCI7XG5cdCAgICAgICAgcmV0dXJuIGpzb25Mb2dpYy5ydWxlX2xpa2UoXG5cdFx0XHRcdFx0XHRqc29uTG9naWMuZ2V0X3ZhbHVlcyhydWxlLCBmYWxzZSksXG5cdFx0XHRcdFx0XHRqc29uTG9naWMuZ2V0X3ZhbHVlcyhwYXR0ZXJuLCBmYWxzZSlcblx0XHRcdFx0XHQpO1xuXHQgICAgICB9XG5cblx0ICAgIH1cblx0ICAgIHJldHVybiBmYWxzZTsgLy9wYXR0ZXJuIGlzIGxvZ2ljLCBydWxlIGlzbid0LCBjYW4ndCBiZSBlcVxuXHQgIH1cblxuXHQgIGlmKEFycmF5LmlzQXJyYXkocGF0dGVybikpe1xuXHQgICAgaWYoQXJyYXkuaXNBcnJheShydWxlKSl7XG5cdCAgICAgIGlmKHBhdHRlcm4ubGVuZ3RoICE9PSBydWxlLmxlbmd0aCl7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHQvKlxuXHRcdFx0XHRcdE5vdGUsIGFycmF5IG9yZGVyIE1BVFRFUlMsIGJlY2F1c2Ugd2UncmUgdXNpbmcgdGhpcyBhcnJheSB0ZXN0IGxvZ2ljIHRvIGNvbnNpZGVyIGFyZ3VtZW50cywgd2hlcmUgb3JkZXIgY2FuIG1hdHRlci4gKGUuZy4sICsgaXMgY29tbXV0YXRpdmUsIGJ1dCAnLScgb3IgJ2lmJyBvciAndmFyJyBhcmUgTk9UKVxuXHRcdFx0XHQqL1xuXHQgICAgICBmb3IodmFyIGkgPSAwIDsgaSA8IHBhdHRlcm4ubGVuZ3RoIDsgaSArPSAxKXtcblx0ICAgICAgICAvL0lmIGFueSBmYWlsLCB3ZSBmYWlsXG5cdCAgICAgICAgaWYoICEganNvbkxvZ2ljLnJ1bGVfbGlrZShydWxlW2ldLCBwYXR0ZXJuW2ldKSl7IHJldHVybiBmYWxzZTsgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB0cnVlOyAvL0lmIHRoZXkgKmFsbCogcGFzc2VkLCB3ZSBwYXNzXG5cdCAgICB9ZWxzZXtcblx0ICAgICAgcmV0dXJuIGZhbHNlOyAvL1BhdHRlcm4gaXMgYXJyYXksIHJ1bGUgaXNuJ3Rcblx0ICAgIH1cblxuXHQgIH1cblxuXHRcdC8vTm90IGxvZ2ljLCBub3QgYXJyYXksIG5vdCBhID09PSBtYXRjaCBmb3IgcnVsZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblxuXG4gIHJldHVybiBqc29uTG9naWM7XG59KSk7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFWaWV3O1xuIiwidmFyIGhhc2hDbGVhciA9IHJlcXVpcmUoJy4vX2hhc2hDbGVhcicpLFxuICAgIGhhc2hEZWxldGUgPSByZXF1aXJlKCcuL19oYXNoRGVsZXRlJyksXG4gICAgaGFzaEdldCA9IHJlcXVpcmUoJy4vX2hhc2hHZXQnKSxcbiAgICBoYXNoSGFzID0gcmVxdWlyZSgnLi9faGFzaEhhcycpLFxuICAgIGhhc2hTZXQgPSByZXF1aXJlKCcuL19oYXNoU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2g7XG4iLCJ2YXIgbGlzdENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVDbGVhcicpLFxuICAgIGxpc3RDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZURlbGV0ZScpLFxuICAgIGxpc3RDYWNoZUdldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUdldCcpLFxuICAgIGxpc3RDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUhhcycpLFxuICAgIGxpc3RDYWNoZVNldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTGlzdENhY2hlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcDtcbiIsInZhciBtYXBDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVDbGVhcicpLFxuICAgIG1hcENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVEZWxldGUnKSxcbiAgICBtYXBDYWNoZUdldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlR2V0JyksXG4gICAgbWFwQ2FjaGVIYXMgPSByZXF1aXJlKCcuL19tYXBDYWNoZUhhcycpLFxuICAgIG1hcENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwQ2FjaGU7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldDtcbiIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyksXG4gICAgc2V0Q2FjaGVBZGQgPSByZXF1aXJlKCcuL19zZXRDYWNoZUFkZCcpLFxuICAgIHNldENhY2hlSGFzID0gcmVxdWlyZSgnLi9fc2V0Q2FjaGVIYXMnKTtcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldENhY2hlO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIHN0YWNrQ2xlYXIgPSByZXF1aXJlKCcuL19zdGFja0NsZWFyJyksXG4gICAgc3RhY2tEZWxldGUgPSByZXF1aXJlKCcuL19zdGFja0RlbGV0ZScpLFxuICAgIHN0YWNrR2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tHZXQnKSxcbiAgICBzdGFja0hhcyA9IHJlcXVpcmUoJy4vX3N0YWNrSGFzJyksXG4gICAgc3RhY2tTZXQgPSByZXF1aXJlKCcuL19zdGFja1NldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhY2s7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gVWludDhBcnJheTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYWtNYXA7XG4iLCIvKipcbiAqIEFkZHMgdGhlIGtleS12YWx1ZSBgcGFpcmAgdG8gYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSBwYWlyIFRoZSBrZXktdmFsdWUgcGFpciB0byBhZGQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBtYXBgLlxuICovXG5mdW5jdGlvbiBhZGRNYXBFbnRyeShtYXAsIHBhaXIpIHtcbiAgLy8gRG9uJ3QgcmV0dXJuIGBtYXAuc2V0YCBiZWNhdXNlIGl0J3Mgbm90IGNoYWluYWJsZSBpbiBJRSAxMS5cbiAgbWFwLnNldChwYWlyWzBdLCBwYWlyWzFdKTtcbiAgcmV0dXJuIG1hcDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhZGRNYXBFbnRyeTtcbiIsIi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIGBzZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYWRkLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgc2V0YC5cbiAqL1xuZnVuY3Rpb24gYWRkU2V0RW50cnkoc2V0LCB2YWx1ZSkge1xuICAvLyBEb24ndCByZXR1cm4gYHNldC5hZGRgIGJlY2F1c2UgaXQncyBub3QgY2hhaW5hYmxlIGluIElFIDExLlxuICBzZXQuYWRkKHZhbHVlKTtcbiAgcmV0dXJuIHNldDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhZGRTZXRFbnRyeTtcbiIsIi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcHBseTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUVhY2g7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlGaWx0ZXI7XG4iLCJ2YXIgYmFzZVRpbWVzID0gcmVxdWlyZSgnLi9fYmFzZVRpbWVzJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TGlrZUtleXM7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TWFwO1xuIiwiLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5UHVzaDtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICogQHBhcmFtIHtib29sZWFufSBbaW5pdEFjY3VtXSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAgYXNcbiAqICB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlSZWR1Y2UoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgaWYgKGluaXRBY2N1bSAmJiBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGFycmF5WysraW5kZXhdO1xuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVJlZHVjZTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlTb21lO1xuIiwidmFyIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnblZhbHVlO1xuIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc29jSW5kZXhPZjtcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ247XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbkluYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduSW4ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnbkluO1xuIiwidmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fZGVmaW5lUHJvcGVydHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICogdmFsdWUgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSkge1xuICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICd2YWx1ZSc6IHZhbHVlLFxuICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduVmFsdWU7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGFycmF5RWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5RWFjaCcpLFxuICAgIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBiYXNlQXNzaWduID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnbicpLFxuICAgIGJhc2VBc3NpZ25JbiA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25JbicpLFxuICAgIGNsb25lQnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVCdWZmZXInKSxcbiAgICBjb3B5QXJyYXkgPSByZXF1aXJlKCcuL19jb3B5QXJyYXknKSxcbiAgICBjb3B5U3ltYm9scyA9IHJlcXVpcmUoJy4vX2NvcHlTeW1ib2xzJyksXG4gICAgY29weVN5bWJvbHNJbiA9IHJlcXVpcmUoJy4vX2NvcHlTeW1ib2xzSW4nKSxcbiAgICBnZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5cycpLFxuICAgIGdldEFsbEtleXNJbiA9IHJlcXVpcmUoJy4vX2dldEFsbEtleXNJbicpLFxuICAgIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGluaXRDbG9uZUFycmF5ID0gcmVxdWlyZSgnLi9faW5pdENsb25lQXJyYXknKSxcbiAgICBpbml0Q2xvbmVCeVRhZyA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZUJ5VGFnJyksXG4gICAgaW5pdENsb25lT2JqZWN0ID0gcmVxdWlyZSgnLi9faW5pdENsb25lT2JqZWN0JyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxLFxuICAgIENMT05FX0ZMQVRfRkxBRyA9IDIsXG4gICAgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBzdXBwb3J0ZWQgYnkgYF8uY2xvbmVgLiAqL1xudmFyIGNsb25lYWJsZVRhZ3MgPSB7fTtcbmNsb25lYWJsZVRhZ3NbYXJnc1RhZ10gPSBjbG9uZWFibGVUYWdzW2FycmF5VGFnXSA9XG5jbG9uZWFibGVUYWdzW2FycmF5QnVmZmVyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0YVZpZXdUYWddID1cbmNsb25lYWJsZVRhZ3NbYm9vbFRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGVUYWddID1cbmNsb25lYWJsZVRhZ3NbZmxvYXQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW2Zsb2F0NjRUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDE2VGFnXSA9XG5jbG9uZWFibGVUYWdzW2ludDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbbWFwVGFnXSA9XG5jbG9uZWFibGVUYWdzW251bWJlclRhZ10gPSBjbG9uZWFibGVUYWdzW29iamVjdFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tyZWdleHBUYWddID0gY2xvbmVhYmxlVGFnc1tzZXRUYWddID1cbmNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3ltYm9sVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuY2xvbmVhYmxlVGFnc1tlcnJvclRhZ10gPSBjbG9uZWFibGVUYWdzW2Z1bmNUYWddID1cbmNsb25lYWJsZVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbG9uZWAgYW5kIGBfLmNsb25lRGVlcGAgd2hpY2ggdHJhY2tzXG4gKiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIERlZXAgY2xvbmVcbiAqICAyIC0gRmxhdHRlbiBpbmhlcml0ZWQgcHJvcGVydGllc1xuICogIDQgLSBDbG9uZSBzeW1ib2xzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IFtrZXldIFRoZSBrZXkgb2YgYHZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgcGFyZW50IG9iamVjdCBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGFuZCB0aGVpciBjbG9uZSBjb3VudGVycGFydHMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlQ2xvbmUodmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgb2JqZWN0LCBzdGFjaykge1xuICB2YXIgcmVzdWx0LFxuICAgICAgaXNEZWVwID0gYml0bWFzayAmIENMT05FX0RFRVBfRkxBRyxcbiAgICAgIGlzRmxhdCA9IGJpdG1hc2sgJiBDTE9ORV9GTEFUX0ZMQUcsXG4gICAgICBpc0Z1bGwgPSBiaXRtYXNrICYgQ0xPTkVfU1lNQk9MU19GTEFHO1xuXG4gIGlmIChjdXN0b21pemVyKSB7XG4gICAgcmVzdWx0ID0gb2JqZWN0ID8gY3VzdG9taXplcih2YWx1ZSwga2V5LCBvYmplY3QsIHN0YWNrKSA6IGN1c3RvbWl6ZXIodmFsdWUpO1xuICB9XG4gIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gIGlmIChpc0Fycikge1xuICAgIHJlc3VsdCA9IGluaXRDbG9uZUFycmF5KHZhbHVlKTtcbiAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgcmV0dXJuIGNvcHlBcnJheSh2YWx1ZSwgcmVzdWx0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSksXG4gICAgICAgIGlzRnVuYyA9IHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG5cbiAgICBpZiAoaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY2xvbmVCdWZmZXIodmFsdWUsIGlzRGVlcCk7XG4gICAgfVxuICAgIGlmICh0YWcgPT0gb2JqZWN0VGFnIHx8IHRhZyA9PSBhcmdzVGFnIHx8IChpc0Z1bmMgJiYgIW9iamVjdCkpIHtcbiAgICAgIHJlc3VsdCA9IChpc0ZsYXQgfHwgaXNGdW5jKSA/IHt9IDogaW5pdENsb25lT2JqZWN0KHZhbHVlKTtcbiAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgIHJldHVybiBpc0ZsYXRcbiAgICAgICAgICA/IGNvcHlTeW1ib2xzSW4odmFsdWUsIGJhc2VBc3NpZ25JbihyZXN1bHQsIHZhbHVlKSlcbiAgICAgICAgICA6IGNvcHlTeW1ib2xzKHZhbHVlLCBiYXNlQXNzaWduKHJlc3VsdCwgdmFsdWUpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFjbG9uZWFibGVUYWdzW3RhZ10pIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCA/IHZhbHVlIDoge307XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBpbml0Q2xvbmVCeVRhZyh2YWx1ZSwgdGFnLCBiYXNlQ2xvbmUsIGlzRGVlcCk7XG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gaXRzIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KHZhbHVlKTtcbiAgaWYgKHN0YWNrZWQpIHtcbiAgICByZXR1cm4gc3RhY2tlZDtcbiAgfVxuICBzdGFjay5zZXQodmFsdWUsIHJlc3VsdCk7XG5cbiAgdmFyIGtleXNGdW5jID0gaXNGdWxsXG4gICAgPyAoaXNGbGF0ID8gZ2V0QWxsS2V5c0luIDogZ2V0QWxsS2V5cylcbiAgICA6IChpc0ZsYXQgPyBrZXlzSW4gOiBrZXlzKTtcblxuICB2YXIgcHJvcHMgPSBpc0FyciA/IHVuZGVmaW5lZCA6IGtleXNGdW5jKHZhbHVlKTtcbiAgYXJyYXlFYWNoKHByb3BzIHx8IHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICBrZXkgPSBzdWJWYWx1ZTtcbiAgICAgIHN1YlZhbHVlID0gdmFsdWVba2V5XTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBhc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ2xvbmU7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbnZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcbiAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICB9XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNyZWF0ZTtcbiIsInZhciBiYXNlRm9yT3duID0gcmVxdWlyZSgnLi9fYmFzZUZvck93bicpLFxuICAgIGNyZWF0ZUJhc2VFYWNoID0gcmVxdWlyZSgnLi9fY3JlYXRlQmFzZUVhY2gnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqL1xudmFyIGJhc2VFYWNoID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93bik7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUVhY2g7XG4iLCJ2YXIgYmFzZUVhY2ggPSByZXF1aXJlKCcuL19iYXNlRWFjaCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbHRlcmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlRmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZpbHRlcjtcbiIsInZhciBjcmVhdGVCYXNlRm9yID0gcmVxdWlyZSgnLi9fY3JlYXRlQmFzZUZvcicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xudmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvcjtcbiIsInZhciBiYXNlRm9yID0gcmVxdWlyZSgnLi9fYmFzZUZvcicpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGb3JPd247XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0O1xuIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRBbGxLZXlzO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGdldFJhd1RhZyA9IHJlcXVpcmUoJy4vX2dldFJhd1RhZycpLFxuICAgIG9iamVjdFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fb2JqZWN0VG9TdHJpbmcnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldFRhZztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VIYXNJbihvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYga2V5IGluIE9iamVjdChvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VIYXNJbjtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzQXJndW1lbnRzO1xuIiwidmFyIGJhc2VJc0VxdWFsRGVlcCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsRGVlcCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0VxdWFsO1xuIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBlcXVhbEFycmF5cyA9IHJlcXVpcmUoJy4vX2VxdWFsQXJyYXlzJyksXG4gICAgZXF1YWxCeVRhZyA9IHJlcXVpcmUoJy4vX2VxdWFsQnlUYWcnKSxcbiAgICBlcXVhbE9iamVjdHMgPSByZXF1aXJlKCcuL19lcXVhbE9iamVjdHMnKSxcbiAgICBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICBvYmpJc09iaiA9IGZhbHNlO1xuICB9XG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gIH1cbiAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWxEZWVwO1xuIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBiYXNlSXNFcXVhbCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7QXJyYXl9IG1hdGNoRGF0YSBUaGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3MgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCxcbiAgICAgIGxlbmd0aCA9IGluZGV4LFxuICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuICFsZW5ndGg7XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIGlmICgobm9DdXN0b21pemVyICYmIGRhdGFbMl0pXG4gICAgICAgICAgPyBkYXRhWzFdICE9PSBvYmplY3RbZGF0YVswXV1cbiAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIHZhciBrZXkgPSBkYXRhWzBdLFxuICAgICAgICBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2s7XG4gICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgICAgIDogcmVzdWx0XG4gICAgICAgICAgKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc01hdGNoO1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc01hc2tlZCA9IHJlcXVpcmUoJy4vX2lzTWFza2VkJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc05hdGl2ZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNUeXBlZEFycmF5O1xuIiwidmFyIGJhc2VNYXRjaGVzID0gcmVxdWlyZSgnLi9fYmFzZU1hdGNoZXMnKSxcbiAgICBiYXNlTWF0Y2hlc1Byb3BlcnR5ID0gcmVxdWlyZSgnLi9fYmFzZU1hdGNoZXNQcm9wZXJ0eScpLFxuICAgIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBwcm9wZXJ0eSA9IHJlcXVpcmUoJy4vcHJvcGVydHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4gIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpXG4gICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXRlcmF0ZWU7XG4iLCJ2YXIgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXMgPSByZXF1aXJlKCcuL19uYXRpdmVLZXlzJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5cztcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAgbmF0aXZlS2V5c0luID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5c0luJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgfVxuICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXNJbjtcbiIsInZhciBiYXNlSXNNYXRjaCA9IHJlcXVpcmUoJy4vX2Jhc2VJc01hdGNoJyksXG4gICAgZ2V0TWF0Y2hEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWF0Y2hEYXRhJyksXG4gICAgbWF0Y2hlc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlcyhzb3VyY2UpIHtcbiAgdmFyIG1hdGNoRGF0YSA9IGdldE1hdGNoRGF0YShzb3VyY2UpO1xuICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShtYXRjaERhdGFbMF1bMF0sIG1hdGNoRGF0YVswXVsxXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWF0Y2hlcztcbiIsInZhciBiYXNlSXNFcXVhbCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsJyksXG4gICAgZ2V0ID0gcmVxdWlyZSgnLi9nZXQnKSxcbiAgICBoYXNJbiA9IHJlcXVpcmUoJy4vaGFzSW4nKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgaXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9faXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAgbWF0Y2hlc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZScpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNQcm9wZXJ0eWAgd2hpY2ggZG9lc24ndCBjbG9uZSBgc3JjVmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gIGlmIChpc0tleShwYXRoKSAmJiBpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKHRvS2V5KHBhdGgpLCBzcmNWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBvYmpWYWx1ZSA9IGdldChvYmplY3QsIHBhdGgpO1xuICAgIHJldHVybiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvYmpWYWx1ZSA9PT0gc3JjVmFsdWUpXG4gICAgICA/IGhhc0luKG9iamVjdCwgcGF0aClcbiAgICAgIDogYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXRjaGVzUHJvcGVydHk7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQcm9wZXJ0eTtcbiIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVByb3BlcnR5YCB3aGljaCBzdXBwb3J0cyBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAocGF0aCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUHJvcGVydHlEZWVwO1xuIiwidmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpLFxuICAgIG92ZXJSZXN0ID0gcmVxdWlyZSgnLi9fb3ZlclJlc3QnKSxcbiAgICBzZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX3NldFRvU3RyaW5nJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCBzdGFydCwgaWRlbnRpdHkpLCBmdW5jICsgJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VSZXN0O1xuIiwidmFyIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2V0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDEsXG4gICAgICBuZXN0ZWQgPSBvYmplY3Q7XG5cbiAgd2hpbGUgKG5lc3RlZCAhPSBudWxsICYmICsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pLFxuICAgICAgICBuZXdWYWx1ZSA9IHZhbHVlO1xuXG4gICAgaWYgKGluZGV4ICE9IGxhc3RJbmRleCkge1xuICAgICAgdmFyIG9ialZhbHVlID0gbmVzdGVkW2tleV07XG4gICAgICBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKG9ialZhbHVlLCBrZXksIG5lc3RlZCkgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdWYWx1ZSA9IGlzT2JqZWN0KG9ialZhbHVlKVxuICAgICAgICAgID8gb2JqVmFsdWVcbiAgICAgICAgICA6IChpc0luZGV4KHBhdGhbaW5kZXggKyAxXSkgPyBbXSA6IHt9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXNzaWduVmFsdWUobmVzdGVkLCBrZXksIG5ld1ZhbHVlKTtcbiAgICBuZXN0ZWQgPSBuZXN0ZWRba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTZXQ7XG4iLCJ2YXIgY29uc3RhbnQgPSByZXF1aXJlKCcuL2NvbnN0YW50JyksXG4gICAgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19kZWZpbmVQcm9wZXJ0eScpLFxuICAgIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXRUb1N0cmluZ2Agd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBiYXNlU2V0VG9TdHJpbmcgPSAhZGVmaW5lUHJvcGVydHkgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIHN0cmluZykge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHkoZnVuYywgJ3RvU3RyaW5nJywge1xuICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICdlbnVtZXJhYmxlJzogZmFsc2UsXG4gICAgJ3ZhbHVlJzogY29uc3RhbnQoc3RyaW5nKSxcbiAgICAnd3JpdGFibGUnOiB0cnVlXG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2V0VG9TdHJpbmc7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUaW1lcztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUb1N0cmluZztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5hcnk7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYWNoZUhhcztcbiIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIHN0cmluZ1RvUGF0aCA9IHJlcXVpcmUoJy4vX3N0cmluZ1RvUGF0aCcpLFxuICAgIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhc3RQYXRoO1xuIiwidmFyIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCcuL19VaW50OEFycmF5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUFycmF5QnVmZmVyO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsIGlzRGVlcCkge1xuICBpZiAoaXNEZWVwKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICB9XG4gIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVCdWZmZXI7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGRhdGFWaWV3YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFWaWV3IFRoZSBkYXRhIHZpZXcgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGRhdGEgdmlldy5cbiAqL1xuZnVuY3Rpb24gY2xvbmVEYXRhVmlldyhkYXRhVmlldywgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKGRhdGFWaWV3LmJ1ZmZlcikgOiBkYXRhVmlldy5idWZmZXI7XG4gIHJldHVybiBuZXcgZGF0YVZpZXcuY29uc3RydWN0b3IoYnVmZmVyLCBkYXRhVmlldy5ieXRlT2Zmc2V0LCBkYXRhVmlldy5ieXRlTGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZURhdGFWaWV3O1xuIiwidmFyIGFkZE1hcEVudHJ5ID0gcmVxdWlyZSgnLi9fYWRkTWFwRW50cnknKSxcbiAgICBhcnJheVJlZHVjZSA9IHJlcXVpcmUoJy4vX2FycmF5UmVkdWNlJyksXG4gICAgbWFwVG9BcnJheSA9IHJlcXVpcmUoJy4vX21hcFRvQXJyYXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNsb25lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2xvbmVGdW5jIFRoZSBmdW5jdGlvbiB0byBjbG9uZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIG1hcC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVNYXAobWFwLCBpc0RlZXAsIGNsb25lRnVuYykge1xuICB2YXIgYXJyYXkgPSBpc0RlZXAgPyBjbG9uZUZ1bmMobWFwVG9BcnJheShtYXApLCBDTE9ORV9ERUVQX0ZMQUcpIDogbWFwVG9BcnJheShtYXApO1xuICByZXR1cm4gYXJyYXlSZWR1Y2UoYXJyYXksIGFkZE1hcEVudHJ5LCBuZXcgbWFwLmNvbnN0cnVjdG9yKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZU1hcDtcbiIsIi8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgcmVnZXhwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHJlZ2V4cCBUaGUgcmVnZXhwIHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHJlZ2V4cC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVSZWdFeHAocmVnZXhwKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgcmVnZXhwLmNvbnN0cnVjdG9yKHJlZ2V4cC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhyZWdleHApKTtcbiAgcmVzdWx0Lmxhc3RJbmRleCA9IHJlZ2V4cC5sYXN0SW5kZXg7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVSZWdFeHA7XG4iLCJ2YXIgYWRkU2V0RW50cnkgPSByZXF1aXJlKCcuL19hZGRTZXRFbnRyeScpLFxuICAgIGFycmF5UmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXlSZWR1Y2UnKSxcbiAgICBzZXRUb0FycmF5ID0gcmVxdWlyZSgnLi9fc2V0VG9BcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDE7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBzZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbG9uZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNsb25lIHZhbHVlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgc2V0LlxuICovXG5mdW5jdGlvbiBjbG9uZVNldChzZXQsIGlzRGVlcCwgY2xvbmVGdW5jKSB7XG4gIHZhciBhcnJheSA9IGlzRGVlcCA/IGNsb25lRnVuYyhzZXRUb0FycmF5KHNldCksIENMT05FX0RFRVBfRkxBRykgOiBzZXRUb0FycmF5KHNldCk7XG4gIHJldHVybiBhcnJheVJlZHVjZShhcnJheSwgYWRkU2V0RW50cnksIG5ldyBzZXQuY29uc3RydWN0b3IpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lU2V0O1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGBzeW1ib2xgIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHN5bWJvbCBUaGUgc3ltYm9sIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzeW1ib2wgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjbG9uZVN5bWJvbChzeW1ib2wpIHtcbiAgcmV0dXJuIHN5bWJvbFZhbHVlT2YgPyBPYmplY3Qoc3ltYm9sVmFsdWVPZi5jYWxsKHN5bWJvbCkpIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVTeW1ib2w7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVR5cGVkQXJyYXk7XG4iLCIvKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsIGFycmF5KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5QXJyYXk7XG4iLCJ2YXIgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpO1xuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5T2JqZWN0O1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKTtcblxuLyoqXG4gKiBDb3BpZXMgb3duIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzKHNvdXJjZSwgb2JqZWN0KSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9scyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlTeW1ib2xzO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAgZ2V0U3ltYm9sc0luID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9sc0luJyk7XG5cbi8qKlxuICogQ29waWVzIG93biBhbmQgaW5oZXJpdGVkIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzSW4oc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzSW4oc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5U3ltYm9sc0luO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZUpzRGF0YTtcbiIsInZhciBiYXNlUmVzdCA9IHJlcXVpcmUoJy4vX2Jhc2VSZXN0JyksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSByZXF1aXJlKCcuL19pc0l0ZXJhdGVlQ2FsbCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmFzc2lnbmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc291cmNlcy5sZW5ndGgsXG4gICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgIGN1c3RvbWl6ZXIgPSAoYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKVxuICAgICAgPyAobGVuZ3RoLS0sIGN1c3RvbWl6ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcbiAgICAgIGxlbmd0aCA9IDE7XG4gICAgfVxuICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBpbmRleCwgY3VzdG9taXplcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFzc2lnbmVyO1xuIiwidmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgYmFzZUVhY2hgIG9yIGBiYXNlRWFjaFJpZ2h0YCBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFYWNoKGVhY2hGdW5jLCBmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJhc2VFYWNoO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQmFzZUZvcjtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICByZXR1cm4gZnVuYztcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lUHJvcGVydHk7XG4iLCJ2YXIgU2V0Q2FjaGUgPSByZXF1aXJlKCcuL19TZXRDYWNoZScpLFxuICAgIGFycmF5U29tZSA9IHJlcXVpcmUoJy4vX2FycmF5U29tZScpLFxuICAgIGNhY2hlSGFzID0gcmVxdWlyZSgnLi9fY2FjaGVIYXMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbEFycmF5cztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBVaW50OEFycmF5ID0gcmVxdWlyZSgnLi9fVWludDhBcnJheScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGVxdWFsQXJyYXlzID0gcmVxdWlyZSgnLi9fZXF1YWxBcnJheXMnKSxcbiAgICBtYXBUb0FycmF5ID0gcmVxdWlyZSgnLi9fbWFwVG9BcnJheScpLFxuICAgIHNldFRvQXJyYXkgPSByZXF1aXJlKCcuL19zZXRUb0FycmF5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxCeVRhZztcbiIsInZhciBnZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5cycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbE9iamVjdHM7XG4iLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZyZWVHbG9iYWw7XG4iLCJ2YXIgYmFzZUdldEFsbEtleXMgPSByZXF1aXJlKCcuL19iYXNlR2V0QWxsS2V5cycpLFxuICAgIGdldFN5bWJvbHMgPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFsbEtleXM7XG4iLCJ2YXIgYmFzZUdldEFsbEtleXMgPSByZXF1aXJlKCcuL19iYXNlR2V0QWxsS2V5cycpLFxuICAgIGdldFN5bWJvbHNJbiA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHNJbicpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzSW4sIGdldFN5bWJvbHNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWxsS2V5c0luO1xuIiwidmFyIGlzS2V5YWJsZSA9IHJlcXVpcmUoJy4vX2lzS2V5YWJsZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFwRGF0YTtcbiIsInZhciBpc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19pc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3Mgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hEYXRhKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0ga2V5cyhvYmplY3QpLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICB2YXIga2V5ID0gcmVzdWx0W2xlbmd0aF0sXG4gICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICByZXN1bHRbbGVuZ3RoXSA9IFtrZXksIHZhbHVlLCBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hdGNoRGF0YTtcbiIsInZhciBiYXNlSXNOYXRpdmUgPSByZXF1aXJlKCcuL19iYXNlSXNOYXRpdmUnKSxcbiAgICBnZXRWYWx1ZSA9IHJlcXVpcmUoJy4vX2dldFZhbHVlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TmF0aXZlO1xuIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFByb3RvdHlwZTtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhd1RhZztcbiIsInZhciBhcnJheUZpbHRlciA9IHJlcXVpcmUoJy4vX2FycmF5RmlsdGVyJyksXG4gICAgc3R1YkFycmF5ID0gcmVxdWlyZSgnLi9zdHViQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFN5bWJvbHM7XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKSxcbiAgICBzdHViQXJyYXkgPSByZXF1aXJlKCcuL3N0dWJBcnJheScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzSW4gPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHdoaWxlIChvYmplY3QpIHtcbiAgICBhcnJheVB1c2gocmVzdWx0LCBnZXRTeW1ib2xzKG9iamVjdCkpO1xuICAgIG9iamVjdCA9IGdldFByb3RvdHlwZShvYmplY3QpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFN5bWJvbHNJbjtcbiIsInZhciBEYXRhVmlldyA9IHJlcXVpcmUoJy4vX0RhdGFWaWV3JyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgUHJvbWlzZSA9IHJlcXVpcmUoJy4vX1Byb21pc2UnKSxcbiAgICBTZXQgPSByZXF1aXJlKCcuL19TZXQnKSxcbiAgICBXZWFrTWFwID0gcmVxdWlyZSgnLi9fV2Vha01hcCcpLFxuICAgIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFRhZztcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFZhbHVlO1xuIiwidmFyIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBmYWxzZTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1BhdGg7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaERlbGV0ZTtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hHZXQ7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoSGFzO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoU2V0O1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgLy8gQWRkIHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYC5cbiAgaWYgKGxlbmd0aCAmJiB0eXBlb2YgYXJyYXlbMF0gPT0gJ3N0cmluZycgJiYgaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgJ2luZGV4JykpIHtcbiAgICByZXN1bHQuaW5kZXggPSBhcnJheS5pbmRleDtcbiAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZUFycmF5O1xuIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyksXG4gICAgY2xvbmVEYXRhVmlldyA9IHJlcXVpcmUoJy4vX2Nsb25lRGF0YVZpZXcnKSxcbiAgICBjbG9uZU1hcCA9IHJlcXVpcmUoJy4vX2Nsb25lTWFwJyksXG4gICAgY2xvbmVSZWdFeHAgPSByZXF1aXJlKCcuL19jbG9uZVJlZ0V4cCcpLFxuICAgIGNsb25lU2V0ID0gcmVxdWlyZSgnLi9fY2xvbmVTZXQnKSxcbiAgICBjbG9uZVN5bWJvbCA9IHJlcXVpcmUoJy4vX2Nsb25lU3ltYm9sJyksXG4gICAgY2xvbmVUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fY2xvbmVUeXBlZEFycmF5Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNsb25lRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2xvbmUgdmFsdWVzLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgY2xvbmVGdW5jLCBpc0RlZXApIHtcbiAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIHJldHVybiBjbG9uZUFycmF5QnVmZmVyKG9iamVjdCk7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKCtvYmplY3QpO1xuXG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIHJldHVybiBjbG9uZURhdGFWaWV3KG9iamVjdCwgaXNEZWVwKTtcblxuICAgIGNhc2UgZmxvYXQzMlRhZzogY2FzZSBmbG9hdDY0VGFnOlxuICAgIGNhc2UgaW50OFRhZzogY2FzZSBpbnQxNlRhZzogY2FzZSBpbnQzMlRhZzpcbiAgICBjYXNlIHVpbnQ4VGFnOiBjYXNlIHVpbnQ4Q2xhbXBlZFRhZzogY2FzZSB1aW50MTZUYWc6IGNhc2UgdWludDMyVGFnOlxuICAgICAgcmV0dXJuIGNsb25lVHlwZWRBcnJheShvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHJldHVybiBjbG9uZU1hcChvYmplY3QsIGlzRGVlcCwgY2xvbmVGdW5jKTtcblxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKG9iamVjdCk7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVJlZ0V4cChvYmplY3QpO1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICByZXR1cm4gY2xvbmVTZXQob2JqZWN0LCBpc0RlZXAsIGNsb25lRnVuYyk7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVN5bWJvbChvYmplY3QpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lQnlUYWc7XG4iLCJ2YXIgYmFzZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX2Jhc2VDcmVhdGUnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVPYmplY3Q7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJlxuICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICApIHtcbiAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0l0ZXJhdGVlQ2FsbDtcbiIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleWFibGU7XG4iLCJ2YXIgY29yZUpzRGF0YSA9IHJlcXVpcmUoJy4vX2NvcmVKc0RhdGEnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc01hc2tlZDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1Byb3RvdHlwZTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAqICBlcXVhbGl0eSBjb21wYXJpc29ucywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3RyaWN0Q29tcGFyYWJsZTtcbiIsIi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVDbGVhcjtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZURlbGV0ZTtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVHZXQ7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUhhcztcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZVNldDtcbiIsInZhciBIYXNoID0gcmVxdWlyZSgnLi9fSGFzaCcpLFxuICAgIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVDbGVhcjtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZURlbGV0ZTtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVHZXQ7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUhhcztcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVTZXQ7XG4iLCIvKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcFRvQXJyYXk7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0Y2hlc1N0cmljdENvbXBhcmFibGU7XG4iLCJ2YXIgbWVtb2l6ZSA9IHJlcXVpcmUoJy4vbWVtb2l6ZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG52YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9KTtcblxuICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZUNhcHBlZDtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVDcmVhdGU7XG4iLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXM7XG4iLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzSW47XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGVVdGlsO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb2JqZWN0VG9TdHJpbmc7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyQXJnO1xuIiwidmFyIGFwcGx5ID0gcmVxdWlyZSgnLi9fYXBwbHknKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIGluZGV4ID0gLTE7XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtKGFycmF5KTtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyUmVzdDtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcbiIsIi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBhZGRcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQGFsaWFzIHB1c2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldENhY2hlQWRkO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldENhY2hlSGFzO1xuIiwiLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUb0FycmF5O1xuIiwidmFyIGJhc2VTZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX2Jhc2VTZXRUb1N0cmluZycpLFxuICAgIHNob3J0T3V0ID0gcmVxdWlyZSgnLi9fc2hvcnRPdXQnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgZnVuY2AgdG8gcmV0dXJuIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUb1N0cmluZztcbiIsIi8qKiBVc2VkIHRvIGRldGVjdCBob3QgZnVuY3Rpb25zIGJ5IG51bWJlciBvZiBjYWxscyB3aXRoaW4gYSBzcGFuIG9mIG1pbGxpc2Vjb25kcy4gKi9cbnZhciBIT1RfQ09VTlQgPSA4MDAsXG4gICAgSE9UX1NQQU4gPSAxNjtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU5vdyA9IERhdGUubm93O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0J2xsIHNob3J0IG91dCBhbmQgaW52b2tlIGBpZGVudGl0eWAgaW5zdGVhZFxuICogb2YgYGZ1bmNgIHdoZW4gaXQncyBjYWxsZWQgYEhPVF9DT1VOVGAgb3IgbW9yZSB0aW1lcyBpbiBgSE9UX1NQQU5gXG4gKiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc2hvcnRhYmxlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XG4gIHZhciBjb3VudCA9IDAsXG4gICAgICBsYXN0Q2FsbGVkID0gMDtcblxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YW1wID0gbmF0aXZlTm93KCksXG4gICAgICAgIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG5cbiAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgIGlmICgrK2NvdW50ID49IEhPVF9DT1VOVCkge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG9ydE91dDtcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0NsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrRGVsZXRlO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrR2V0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0hhcztcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKSxcbiAgICBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrU2V0O1xuIiwidmFyIG1lbW9pemVDYXBwZWQgPSByZXF1aXJlKCcuL19tZW1vaXplQ2FwcGVkJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUxlYWRpbmdEb3QgPSAvXlxcLi8sXG4gICAgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHJlTGVhZGluZ0RvdC50ZXN0KHN0cmluZykpIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdUb1BhdGg7XG4iLCJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvS2V5O1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU291cmNlO1xuIiwidmFyIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGNyZWF0ZUFzc2lnbmVyID0gcmVxdWlyZSgnLi9fY3JlYXRlQXNzaWduZXInKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgdG8gdGhlXG4gKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC5cbiAqIFN1YnNlcXVlbnQgc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YCBhbmQgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BPYmplY3QuYXNzaWduYF0oaHR0cHM6Ly9tZG4uaW8vT2JqZWN0L2Fzc2lnbikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEwLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBzZWUgXy5hc3NpZ25JblxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogZnVuY3Rpb24gQmFyKCkge1xuICogICB0aGlzLmMgPSAzO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYiA9IDI7XG4gKiBCYXIucHJvdG90eXBlLmQgPSA0O1xuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAwIH0sIG5ldyBGb28sIG5ldyBCYXIpO1xuICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gKi9cbnZhciBhc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSkge1xuICBpZiAoaXNQcm90b3R5cGUoc291cmNlKSB8fCBpc0FycmF5TGlrZShzb3VyY2UpKSB7XG4gICAgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnbjtcbiIsInZhciBiYXNlQ2xvbmUgPSByZXF1aXJlKCcuL19iYXNlQ2xvbmUnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxLFxuICAgIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZWAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgY2xvbmVzIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAxLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJlY3Vyc2l2ZWx5IGNsb25lLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICogQHNlZSBfLmNsb25lXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICpcbiAqIHZhciBkZWVwID0gXy5jbG9uZURlZXAob2JqZWN0cyk7XG4gKiBjb25zb2xlLmxvZyhkZWVwWzBdID09PSBvYmplY3RzWzBdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSkge1xuICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lRGVlcDtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnN0YW50O1xuIiwiLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXE7XG4iLCJ2YXIgYXJyYXlGaWx0ZXIgPSByZXF1aXJlKCcuL19hcnJheUZpbHRlcicpLFxuICAgIGJhc2VGaWx0ZXIgPSByZXF1aXJlKCcuL19iYXNlRmlsdGVyJyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYWxsIGVsZW1lbnRzXG4gKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiAqKk5vdGU6KiogVW5saWtlIGBfLnJlbW92ZWAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICogQHNlZSBfLnJlamVjdFxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAqIF07XG4gKlxuICogXy5maWx0ZXIodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbHRlcih1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmlsdGVyKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maWx0ZXIodXNlcnMsICdhY3RpdmUnKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAqL1xuZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUZpbHRlciA6IGJhc2VGaWx0ZXI7XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaWx0ZXI7XG4iLCJ2YXIgYmFzZUdldCA9IHJlcXVpcmUoJy4vX2Jhc2VHZXQnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjcuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gKlxuICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gKiAvLyA9PiAnZGVmYXVsdCdcbiAqL1xuZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldDtcbiIsInZhciBiYXNlSGFzSW4gPSByZXF1aXJlKCcuL19iYXNlSGFzSW4nKSxcbiAgICBoYXNQYXRoID0gcmVxdWlyZSgnLi9faGFzUGF0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzSW47XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlkZW50aXR5O1xuIiwidmFyIGJhc2VJc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vX2Jhc2VJc0FyZ3VtZW50cycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJndW1lbnRzO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290JyksXG4gICAgc3R1YkZhbHNlID0gcmVxdWlyZSgnLi9zdHViRmFsc2UnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmZmVyO1xuIiwidmFyIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWwnKTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlXG4gKiBlcXVpdmFsZW50LlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucyxcbiAqIGRhdGUgb2JqZWN0cywgZXJyb3Igb2JqZWN0cywgbWFwcywgbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcyxcbiAqIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZCBhcnJheXMuIGBPYmplY3RgIG9iamVjdHMgYXJlIGNvbXBhcmVkXG4gKiBieSB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy4gRnVuY3Rpb25zIGFuZCBET01cbiAqIG5vZGVzIGFyZSBjb21wYXJlZCBieSBzdHJpY3QgZXF1YWxpdHksIGkuZS4gYD09PWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uaXNFcXVhbChvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBvYmplY3QgPT09IG90aGVyO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFcXVhbCh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFcXVhbDtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNMZW5ndGg7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N5bWJvbDtcbiIsInZhciBiYXNlSXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fYmFzZUlzVHlwZWRBcnJheScpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUeXBlZEFycmF5O1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXMgPSByZXF1aXJlKCcuL19iYXNlS2V5cycpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzO1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzSW4nKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c0luO1xuIiwidmFyIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemU7XG4iLCJ2YXIgYmFzZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fYmFzZVByb3BlcnR5JyksXG4gICAgYmFzZVByb3BlcnR5RGVlcCA9IHJlcXVpcmUoJy4vX2Jhc2VQcm9wZXJ0eURlZXAnKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFtcbiAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICogXTtcbiAqXG4gKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqXG4gKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICogLy8gPT4gWzEsIDJdXG4gKi9cbmZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcHJvcGVydHk7XG4iLCJ2YXIgYmFzZVNldCA9IHJlcXVpcmUoJy4vX2Jhc2VTZXQnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIGEgcG9ydGlvbiBvZiBgcGF0aGAgZG9lc24ndCBleGlzdCxcbiAqIGl0J3MgY3JlYXRlZC4gQXJyYXlzIGFyZSBjcmVhdGVkIGZvciBtaXNzaW5nIGluZGV4IHByb3BlcnRpZXMgd2hpbGUgb2JqZWN0c1xuICogYXJlIGNyZWF0ZWQgZm9yIGFsbCBvdGhlciBtaXNzaW5nIHByb3BlcnRpZXMuIFVzZSBgXy5zZXRXaXRoYCB0byBjdXN0b21pemVcbiAqIGBwYXRoYCBjcmVhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuNy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gKlxuICogXy5zZXQob2JqZWN0LCAnYVswXS5iLmMnLCA0KTtcbiAqIGNvbnNvbGUubG9nKG9iamVjdC5hWzBdLmIuYyk7XG4gKiAvLyA9PiA0XG4gKlxuICogXy5zZXQob2JqZWN0LCBbJ3gnLCAnMCcsICd5JywgJ3onXSwgNSk7XG4gKiBjb25zb2xlLmxvZyhvYmplY3QueFswXS55LnopO1xuICogLy8gPT4gNVxuICovXG5mdW5jdGlvbiBzZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldDtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkFycmF5O1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJGYWxzZTtcbiIsInZhciBiYXNlVG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlVG9TdHJpbmcnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU3RyaW5nO1xuIiwiLyohIE5hdGl2ZSBQcm9taXNlIE9ubHlcbiAgICB2MC44LjEgKGMpIEt5bGUgU2ltcHNvblxuICAgIE1JVCBMaWNlbnNlOiBodHRwOi8vZ2V0aWZ5Lm1pdC1saWNlbnNlLm9yZ1xuKi9cblxuKGZ1bmN0aW9uIFVNRChuYW1lLGNvbnRleHQsZGVmaW5pdGlvbil7XG5cdC8vIHNwZWNpYWwgZm9ybSBvZiBVTUQgZm9yIHBvbHlmaWxsaW5nIGFjcm9zcyBldmlyb25tZW50c1xuXHRjb250ZXh0W25hbWVdID0gY29udGV4dFtuYW1lXSB8fCBkZWZpbml0aW9uKCk7XG5cdGlmICh0eXBlb2YgbW9kdWxlICE9IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMpIHsgbW9kdWxlLmV4cG9ydHMgPSBjb250ZXh0W25hbWVdOyB9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHsgZGVmaW5lKGZ1bmN0aW9uICRBTUQkKCl7IHJldHVybiBjb250ZXh0W25hbWVdOyB9KTsgfVxufSkoXCJQcm9taXNlXCIsdHlwZW9mIGdsb2JhbCAhPSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdGhpcyxmdW5jdGlvbiBERUYoKXtcblx0Lypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0dmFyIGJ1aWx0SW5Qcm9wLCBjeWNsZSwgc2NoZWR1bGluZ19xdWV1ZSxcblx0XHRUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG5cdFx0dGltZXIgPSAodHlwZW9mIHNldEltbWVkaWF0ZSAhPSBcInVuZGVmaW5lZFwiKSA/XG5cdFx0XHRmdW5jdGlvbiB0aW1lcihmbikgeyByZXR1cm4gc2V0SW1tZWRpYXRlKGZuKTsgfSA6XG5cdFx0XHRzZXRUaW1lb3V0XG5cdDtcblxuXHQvLyBkYW1taXQsIElFOC5cblx0dHJ5IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sXCJ4XCIse30pO1xuXHRcdGJ1aWx0SW5Qcm9wID0gZnVuY3Rpb24gYnVpbHRJblByb3Aob2JqLG5hbWUsdmFsLGNvbmZpZykge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosbmFtZSx7XG5cdFx0XHRcdHZhbHVlOiB2YWwsXG5cdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHRjb25maWd1cmFibGU6IGNvbmZpZyAhPT0gZmFsc2Vcblx0XHRcdH0pO1xuXHRcdH07XG5cdH1cblx0Y2F0Y2ggKGVycikge1xuXHRcdGJ1aWx0SW5Qcm9wID0gZnVuY3Rpb24gYnVpbHRJblByb3Aob2JqLG5hbWUsdmFsKSB7XG5cdFx0XHRvYmpbbmFtZV0gPSB2YWw7XG5cdFx0XHRyZXR1cm4gb2JqO1xuXHRcdH07XG5cdH1cblxuXHQvLyBOb3RlOiB1c2luZyBhIHF1ZXVlIGluc3RlYWQgb2YgYXJyYXkgZm9yIGVmZmljaWVuY3lcblx0c2NoZWR1bGluZ19xdWV1ZSA9IChmdW5jdGlvbiBRdWV1ZSgpIHtcblx0XHR2YXIgZmlyc3QsIGxhc3QsIGl0ZW07XG5cblx0XHRmdW5jdGlvbiBJdGVtKGZuLHNlbGYpIHtcblx0XHRcdHRoaXMuZm4gPSBmbjtcblx0XHRcdHRoaXMuc2VsZiA9IHNlbGY7XG5cdFx0XHR0aGlzLm5leHQgPSB2b2lkIDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGFkZDogZnVuY3Rpb24gYWRkKGZuLHNlbGYpIHtcblx0XHRcdFx0aXRlbSA9IG5ldyBJdGVtKGZuLHNlbGYpO1xuXHRcdFx0XHRpZiAobGFzdCkge1xuXHRcdFx0XHRcdGxhc3QubmV4dCA9IGl0ZW07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Zmlyc3QgPSBpdGVtO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxhc3QgPSBpdGVtO1xuXHRcdFx0XHRpdGVtID0gdm9pZCAwO1xuXHRcdFx0fSxcblx0XHRcdGRyYWluOiBmdW5jdGlvbiBkcmFpbigpIHtcblx0XHRcdFx0dmFyIGYgPSBmaXJzdDtcblx0XHRcdFx0Zmlyc3QgPSBsYXN0ID0gY3ljbGUgPSB2b2lkIDA7XG5cblx0XHRcdFx0d2hpbGUgKGYpIHtcblx0XHRcdFx0XHRmLmZuLmNhbGwoZi5zZWxmKTtcblx0XHRcdFx0XHRmID0gZi5uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSkoKTtcblxuXHRmdW5jdGlvbiBzY2hlZHVsZShmbixzZWxmKSB7XG5cdFx0c2NoZWR1bGluZ19xdWV1ZS5hZGQoZm4sc2VsZik7XG5cdFx0aWYgKCFjeWNsZSkge1xuXHRcdFx0Y3ljbGUgPSB0aW1lcihzY2hlZHVsaW5nX3F1ZXVlLmRyYWluKTtcblx0XHR9XG5cdH1cblxuXHQvLyBwcm9taXNlIGR1Y2sgdHlwaW5nXG5cdGZ1bmN0aW9uIGlzVGhlbmFibGUobykge1xuXHRcdHZhciBfdGhlbiwgb190eXBlID0gdHlwZW9mIG87XG5cblx0XHRpZiAobyAhPSBudWxsICYmXG5cdFx0XHQoXG5cdFx0XHRcdG9fdHlwZSA9PSBcIm9iamVjdFwiIHx8IG9fdHlwZSA9PSBcImZ1bmN0aW9uXCJcblx0XHRcdClcblx0XHQpIHtcblx0XHRcdF90aGVuID0gby50aGVuO1xuXHRcdH1cblx0XHRyZXR1cm4gdHlwZW9mIF90aGVuID09IFwiZnVuY3Rpb25cIiA/IF90aGVuIDogZmFsc2U7XG5cdH1cblxuXHRmdW5jdGlvbiBub3RpZnkoKSB7XG5cdFx0Zm9yICh2YXIgaT0wOyBpPHRoaXMuY2hhaW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdG5vdGlmeUlzb2xhdGVkKFxuXHRcdFx0XHR0aGlzLFxuXHRcdFx0XHQodGhpcy5zdGF0ZSA9PT0gMSkgPyB0aGlzLmNoYWluW2ldLnN1Y2Nlc3MgOiB0aGlzLmNoYWluW2ldLmZhaWx1cmUsXG5cdFx0XHRcdHRoaXMuY2hhaW5baV1cblx0XHRcdCk7XG5cdFx0fVxuXHRcdHRoaXMuY2hhaW4ubGVuZ3RoID0gMDtcblx0fVxuXG5cdC8vIE5PVEU6IFRoaXMgaXMgYSBzZXBhcmF0ZSBmdW5jdGlvbiB0byBpc29sYXRlXG5cdC8vIHRoZSBgdHJ5Li5jYXRjaGAgc28gdGhhdCBvdGhlciBjb2RlIGNhbiBiZVxuXHQvLyBvcHRpbWl6ZWQgYmV0dGVyXG5cdGZ1bmN0aW9uIG5vdGlmeUlzb2xhdGVkKHNlbGYsY2IsY2hhaW4pIHtcblx0XHR2YXIgcmV0LCBfdGhlbjtcblx0XHR0cnkge1xuXHRcdFx0aWYgKGNiID09PSBmYWxzZSkge1xuXHRcdFx0XHRjaGFpbi5yZWplY3Qoc2VsZi5tc2cpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGlmIChjYiA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdHJldCA9IHNlbGYubXNnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHJldCA9IGNiLmNhbGwodm9pZCAwLHNlbGYubXNnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChyZXQgPT09IGNoYWluLnByb21pc2UpIHtcblx0XHRcdFx0XHRjaGFpbi5yZWplY3QoVHlwZUVycm9yKFwiUHJvbWlzZS1jaGFpbiBjeWNsZVwiKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoX3RoZW4gPSBpc1RoZW5hYmxlKHJldCkpIHtcblx0XHRcdFx0XHRfdGhlbi5jYWxsKHJldCxjaGFpbi5yZXNvbHZlLGNoYWluLnJlamVjdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Y2hhaW4ucmVzb2x2ZShyZXQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNhdGNoIChlcnIpIHtcblx0XHRcdGNoYWluLnJlamVjdChlcnIpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHJlc29sdmUobXNnKSB7XG5cdFx0dmFyIF90aGVuLCBzZWxmID0gdGhpcztcblxuXHRcdC8vIGFscmVhZHkgdHJpZ2dlcmVkP1xuXHRcdGlmIChzZWxmLnRyaWdnZXJlZCkgeyByZXR1cm47IH1cblxuXHRcdHNlbGYudHJpZ2dlcmVkID0gdHJ1ZTtcblxuXHRcdC8vIHVud3JhcFxuXHRcdGlmIChzZWxmLmRlZikge1xuXHRcdFx0c2VsZiA9IHNlbGYuZGVmO1xuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHRpZiAoX3RoZW4gPSBpc1RoZW5hYmxlKG1zZykpIHtcblx0XHRcdFx0c2NoZWR1bGUoZnVuY3Rpb24oKXtcblx0XHRcdFx0XHR2YXIgZGVmX3dyYXBwZXIgPSBuZXcgTWFrZURlZldyYXBwZXIoc2VsZik7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdF90aGVuLmNhbGwobXNnLFxuXHRcdFx0XHRcdFx0XHRmdW5jdGlvbiAkcmVzb2x2ZSQoKXsgcmVzb2x2ZS5hcHBseShkZWZfd3JhcHBlcixhcmd1bWVudHMpOyB9LFxuXHRcdFx0XHRcdFx0XHRmdW5jdGlvbiAkcmVqZWN0JCgpeyByZWplY3QuYXBwbHkoZGVmX3dyYXBwZXIsYXJndW1lbnRzKTsgfVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdFx0cmVqZWN0LmNhbGwoZGVmX3dyYXBwZXIsZXJyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pXG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0c2VsZi5tc2cgPSBtc2c7XG5cdFx0XHRcdHNlbGYuc3RhdGUgPSAxO1xuXHRcdFx0XHRpZiAoc2VsZi5jaGFpbi5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0c2NoZWR1bGUobm90aWZ5LHNlbGYpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNhdGNoIChlcnIpIHtcblx0XHRcdHJlamVjdC5jYWxsKG5ldyBNYWtlRGVmV3JhcHBlcihzZWxmKSxlcnIpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHJlamVjdChtc2cpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHQvLyBhbHJlYWR5IHRyaWdnZXJlZD9cblx0XHRpZiAoc2VsZi50cmlnZ2VyZWQpIHsgcmV0dXJuOyB9XG5cblx0XHRzZWxmLnRyaWdnZXJlZCA9IHRydWU7XG5cblx0XHQvLyB1bndyYXBcblx0XHRpZiAoc2VsZi5kZWYpIHtcblx0XHRcdHNlbGYgPSBzZWxmLmRlZjtcblx0XHR9XG5cblx0XHRzZWxmLm1zZyA9IG1zZztcblx0XHRzZWxmLnN0YXRlID0gMjtcblx0XHRpZiAoc2VsZi5jaGFpbi5sZW5ndGggPiAwKSB7XG5cdFx0XHRzY2hlZHVsZShub3RpZnksc2VsZik7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gaXRlcmF0ZVByb21pc2VzKENvbnN0cnVjdG9yLGFycixyZXNvbHZlcixyZWplY3Rlcikge1xuXHRcdGZvciAodmFyIGlkeD0wOyBpZHg8YXJyLmxlbmd0aDsgaWR4KyspIHtcblx0XHRcdChmdW5jdGlvbiBJSUZFKGlkeCl7XG5cdFx0XHRcdENvbnN0cnVjdG9yLnJlc29sdmUoYXJyW2lkeF0pXG5cdFx0XHRcdC50aGVuKFxuXHRcdFx0XHRcdGZ1bmN0aW9uICRyZXNvbHZlciQobXNnKXtcblx0XHRcdFx0XHRcdHJlc29sdmVyKGlkeCxtc2cpO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0cmVqZWN0ZXJcblx0XHRcdFx0KTtcblx0XHRcdH0pKGlkeCk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gTWFrZURlZldyYXBwZXIoc2VsZikge1xuXHRcdHRoaXMuZGVmID0gc2VsZjtcblx0XHR0aGlzLnRyaWdnZXJlZCA9IGZhbHNlO1xuXHR9XG5cblx0ZnVuY3Rpb24gTWFrZURlZihzZWxmKSB7XG5cdFx0dGhpcy5wcm9taXNlID0gc2VsZjtcblx0XHR0aGlzLnN0YXRlID0gMDtcblx0XHR0aGlzLnRyaWdnZXJlZCA9IGZhbHNlO1xuXHRcdHRoaXMuY2hhaW4gPSBbXTtcblx0XHR0aGlzLm1zZyA9IHZvaWQgMDtcblx0fVxuXG5cdGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcblx0XHRpZiAodHlwZW9mIGV4ZWN1dG9yICE9IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dGhyb3cgVHlwZUVycm9yKFwiTm90IGEgZnVuY3Rpb25cIik7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX19OUE9fXyAhPT0gMCkge1xuXHRcdFx0dGhyb3cgVHlwZUVycm9yKFwiTm90IGEgcHJvbWlzZVwiKTtcblx0XHR9XG5cblx0XHQvLyBpbnN0YW5jZSBzaGFkb3dpbmcgdGhlIGluaGVyaXRlZCBcImJyYW5kXCJcblx0XHQvLyB0byBzaWduYWwgYW4gYWxyZWFkeSBcImluaXRpYWxpemVkXCIgcHJvbWlzZVxuXHRcdHRoaXMuX19OUE9fXyA9IDE7XG5cblx0XHR2YXIgZGVmID0gbmV3IE1ha2VEZWYodGhpcyk7XG5cblx0XHR0aGlzW1widGhlblwiXSA9IGZ1bmN0aW9uIHRoZW4oc3VjY2VzcyxmYWlsdXJlKSB7XG5cdFx0XHR2YXIgbyA9IHtcblx0XHRcdFx0c3VjY2VzczogdHlwZW9mIHN1Y2Nlc3MgPT0gXCJmdW5jdGlvblwiID8gc3VjY2VzcyA6IHRydWUsXG5cdFx0XHRcdGZhaWx1cmU6IHR5cGVvZiBmYWlsdXJlID09IFwiZnVuY3Rpb25cIiA/IGZhaWx1cmUgOiBmYWxzZVxuXHRcdFx0fTtcblx0XHRcdC8vIE5vdGU6IGB0aGVuKC4uKWAgaXRzZWxmIGNhbiBiZSBib3Jyb3dlZCB0byBiZSB1c2VkIGFnYWluc3Rcblx0XHRcdC8vIGEgZGlmZmVyZW50IHByb21pc2UgY29uc3RydWN0b3IgZm9yIG1ha2luZyB0aGUgY2hhaW5lZCBwcm9taXNlLFxuXHRcdFx0Ly8gYnkgc3Vic3RpdHV0aW5nIGEgZGlmZmVyZW50IGB0aGlzYCBiaW5kaW5nLlxuXHRcdFx0by5wcm9taXNlID0gbmV3IHRoaXMuY29uc3RydWN0b3IoZnVuY3Rpb24gZXh0cmFjdENoYWluKHJlc29sdmUscmVqZWN0KSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgcmVzb2x2ZSAhPSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHJlamVjdCAhPSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHR0aHJvdyBUeXBlRXJyb3IoXCJOb3QgYSBmdW5jdGlvblwiKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG8ucmVzb2x2ZSA9IHJlc29sdmU7XG5cdFx0XHRcdG8ucmVqZWN0ID0gcmVqZWN0O1xuXHRcdFx0fSk7XG5cdFx0XHRkZWYuY2hhaW4ucHVzaChvKTtcblxuXHRcdFx0aWYgKGRlZi5zdGF0ZSAhPT0gMCkge1xuXHRcdFx0XHRzY2hlZHVsZShub3RpZnksZGVmKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG8ucHJvbWlzZTtcblx0XHR9O1xuXHRcdHRoaXNbXCJjYXRjaFwiXSA9IGZ1bmN0aW9uICRjYXRjaCQoZmFpbHVyZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMudGhlbih2b2lkIDAsZmFpbHVyZSk7XG5cdFx0fTtcblxuXHRcdHRyeSB7XG5cdFx0XHRleGVjdXRvci5jYWxsKFxuXHRcdFx0XHR2b2lkIDAsXG5cdFx0XHRcdGZ1bmN0aW9uIHB1YmxpY1Jlc29sdmUobXNnKXtcblx0XHRcdFx0XHRyZXNvbHZlLmNhbGwoZGVmLG1zZyk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZ1bmN0aW9uIHB1YmxpY1JlamVjdChtc2cpIHtcblx0XHRcdFx0XHRyZWplY3QuY2FsbChkZWYsbXNnKTtcblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHR9XG5cdFx0Y2F0Y2ggKGVycikge1xuXHRcdFx0cmVqZWN0LmNhbGwoZGVmLGVycik7XG5cdFx0fVxuXHR9XG5cblx0dmFyIFByb21pc2VQcm90b3R5cGUgPSBidWlsdEluUHJvcCh7fSxcImNvbnN0cnVjdG9yXCIsUHJvbWlzZSxcblx0XHQvKmNvbmZpZ3VyYWJsZT0qL2ZhbHNlXG5cdCk7XG5cblx0Ly8gTm90ZTogQW5kcm9pZCA0IGNhbm5vdCB1c2UgYE9iamVjdC5kZWZpbmVQcm9wZXJ0eSguLilgIGhlcmVcblx0UHJvbWlzZS5wcm90b3R5cGUgPSBQcm9taXNlUHJvdG90eXBlO1xuXG5cdC8vIGJ1aWx0LWluIFwiYnJhbmRcIiB0byBzaWduYWwgYW4gXCJ1bmluaXRpYWxpemVkXCIgcHJvbWlzZVxuXHRidWlsdEluUHJvcChQcm9taXNlUHJvdG90eXBlLFwiX19OUE9fX1wiLDAsXG5cdFx0Lypjb25maWd1cmFibGU9Ki9mYWxzZVxuXHQpO1xuXG5cdGJ1aWx0SW5Qcm9wKFByb21pc2UsXCJyZXNvbHZlXCIsZnVuY3Rpb24gUHJvbWlzZSRyZXNvbHZlKG1zZykge1xuXHRcdHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cblx0XHQvLyBzcGVjIG1hbmRhdGVkIGNoZWNrc1xuXHRcdC8vIG5vdGU6IGJlc3QgXCJpc1Byb21pc2VcIiBjaGVjayB0aGF0J3MgcHJhY3RpY2FsIGZvciBub3dcblx0XHRpZiAobXNnICYmIHR5cGVvZiBtc2cgPT0gXCJvYmplY3RcIiAmJiBtc2cuX19OUE9fXyA9PT0gMSkge1xuXHRcdFx0cmV0dXJuIG1zZztcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUscmVqZWN0KXtcblx0XHRcdGlmICh0eXBlb2YgcmVzb2x2ZSAhPSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHJlamVjdCAhPSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0dGhyb3cgVHlwZUVycm9yKFwiTm90IGEgZnVuY3Rpb25cIik7XG5cdFx0XHR9XG5cblx0XHRcdHJlc29sdmUobXNnKTtcblx0XHR9KTtcblx0fSk7XG5cblx0YnVpbHRJblByb3AoUHJvbWlzZSxcInJlamVjdFwiLGZ1bmN0aW9uIFByb21pc2UkcmVqZWN0KG1zZykge1xuXHRcdHJldHVybiBuZXcgdGhpcyhmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLHJlamVjdCl7XG5cdFx0XHRpZiAodHlwZW9mIHJlc29sdmUgIT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiByZWplY3QgIT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdHRocm93IFR5cGVFcnJvcihcIk5vdCBhIGZ1bmN0aW9uXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZWplY3QobXNnKTtcblx0XHR9KTtcblx0fSk7XG5cblx0YnVpbHRJblByb3AoUHJvbWlzZSxcImFsbFwiLGZ1bmN0aW9uIFByb21pc2UkYWxsKGFycikge1xuXHRcdHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cblx0XHQvLyBzcGVjIG1hbmRhdGVkIGNoZWNrc1xuXHRcdGlmIChUb1N0cmluZy5jYWxsKGFycikgIT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG5cdFx0XHRyZXR1cm4gQ29uc3RydWN0b3IucmVqZWN0KFR5cGVFcnJvcihcIk5vdCBhbiBhcnJheVwiKSk7XG5cdFx0fVxuXHRcdGlmIChhcnIubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gQ29uc3RydWN0b3IucmVzb2x2ZShbXSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLHJlamVjdCl7XG5cdFx0XHRpZiAodHlwZW9mIHJlc29sdmUgIT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiByZWplY3QgIT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdHRocm93IFR5cGVFcnJvcihcIk5vdCBhIGZ1bmN0aW9uXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbGVuID0gYXJyLmxlbmd0aCwgbXNncyA9IEFycmF5KGxlbiksIGNvdW50ID0gMDtcblxuXHRcdFx0aXRlcmF0ZVByb21pc2VzKENvbnN0cnVjdG9yLGFycixmdW5jdGlvbiByZXNvbHZlcihpZHgsbXNnKSB7XG5cdFx0XHRcdG1zZ3NbaWR4XSA9IG1zZztcblx0XHRcdFx0aWYgKCsrY291bnQgPT09IGxlbikge1xuXHRcdFx0XHRcdHJlc29sdmUobXNncyk7XG5cdFx0XHRcdH1cblx0XHRcdH0scmVqZWN0KTtcblx0XHR9KTtcblx0fSk7XG5cblx0YnVpbHRJblByb3AoUHJvbWlzZSxcInJhY2VcIixmdW5jdGlvbiBQcm9taXNlJHJhY2UoYXJyKSB7XG5cdFx0dmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuXHRcdC8vIHNwZWMgbWFuZGF0ZWQgY2hlY2tzXG5cdFx0aWYgKFRvU3RyaW5nLmNhbGwoYXJyKSAhPSBcIltvYmplY3QgQXJyYXldXCIpIHtcblx0XHRcdHJldHVybiBDb25zdHJ1Y3Rvci5yZWplY3QoVHlwZUVycm9yKFwiTm90IGFuIGFycmF5XCIpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUscmVqZWN0KXtcblx0XHRcdGlmICh0eXBlb2YgcmVzb2x2ZSAhPSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHJlamVjdCAhPSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0dGhyb3cgVHlwZUVycm9yKFwiTm90IGEgZnVuY3Rpb25cIik7XG5cdFx0XHR9XG5cblx0XHRcdGl0ZXJhdGVQcm9taXNlcyhDb25zdHJ1Y3RvcixhcnIsZnVuY3Rpb24gcmVzb2x2ZXIoaWR4LG1zZyl7XG5cdFx0XHRcdHJlc29sdmUobXNnKTtcblx0XHRcdH0scmVqZWN0KTtcblx0XHR9KTtcblx0fSk7XG5cblx0cmV0dXJuIFByb21pc2U7XG59KTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICAgIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSByZXR1cm4gb2JqO1xuICAgIFxuICAgIHZhciBjb3B5O1xuICAgIFxuICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgICAgdmFyIGxlbiA9IG9iai5sZW5ndGg7XG4gICAgICAgIGNvcHkgPSBBcnJheShsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb3B5W2ldID0gb2JqW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIga2V5cyA9IG9iamVjdEtleXMob2JqKTtcbiAgICAgICAgY29weSA9IHt9O1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBjb3B5W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29weTtcbn07XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgICByZXR1cm4ge30udG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLyohXG4gKiBTaWduYXR1cmUgUGFkIHYxLjYuMFxuICogaHR0cHM6Ly9naXRodWIuY29tL3N6aW1lay9zaWduYXR1cmVfcGFkXG4gKlxuICogQ29weXJpZ2h0IDIwMTcgU3p5bW9uIE5vd2FrXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqXG4gKiBUaGUgbWFpbiBpZGVhIGFuZCBzb21lIHBhcnRzIG9mIHRoZSBjb2RlIChlLmcuIGRyYXdpbmcgdmFyaWFibGUgd2lkdGggQsOpemllciBjdXJ2ZSkgYXJlIHRha2VuIGZyb206XG4gKiBodHRwOi8vY29ybmVyLnNxdWFyZXVwLmNvbS8yMDEyLzA3L3Ntb290aGVyLXNpZ25hdHVyZXMuaHRtbFxuICpcbiAqIEltcGxlbWVudGF0aW9uIG9mIGludGVycG9sYXRpb24gdXNpbmcgY3ViaWMgQsOpemllciBjdXJ2ZXMgaXMgdGFrZW4gZnJvbTpcbiAqIGh0dHA6Ly9iZW5rbm93c2NvZGUud29yZHByZXNzLmNvbS8yMDEyLzA5LzE0L3BhdGgtaW50ZXJwb2xhdGlvbi11c2luZy1jdWJpYy1iZXppZXItYW5kLWNvbnRyb2wtcG9pbnQtZXN0aW1hdGlvbi1pbi1qYXZhc2NyaXB0XG4gKlxuICogQWxnb3JpdGhtIGZvciBhcHByb3hpbWF0ZWQgbGVuZ3RoIG9mIGEgQsOpemllciBjdXJ2ZSBpcyB0YWtlbiBmcm9tOlxuICogaHR0cDovL3d3dy5sZW1vZGEubmV0L21hdGhzL2Jlemllci1sZW5ndGgvaW5kZXguaHRtbFxuICpcbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG5cdChnbG9iYWwuU2lnbmF0dXJlUGFkID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBQb2ludCh4LCB5LCB0aW1lKSB7XG4gIHRoaXMueCA9IHg7XG4gIHRoaXMueSA9IHk7XG4gIHRoaXMudGltZSA9IHRpbWUgfHwgbmV3IERhdGUoKS5nZXRUaW1lKCk7XG59XG5cblBvaW50LnByb3RvdHlwZS52ZWxvY2l0eUZyb20gPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgcmV0dXJuIHRoaXMudGltZSAhPT0gc3RhcnQudGltZSA/IHRoaXMuZGlzdGFuY2VUbyhzdGFydCkgLyAodGhpcy50aW1lIC0gc3RhcnQudGltZSkgOiAxO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmRpc3RhbmNlVG8gPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh0aGlzLnggLSBzdGFydC54LCAyKSArIE1hdGgucG93KHRoaXMueSAtIHN0YXJ0LnksIDIpKTtcbn07XG5cbmZ1bmN0aW9uIEJlemllcihzdGFydFBvaW50LCBjb250cm9sMSwgY29udHJvbDIsIGVuZFBvaW50KSB7XG4gIHRoaXMuc3RhcnRQb2ludCA9IHN0YXJ0UG9pbnQ7XG4gIHRoaXMuY29udHJvbDEgPSBjb250cm9sMTtcbiAgdGhpcy5jb250cm9sMiA9IGNvbnRyb2wyO1xuICB0aGlzLmVuZFBvaW50ID0gZW5kUG9pbnQ7XG59XG5cbi8vIFJldHVybnMgYXBwcm94aW1hdGVkIGxlbmd0aC5cbkJlemllci5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RlcHMgPSAxMDtcbiAgdmFyIGxlbmd0aCA9IDA7XG4gIHZhciBweCA9IHZvaWQgMDtcbiAgdmFyIHB5ID0gdm9pZCAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDw9IHN0ZXBzOyBpICs9IDEpIHtcbiAgICB2YXIgdCA9IGkgLyBzdGVwcztcbiAgICB2YXIgY3ggPSB0aGlzLl9wb2ludCh0LCB0aGlzLnN0YXJ0UG9pbnQueCwgdGhpcy5jb250cm9sMS54LCB0aGlzLmNvbnRyb2wyLngsIHRoaXMuZW5kUG9pbnQueCk7XG4gICAgdmFyIGN5ID0gdGhpcy5fcG9pbnQodCwgdGhpcy5zdGFydFBvaW50LnksIHRoaXMuY29udHJvbDEueSwgdGhpcy5jb250cm9sMi55LCB0aGlzLmVuZFBvaW50LnkpO1xuICAgIGlmIChpID4gMCkge1xuICAgICAgdmFyIHhkaWZmID0gY3ggLSBweDtcbiAgICAgIHZhciB5ZGlmZiA9IGN5IC0gcHk7XG4gICAgICBsZW5ndGggKz0gTWF0aC5zcXJ0KHhkaWZmICogeGRpZmYgKyB5ZGlmZiAqIHlkaWZmKTtcbiAgICB9XG4gICAgcHggPSBjeDtcbiAgICBweSA9IGN5O1xuICB9XG5cbiAgcmV0dXJuIGxlbmd0aDtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLW11bHRpLXNwYWNlcywgc3BhY2UtaW4tcGFyZW5zICovXG5CZXppZXIucHJvdG90eXBlLl9wb2ludCA9IGZ1bmN0aW9uICh0LCBzdGFydCwgYzEsIGMyLCBlbmQpIHtcbiAgcmV0dXJuIHN0YXJ0ICogKDEuMCAtIHQpICogKDEuMCAtIHQpICogKDEuMCAtIHQpICsgMy4wICogYzEgKiAoMS4wIC0gdCkgKiAoMS4wIC0gdCkgKiB0ICsgMy4wICogYzIgKiAoMS4wIC0gdCkgKiB0ICogdCArIGVuZCAqIHQgKiB0ICogdDtcbn07XG5cbmZ1bmN0aW9uIFNpZ25hdHVyZVBhZChjYW52YXMsIG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgb3B0cyA9IG9wdGlvbnMgfHwge307XG5cbiAgdGhpcy52ZWxvY2l0eUZpbHRlcldlaWdodCA9IG9wdHMudmVsb2NpdHlGaWx0ZXJXZWlnaHQgfHwgMC43O1xuICB0aGlzLm1pbldpZHRoID0gb3B0cy5taW5XaWR0aCB8fCAwLjU7XG4gIHRoaXMubWF4V2lkdGggPSBvcHRzLm1heFdpZHRoIHx8IDIuNTtcbiAgdGhpcy5kb3RTaXplID0gb3B0cy5kb3RTaXplIHx8IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMubWluV2lkdGggKyB0aGlzLm1heFdpZHRoKSAvIDI7XG4gIH07XG4gIHRoaXMucGVuQ29sb3IgPSBvcHRzLnBlbkNvbG9yIHx8ICdibGFjayc7XG4gIHRoaXMuYmFja2dyb3VuZENvbG9yID0gb3B0cy5iYWNrZ3JvdW5kQ29sb3IgfHwgJ3JnYmEoMCwwLDAsMCknO1xuICB0aGlzLm9uQmVnaW4gPSBvcHRzLm9uQmVnaW47XG4gIHRoaXMub25FbmQgPSBvcHRzLm9uRW5kO1xuXG4gIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcbiAgdGhpcy5fY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIHRoaXMuY2xlYXIoKTtcblxuICAvLyBXZSBuZWVkIGFkZCB0aGVzZSBpbmxpbmUgc28gdGhleSBhcmUgYXZhaWxhYmxlIHRvIHVuYmluZCB3aGlsZSBzdGlsbCBoYXZpbmdcbiAgLy8gYWNjZXNzIHRvICdzZWxmJyB3ZSBjb3VsZCB1c2UgXy5iaW5kIGJ1dCBpdCdzIG5vdCB3b3J0aCBhZGRpbmcgYSBkZXBlbmRlbmN5LlxuICB0aGlzLl9oYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQud2hpY2ggPT09IDEpIHtcbiAgICAgIHNlbGYuX21vdXNlQnV0dG9uRG93biA9IHRydWU7XG4gICAgICBzZWxmLl9zdHJva2VCZWdpbihldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuX2hhbmRsZU1vdXNlTW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChzZWxmLl9tb3VzZUJ1dHRvbkRvd24pIHtcbiAgICAgIHNlbGYuX3N0cm9rZVVwZGF0ZShldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuX2hhbmRsZU1vdXNlVXAgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQud2hpY2ggPT09IDEgJiYgc2VsZi5fbW91c2VCdXR0b25Eb3duKSB7XG4gICAgICBzZWxmLl9tb3VzZUJ1dHRvbkRvd24gPSBmYWxzZTtcbiAgICAgIHNlbGYuX3N0cm9rZUVuZChldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuX2hhbmRsZVRvdWNoU3RhcnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0VG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciB0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgc2VsZi5fc3Ryb2tlQmVnaW4odG91Y2gpO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLl9oYW5kbGVUb3VjaE1vdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBQcmV2ZW50IHNjcm9sbGluZy5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgdmFyIHRvdWNoID0gZXZlbnQudGFyZ2V0VG91Y2hlc1swXTtcbiAgICBzZWxmLl9zdHJva2VVcGRhdGUodG91Y2gpO1xuICB9O1xuXG4gIHRoaXMuX2hhbmRsZVRvdWNoRW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHdhc0NhbnZhc1RvdWNoZWQgPSBldmVudC50YXJnZXQgPT09IHNlbGYuX2NhbnZhcztcbiAgICBpZiAod2FzQ2FudmFzVG91Y2hlZCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHNlbGYuX3N0cm9rZUVuZChldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEVuYWJsZSBtb3VzZSBhbmQgdG91Y2ggZXZlbnQgaGFuZGxlcnNcbiAgdGhpcy5vbigpO1xufVxuXG4vLyBQdWJsaWMgbWV0aG9kc1xuU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgdmFyIGNhbnZhcyA9IHRoaXMuX2NhbnZhcztcblxuICBjdHguZmlsbFN0eWxlID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XG4gIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgdGhpcy5fZGF0YSA9IFtdO1xuICB0aGlzLl9yZXNldCgpO1xuICB0aGlzLl9pc0VtcHR5ID0gdHJ1ZTtcbn07XG5cblNpZ25hdHVyZVBhZC5wcm90b3R5cGUuZnJvbURhdGFVUkwgPSBmdW5jdGlvbiAoZGF0YVVybCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICB2YXIgcmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICB2YXIgd2lkdGggPSB0aGlzLl9jYW52YXMud2lkdGggLyByYXRpbztcbiAgdmFyIGhlaWdodCA9IHRoaXMuX2NhbnZhcy5oZWlnaHQgLyByYXRpbztcblxuICB0aGlzLl9yZXNldCgpO1xuICBpbWFnZS5zcmMgPSBkYXRhVXJsO1xuICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMuX2N0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICB9O1xuICB0aGlzLl9pc0VtcHR5ID0gZmFsc2U7XG59O1xuXG5TaWduYXR1cmVQYWQucHJvdG90eXBlLnRvRGF0YVVSTCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHZhciBfY2FudmFzO1xuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2ltYWdlL3N2Zyt4bWwnOlxuICAgICAgcmV0dXJuIHRoaXMuX3RvU1ZHKCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBvcHRpb25zID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBvcHRpb25zW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChfY2FudmFzID0gdGhpcy5fY2FudmFzKS50b0RhdGFVUkwuYXBwbHkoX2NhbnZhcywgW3R5cGVdLmNvbmNhdChvcHRpb25zKSk7XG4gIH1cbn07XG5cblNpZ25hdHVyZVBhZC5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2hhbmRsZU1vdXNlRXZlbnRzKCk7XG4gIHRoaXMuX2hhbmRsZVRvdWNoRXZlbnRzKCk7XG59O1xuXG5TaWduYXR1cmVQYWQucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX2hhbmRsZU1vdXNlRG93bik7XG4gIHRoaXMuX2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9oYW5kbGVNb3VzZU1vdmUpO1xuICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5faGFuZGxlTW91c2VVcCk7XG5cbiAgdGhpcy5fY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9oYW5kbGVUb3VjaFN0YXJ0KTtcbiAgdGhpcy5fY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX2hhbmRsZVRvdWNoTW92ZSk7XG4gIHRoaXMuX2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX2hhbmRsZVRvdWNoRW5kKTtcbn07XG5cblNpZ25hdHVyZVBhZC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2lzRW1wdHk7XG59O1xuXG4vLyBQcml2YXRlIG1ldGhvZHNcblNpZ25hdHVyZVBhZC5wcm90b3R5cGUuX3N0cm9rZUJlZ2luID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHRoaXMuX2RhdGEucHVzaChbXSk7XG4gIHRoaXMuX3Jlc2V0KCk7XG4gIHRoaXMuX3N0cm9rZVVwZGF0ZShldmVudCk7XG5cbiAgaWYgKHR5cGVvZiB0aGlzLm9uQmVnaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLm9uQmVnaW4oZXZlbnQpO1xuICB9XG59O1xuXG5TaWduYXR1cmVQYWQucHJvdG90eXBlLl9zdHJva2VVcGRhdGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdmFyIHggPSBldmVudC5jbGllbnRYO1xuICB2YXIgeSA9IGV2ZW50LmNsaWVudFk7XG5cbiAgdmFyIHBvaW50ID0gdGhpcy5fY3JlYXRlUG9pbnQoeCwgeSk7XG5cbiAgdmFyIF9hZGRQb2ludCA9IHRoaXMuX2FkZFBvaW50KHBvaW50KSxcbiAgICAgIGN1cnZlID0gX2FkZFBvaW50LmN1cnZlLFxuICAgICAgd2lkdGhzID0gX2FkZFBvaW50LndpZHRocztcblxuICBpZiAoY3VydmUgJiYgd2lkdGhzKSB7XG4gICAgdGhpcy5fZHJhd0N1cnZlKGN1cnZlLCB3aWR0aHMuc3RhcnQsIHdpZHRocy5lbmQpO1xuICB9XG5cbiAgdGhpcy5fZGF0YVt0aGlzLl9kYXRhLmxlbmd0aCAtIDFdLnB1c2goe1xuICAgIHg6IHBvaW50LngsXG4gICAgeTogcG9pbnQueSxcbiAgICB0aW1lOiBwb2ludC50aW1lXG4gIH0pO1xufTtcblxuU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5fc3Ryb2tlRW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHZhciBjYW5EcmF3Q3VydmUgPSB0aGlzLnBvaW50cy5sZW5ndGggPiAyO1xuICB2YXIgcG9pbnQgPSB0aGlzLnBvaW50c1swXTtcblxuICBpZiAoIWNhbkRyYXdDdXJ2ZSAmJiBwb2ludCkge1xuICAgIHRoaXMuX2RyYXdEb3QocG9pbnQpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0aGlzLm9uRW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5vbkVuZChldmVudCk7XG4gIH1cbn07XG5cblNpZ25hdHVyZVBhZC5wcm90b3R5cGUuX2hhbmRsZU1vdXNlRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9tb3VzZUJ1dHRvbkRvd24gPSBmYWxzZTtcblxuICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5faGFuZGxlTW91c2VEb3duKTtcbiAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX2hhbmRsZU1vdXNlTW92ZSk7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9oYW5kbGVNb3VzZVVwKTtcbn07XG5cblNpZ25hdHVyZVBhZC5wcm90b3R5cGUuX2hhbmRsZVRvdWNoRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAvLyBQYXNzIHRvdWNoIGV2ZW50cyB0byBjYW52YXMgZWxlbWVudCBvbiBtb2JpbGUgSUUxMSBhbmQgRWRnZS5cbiAgdGhpcy5fY2FudmFzLnN0eWxlLm1zVG91Y2hBY3Rpb24gPSAnbm9uZSc7XG4gIHRoaXMuX2NhbnZhcy5zdHlsZS50b3VjaEFjdGlvbiA9ICdub25lJztcblxuICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX2hhbmRsZVRvdWNoU3RhcnQpO1xuICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5faGFuZGxlVG91Y2hNb3ZlKTtcbiAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5faGFuZGxlVG91Y2hFbmQpO1xufTtcblxuU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5fcmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucG9pbnRzID0gW107XG4gIHRoaXMuX2xhc3RWZWxvY2l0eSA9IDA7XG4gIHRoaXMuX2xhc3RXaWR0aCA9ICh0aGlzLm1pbldpZHRoICsgdGhpcy5tYXhXaWR0aCkgLyAyO1xuICB0aGlzLl9jdHguZmlsbFN0eWxlID0gdGhpcy5wZW5Db2xvcjtcbn07XG5cblNpZ25hdHVyZVBhZC5wcm90b3R5cGUuX2NyZWF0ZVBvaW50ID0gZnVuY3Rpb24gKHgsIHksIHRpbWUpIHtcbiAgdmFyIHJlY3QgPSB0aGlzLl9jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgcmV0dXJuIG5ldyBQb2ludCh4IC0gcmVjdC5sZWZ0LCB5IC0gcmVjdC50b3AsIHRpbWUgfHwgbmV3IERhdGUoKS5nZXRUaW1lKCkpO1xufTtcblxuU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5fYWRkUG9pbnQgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICB2YXIgdG1wID0gdm9pZCAwO1xuXG4gIHBvaW50cy5wdXNoKHBvaW50KTtcblxuICBpZiAocG9pbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAvLyBUbyByZWR1Y2UgdGhlIGluaXRpYWwgbGFnIG1ha2UgaXQgd29yayB3aXRoIDMgcG9pbnRzXG4gICAgLy8gYnkgY29weWluZyB0aGUgZmlyc3QgcG9pbnQgdG8gdGhlIGJlZ2lubmluZy5cbiAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMykgcG9pbnRzLnVuc2hpZnQocG9pbnRzWzBdKTtcblxuICAgIHRtcCA9IHRoaXMuX2NhbGN1bGF0ZUN1cnZlQ29udHJvbFBvaW50cyhwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdKTtcbiAgICB2YXIgYzIgPSB0bXAuYzI7XG4gICAgdG1wID0gdGhpcy5fY2FsY3VsYXRlQ3VydmVDb250cm9sUG9pbnRzKHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10pO1xuICAgIHZhciBjMyA9IHRtcC5jMTtcbiAgICB2YXIgY3VydmUgPSBuZXcgQmV6aWVyKHBvaW50c1sxXSwgYzIsIGMzLCBwb2ludHNbMl0pO1xuICAgIHZhciB3aWR0aHMgPSB0aGlzLl9jYWxjdWxhdGVDdXJ2ZVdpZHRocyhjdXJ2ZSk7XG5cbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IGVsZW1lbnQgZnJvbSB0aGUgbGlzdCxcbiAgICAvLyBzbyB0aGF0IHdlIGFsd2F5cyBoYXZlIG5vIG1vcmUgdGhhbiA0IHBvaW50cyBpbiBwb2ludHMgYXJyYXkuXG4gICAgcG9pbnRzLnNoaWZ0KCk7XG5cbiAgICByZXR1cm4geyBjdXJ2ZTogY3VydmUsIHdpZHRoczogd2lkdGhzIH07XG4gIH1cblxuICByZXR1cm4ge307XG59O1xuXG5TaWduYXR1cmVQYWQucHJvdG90eXBlLl9jYWxjdWxhdGVDdXJ2ZUNvbnRyb2xQb2ludHMgPSBmdW5jdGlvbiAoczEsIHMyLCBzMykge1xuICB2YXIgZHgxID0gczEueCAtIHMyLng7XG4gIHZhciBkeTEgPSBzMS55IC0gczIueTtcbiAgdmFyIGR4MiA9IHMyLnggLSBzMy54O1xuICB2YXIgZHkyID0gczIueSAtIHMzLnk7XG5cbiAgdmFyIG0xID0geyB4OiAoczEueCArIHMyLngpIC8gMi4wLCB5OiAoczEueSArIHMyLnkpIC8gMi4wIH07XG4gIHZhciBtMiA9IHsgeDogKHMyLnggKyBzMy54KSAvIDIuMCwgeTogKHMyLnkgKyBzMy55KSAvIDIuMCB9O1xuXG4gIHZhciBsMSA9IE1hdGguc3FydChkeDEgKiBkeDEgKyBkeTEgKiBkeTEpO1xuICB2YXIgbDIgPSBNYXRoLnNxcnQoZHgyICogZHgyICsgZHkyICogZHkyKTtcblxuICB2YXIgZHhtID0gbTEueCAtIG0yLng7XG4gIHZhciBkeW0gPSBtMS55IC0gbTIueTtcblxuICB2YXIgayA9IGwyIC8gKGwxICsgbDIpO1xuICB2YXIgY20gPSB7IHg6IG0yLnggKyBkeG0gKiBrLCB5OiBtMi55ICsgZHltICogayB9O1xuXG4gIHZhciB0eCA9IHMyLnggLSBjbS54O1xuICB2YXIgdHkgPSBzMi55IC0gY20ueTtcblxuICByZXR1cm4ge1xuICAgIGMxOiBuZXcgUG9pbnQobTEueCArIHR4LCBtMS55ICsgdHkpLFxuICAgIGMyOiBuZXcgUG9pbnQobTIueCArIHR4LCBtMi55ICsgdHkpXG4gIH07XG59O1xuXG5TaWduYXR1cmVQYWQucHJvdG90eXBlLl9jYWxjdWxhdGVDdXJ2ZVdpZHRocyA9IGZ1bmN0aW9uIChjdXJ2ZSkge1xuICB2YXIgc3RhcnRQb2ludCA9IGN1cnZlLnN0YXJ0UG9pbnQ7XG4gIHZhciBlbmRQb2ludCA9IGN1cnZlLmVuZFBvaW50O1xuICB2YXIgd2lkdGhzID0geyBzdGFydDogbnVsbCwgZW5kOiBudWxsIH07XG5cbiAgdmFyIHZlbG9jaXR5ID0gdGhpcy52ZWxvY2l0eUZpbHRlcldlaWdodCAqIGVuZFBvaW50LnZlbG9jaXR5RnJvbShzdGFydFBvaW50KSArICgxIC0gdGhpcy52ZWxvY2l0eUZpbHRlcldlaWdodCkgKiB0aGlzLl9sYXN0VmVsb2NpdHk7XG5cbiAgdmFyIG5ld1dpZHRoID0gdGhpcy5fc3Ryb2tlV2lkdGgodmVsb2NpdHkpO1xuXG4gIHdpZHRocy5zdGFydCA9IHRoaXMuX2xhc3RXaWR0aDtcbiAgd2lkdGhzLmVuZCA9IG5ld1dpZHRoO1xuXG4gIHRoaXMuX2xhc3RWZWxvY2l0eSA9IHZlbG9jaXR5O1xuICB0aGlzLl9sYXN0V2lkdGggPSBuZXdXaWR0aDtcblxuICByZXR1cm4gd2lkdGhzO1xufTtcblxuU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5fc3Ryb2tlV2lkdGggPSBmdW5jdGlvbiAodmVsb2NpdHkpIHtcbiAgcmV0dXJuIE1hdGgubWF4KHRoaXMubWF4V2lkdGggLyAodmVsb2NpdHkgKyAxKSwgdGhpcy5taW5XaWR0aCk7XG59O1xuXG5TaWduYXR1cmVQYWQucHJvdG90eXBlLl9kcmF3UG9pbnQgPSBmdW5jdGlvbiAoeCwgeSwgc2l6ZSkge1xuICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuXG4gIGN0eC5tb3ZlVG8oeCwgeSk7XG4gIGN0eC5hcmMoeCwgeSwgc2l6ZSwgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgdGhpcy5faXNFbXB0eSA9IGZhbHNlO1xufTtcblxuU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5fZHJhd0N1cnZlID0gZnVuY3Rpb24gKGN1cnZlLCBzdGFydFdpZHRoLCBlbmRXaWR0aCkge1xuICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICB2YXIgd2lkdGhEZWx0YSA9IGVuZFdpZHRoIC0gc3RhcnRXaWR0aDtcbiAgdmFyIGRyYXdTdGVwcyA9IE1hdGguZmxvb3IoY3VydmUubGVuZ3RoKCkpO1xuXG4gIGN0eC5iZWdpblBhdGgoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRyYXdTdGVwczsgaSArPSAxKSB7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBCZXppZXIgKHgsIHkpIGNvb3JkaW5hdGUgZm9yIHRoaXMgc3RlcC5cbiAgICB2YXIgdCA9IGkgLyBkcmF3U3RlcHM7XG4gICAgdmFyIHR0ID0gdCAqIHQ7XG4gICAgdmFyIHR0dCA9IHR0ICogdDtcbiAgICB2YXIgdSA9IDEgLSB0O1xuICAgIHZhciB1dSA9IHUgKiB1O1xuICAgIHZhciB1dXUgPSB1dSAqIHU7XG5cbiAgICB2YXIgeCA9IHV1dSAqIGN1cnZlLnN0YXJ0UG9pbnQueDtcbiAgICB4ICs9IDMgKiB1dSAqIHQgKiBjdXJ2ZS5jb250cm9sMS54O1xuICAgIHggKz0gMyAqIHUgKiB0dCAqIGN1cnZlLmNvbnRyb2wyLng7XG4gICAgeCArPSB0dHQgKiBjdXJ2ZS5lbmRQb2ludC54O1xuXG4gICAgdmFyIHkgPSB1dXUgKiBjdXJ2ZS5zdGFydFBvaW50Lnk7XG4gICAgeSArPSAzICogdXUgKiB0ICogY3VydmUuY29udHJvbDEueTtcbiAgICB5ICs9IDMgKiB1ICogdHQgKiBjdXJ2ZS5jb250cm9sMi55O1xuICAgIHkgKz0gdHR0ICogY3VydmUuZW5kUG9pbnQueTtcblxuICAgIHZhciB3aWR0aCA9IHN0YXJ0V2lkdGggKyB0dHQgKiB3aWR0aERlbHRhO1xuICAgIHRoaXMuX2RyYXdQb2ludCh4LCB5LCB3aWR0aCk7XG4gIH1cblxuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5maWxsKCk7XG59O1xuXG5TaWduYXR1cmVQYWQucHJvdG90eXBlLl9kcmF3RG90ID0gZnVuY3Rpb24gKHBvaW50KSB7XG4gIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gIHZhciB3aWR0aCA9IHR5cGVvZiB0aGlzLmRvdFNpemUgPT09ICdmdW5jdGlvbicgPyB0aGlzLmRvdFNpemUoKSA6IHRoaXMuZG90U2l6ZTtcblxuICBjdHguYmVnaW5QYXRoKCk7XG4gIHRoaXMuX2RyYXdQb2ludChwb2ludC54LCBwb2ludC55LCB3aWR0aCk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgY3R4LmZpbGwoKTtcbn07XG5cblNpZ25hdHVyZVBhZC5wcm90b3R5cGUuX2Zyb21EYXRhID0gZnVuY3Rpb24gKHBvaW50R3JvdXBzLCBkcmF3Q3VydmUsIGRyYXdEb3QpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludEdyb3Vwcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIHZhciBncm91cCA9IHBvaW50R3JvdXBzW2ldO1xuXG4gICAgaWYgKGdyb3VwLmxlbmd0aCA+IDEpIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ3JvdXAubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgdmFyIHJhd1BvaW50ID0gZ3JvdXBbal07XG4gICAgICAgIHZhciBwb2ludCA9IG5ldyBQb2ludChyYXdQb2ludC54LCByYXdQb2ludC55LCByYXdQb2ludC50aW1lKTtcblxuICAgICAgICBpZiAoaiA9PT0gMCkge1xuICAgICAgICAgIC8vIEZpcnN0IHBvaW50IGluIGEgZ3JvdXAuIE5vdGhpbmcgdG8gZHJhdyB5ZXQuXG4gICAgICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgICAgICB0aGlzLl9hZGRQb2ludChwb2ludCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaiAhPT0gZ3JvdXAubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIC8vIE1pZGRsZSBwb2ludCBpbiBhIGdyb3VwLlxuICAgICAgICAgIHZhciBfYWRkUG9pbnQyID0gdGhpcy5fYWRkUG9pbnQocG9pbnQpLFxuICAgICAgICAgICAgICBjdXJ2ZSA9IF9hZGRQb2ludDIuY3VydmUsXG4gICAgICAgICAgICAgIHdpZHRocyA9IF9hZGRQb2ludDIud2lkdGhzO1xuXG4gICAgICAgICAgaWYgKGN1cnZlICYmIHdpZHRocykge1xuICAgICAgICAgICAgZHJhd0N1cnZlKGN1cnZlLCB3aWR0aHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBMYXN0IHBvaW50IGluIGEgZ3JvdXAuIERvIG5vdGhpbmcuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgIHZhciBfcmF3UG9pbnQgPSBncm91cFswXTtcbiAgICAgIGRyYXdEb3QoX3Jhd1BvaW50KTtcbiAgICB9XG4gIH1cbn07XG5cblNpZ25hdHVyZVBhZC5wcm90b3R5cGUuX3RvU1ZHID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICB2YXIgcG9pbnRHcm91cHMgPSB0aGlzLl9kYXRhO1xuICB2YXIgY2FudmFzID0gdGhpcy5fY2FudmFzO1xuICB2YXIgcmF0aW8gPSBNYXRoLm1heCh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxLCAxKTtcbiAgdmFyIG1pblggPSAwO1xuICB2YXIgbWluWSA9IDA7XG4gIHZhciBtYXhYID0gY2FudmFzLndpZHRoIC8gcmF0aW87XG4gIHZhciBtYXhZID0gY2FudmFzLmhlaWdodCAvIHJhdGlvO1xuICB2YXIgc3ZnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdzdmcnKTtcblxuICBzdmcuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3dpZHRoJywgY2FudmFzLndpZHRoKTtcbiAgc3ZnLnNldEF0dHJpYnV0ZU5TKG51bGwsICdoZWlnaHQnLCBjYW52YXMuaGVpZ2h0KTtcblxuICB0aGlzLl9mcm9tRGF0YShwb2ludEdyb3VwcywgZnVuY3Rpb24gKGN1cnZlLCB3aWR0aHMpIHtcbiAgICB2YXIgcGF0aCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnKTtcblxuICAgIC8vIE5lZWQgdG8gY2hlY2sgY3VydmUgZm9yIE5hTiB2YWx1ZXMsIHRoZXNlIHBvcCB1cCB3aGVuIGRyYXdpbmdcbiAgICAvLyBsaW5lcyBvbiB0aGUgY2FudmFzIHRoYXQgYXJlIG5vdCBjb250aW51b3VzLiBFLmcuIFNoYXJwIGNvcm5lcnNcbiAgICAvLyBvciBzdG9wcGluZyBtaWQtc3Ryb2tlIGFuZCB0aGFuIGNvbnRpbnVpbmcgd2l0aG91dCBsaWZ0aW5nIG1vdXNlLlxuICAgIGlmICghaXNOYU4oY3VydmUuY29udHJvbDEueCkgJiYgIWlzTmFOKGN1cnZlLmNvbnRyb2wxLnkpICYmICFpc05hTihjdXJ2ZS5jb250cm9sMi54KSAmJiAhaXNOYU4oY3VydmUuY29udHJvbDIueSkpIHtcbiAgICAgIHZhciBhdHRyID0gJ00gJyArIGN1cnZlLnN0YXJ0UG9pbnQueC50b0ZpeGVkKDMpICsgJywnICsgY3VydmUuc3RhcnRQb2ludC55LnRvRml4ZWQoMykgKyAnICcgKyAoJ0MgJyArIGN1cnZlLmNvbnRyb2wxLngudG9GaXhlZCgzKSArICcsJyArIGN1cnZlLmNvbnRyb2wxLnkudG9GaXhlZCgzKSArICcgJykgKyAoY3VydmUuY29udHJvbDIueC50b0ZpeGVkKDMpICsgJywnICsgY3VydmUuY29udHJvbDIueS50b0ZpeGVkKDMpICsgJyAnKSArIChjdXJ2ZS5lbmRQb2ludC54LnRvRml4ZWQoMykgKyAnLCcgKyBjdXJ2ZS5lbmRQb2ludC55LnRvRml4ZWQoMykpO1xuXG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnZCcsIGF0dHIpO1xuICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsICh3aWR0aHMuZW5kICogMi4yNSkudG9GaXhlZCgzKSk7XG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgX3RoaXMyLnBlbkNvbG9yKTtcbiAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgJ25vbmUnKTtcbiAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWNhcCcsICdyb3VuZCcpO1xuXG4gICAgICBzdmcuYXBwZW5kQ2hpbGQocGF0aCk7XG4gICAgfVxuICB9LCBmdW5jdGlvbiAocmF3UG9pbnQpIHtcbiAgICB2YXIgY2lyY2xlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2lyY2xlJyk7XG4gICAgdmFyIGRvdFNpemUgPSB0eXBlb2YgX3RoaXMyLmRvdFNpemUgPT09ICdmdW5jdGlvbicgPyBfdGhpczIuZG90U2l6ZSgpIDogX3RoaXMyLmRvdFNpemU7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZSgncicsIGRvdFNpemUpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoJ2N4JywgcmF3UG9pbnQueCk7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZSgnY3knLCByYXdQb2ludC55KTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKCdmaWxsJywgX3RoaXMyLnBlbkNvbG9yKTtcblxuICAgIHN2Zy5hcHBlbmRDaGlsZChjaXJjbGUpO1xuICB9KTtcblxuICB2YXIgcHJlZml4ID0gJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsJztcbiAgdmFyIGhlYWRlciA9ICc8c3ZnJyArICcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiJyArICcgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCInICsgKCcgdmlld0JveD1cIicgKyBtaW5YICsgJyAnICsgbWluWSArICcgJyArIG1heFggKyAnICcgKyBtYXhZICsgJ1wiJykgKyAoJyB3aWR0aD1cIicgKyBtYXhYICsgJ1wiJykgKyAoJyBoZWlnaHQ9XCInICsgbWF4WSArICdcIicpICsgJz4nO1xuICB2YXIgYm9keSA9IHN2Zy5pbm5lckhUTUw7XG5cbiAgLy8gSUUgaGFjayBmb3IgbWlzc2luZyBpbm5lckhUTUwgcHJvcGVydHkgb24gU1ZHRWxlbWVudFxuICBpZiAoYm9keSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGR1bW15ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZHVtbXknKTtcbiAgICB2YXIgbm9kZXMgPSBzdmcuY2hpbGROb2RlcztcbiAgICBkdW1teS5pbm5lckhUTUwgPSAnJztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGR1bW15LmFwcGVuZENoaWxkKG5vZGVzW2ldLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgfVxuXG4gICAgYm9keSA9IGR1bW15LmlubmVySFRNTDtcbiAgfVxuXG4gIHZhciBmb290ZXIgPSAnPC9zdmc+JztcbiAgdmFyIGRhdGEgPSBoZWFkZXIgKyBib2R5ICsgZm9vdGVyO1xuXG4gIHJldHVybiBwcmVmaXggKyBidG9hKGRhdGEpO1xufTtcblxuU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5mcm9tRGF0YSA9IGZ1bmN0aW9uIChwb2ludEdyb3Vwcykge1xuICB2YXIgX3RoaXMzID0gdGhpcztcblxuICB0aGlzLmNsZWFyKCk7XG5cbiAgdGhpcy5fZnJvbURhdGEocG9pbnRHcm91cHMsIGZ1bmN0aW9uIChjdXJ2ZSwgd2lkdGhzKSB7XG4gICAgcmV0dXJuIF90aGlzMy5fZHJhd0N1cnZlKGN1cnZlLCB3aWR0aHMuc3RhcnQsIHdpZHRocy5lbmQpO1xuICB9LCBmdW5jdGlvbiAocmF3UG9pbnQpIHtcbiAgICByZXR1cm4gX3RoaXMzLl9kcmF3RG90KHJhd1BvaW50KTtcbiAgfSk7XG59O1xuXG5TaWduYXR1cmVQYWQucHJvdG90eXBlLnRvRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2RhdGE7XG59O1xuXG5yZXR1cm4gU2lnbmF0dXJlUGFkO1xuXG59KSkpO1xuIiwiKGZ1bmN0aW9uKHNlbGYpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmIChzZWxmLmZldGNoKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc3VwcG9ydCA9IHtcbiAgICBzZWFyY2hQYXJhbXM6ICdVUkxTZWFyY2hQYXJhbXMnIGluIHNlbGYsXG4gICAgaXRlcmFibGU6ICdTeW1ib2wnIGluIHNlbGYgJiYgJ2l0ZXJhdG9yJyBpbiBTeW1ib2wsXG4gICAgYmxvYjogJ0ZpbGVSZWFkZXInIGluIHNlbGYgJiYgJ0Jsb2InIGluIHNlbGYgJiYgKGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEJsb2IoKVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0pKCksXG4gICAgZm9ybURhdGE6ICdGb3JtRGF0YScgaW4gc2VsZixcbiAgICBhcnJheUJ1ZmZlcjogJ0FycmF5QnVmZmVyJyBpbiBzZWxmXG4gIH1cblxuICBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlcikge1xuICAgIHZhciB2aWV3Q2xhc3NlcyA9IFtcbiAgICAgICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgICAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBGbG9hdDY0QXJyYXldJ1xuICAgIF1cblxuICAgIHZhciBpc0RhdGFWaWV3ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIERhdGFWaWV3LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKG9iailcbiAgICB9XG5cbiAgICB2YXIgaXNBcnJheUJ1ZmZlclZpZXcgPSBBcnJheUJ1ZmZlci5pc1ZpZXcgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHZpZXdDbGFzc2VzLmluZGV4T2YoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikpID4gLTFcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVOYW1lKG5hbWUpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBuYW1lID0gU3RyaW5nKG5hbWUpXG4gICAgfVxuICAgIGlmICgvW15hLXowLTlcXC0jJCUmJyorLlxcXl9gfH5dL2kudGVzdChuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGZpZWxkIG5hbWUnKVxuICAgIH1cbiAgICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpXG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSlcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICAvLyBCdWlsZCBhIGRlc3RydWN0aXZlIGl0ZXJhdG9yIGZvciB0aGUgdmFsdWUgbGlzdFxuICBmdW5jdGlvbiBpdGVyYXRvckZvcihpdGVtcykge1xuICAgIHZhciBpdGVyYXRvciA9IHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBpdGVtcy5zaGlmdCgpXG4gICAgICAgIHJldHVybiB7ZG9uZTogdmFsdWUgPT09IHVuZGVmaW5lZCwgdmFsdWU6IHZhbHVlfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgICBpdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvclxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpdGVyYXRvclxuICB9XG5cbiAgZnVuY3Rpb24gSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgdGhpcy5tYXAgPSB7fVxuXG4gICAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgdmFsdWUpXG4gICAgICB9LCB0aGlzKVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgICB0aGlzLmFwcGVuZChoZWFkZXJbMF0sIGhlYWRlclsxXSlcbiAgICAgIH0sIHRoaXMpXG4gICAgfSBlbHNlIGlmIChoZWFkZXJzKSB7XG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhoZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgaGVhZGVyc1tuYW1lXSlcbiAgICAgIH0sIHRoaXMpXG4gICAgfVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKVxuICAgIHZhbHVlID0gbm9ybWFsaXplVmFsdWUodmFsdWUpXG4gICAgdmFyIG9sZFZhbHVlID0gdGhpcy5tYXBbbmFtZV1cbiAgICB0aGlzLm1hcFtuYW1lXSA9IG9sZFZhbHVlID8gb2xkVmFsdWUrJywnK3ZhbHVlIDogdmFsdWVcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlWydkZWxldGUnXSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV1cbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKVxuICAgIHJldHVybiB0aGlzLmhhcyhuYW1lKSA/IHRoaXMubWFwW25hbWVdIDogbnVsbFxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShub3JtYWxpemVOYW1lKG5hbWUpKVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLm1hcCkge1xuICAgICAgaWYgKHRoaXMubWFwLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdGhpcy5tYXBbbmFtZV0sIG5hbWUsIHRoaXMpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdXG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7IGl0ZW1zLnB1c2gobmFtZSkgfSlcbiAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXVxuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkgeyBpdGVtcy5wdXNoKHZhbHVlKSB9KVxuICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXVxuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkgeyBpdGVtcy5wdXNoKFtuYW1lLCB2YWx1ZV0pIH0pXG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgICBIZWFkZXJzLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gSGVhZGVycy5wcm90b3R5cGUuZW50cmllc1xuICB9XG5cbiAgZnVuY3Rpb24gY29uc3VtZWQoYm9keSkge1xuICAgIGlmIChib2R5LmJvZHlVc2VkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJykpXG4gICAgfVxuICAgIGJvZHkuYm9keVVzZWQgPSB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpXG4gICAgICB9XG4gICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QocmVhZGVyLmVycm9yKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQmxvYkFzQXJyYXlCdWZmZXIoYmxvYikge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gICAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKVxuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKVxuICAgIHJldHVybiBwcm9taXNlXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQmxvYkFzVGV4dChibG9iKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gICAgcmVhZGVyLnJlYWRBc1RleHQoYmxvYilcbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEFycmF5QnVmZmVyQXNUZXh0KGJ1Zikge1xuICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICAgIHZhciBjaGFycyA9IG5ldyBBcnJheSh2aWV3Lmxlbmd0aClcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhcnNbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHZpZXdbaV0pXG4gICAgfVxuICAgIHJldHVybiBjaGFycy5qb2luKCcnKVxuICB9XG5cbiAgZnVuY3Rpb24gYnVmZmVyQ2xvbmUoYnVmKSB7XG4gICAgaWYgKGJ1Zi5zbGljZSkge1xuICAgICAgcmV0dXJuIGJ1Zi5zbGljZSgwKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zi5ieXRlTGVuZ3RoKVxuICAgICAgdmlldy5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmKSlcbiAgICAgIHJldHVybiB2aWV3LmJ1ZmZlclxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIEJvZHkoKSB7XG4gICAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlXG5cbiAgICB0aGlzLl9pbml0Qm9keSA9IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAgIHRoaXMuX2JvZHlJbml0ID0gYm9keVxuICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gJydcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmJsb2IgJiYgQmxvYi5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5QmxvYiA9IGJvZHlcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5mb3JtRGF0YSAmJiBGb3JtRGF0YS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5Rm9ybURhdGEgPSBib2R5XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkudG9TdHJpbmcoKVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIHN1cHBvcnQuYmxvYiAmJiBpc0RhdGFWaWV3KGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkuYnVmZmVyKVxuICAgICAgICAvLyBJRSAxMC0xMSBjYW4ndCBoYW5kbGUgYSBEYXRhVmlldyBib2R5LlxuICAgICAgICB0aGlzLl9ib2R5SW5pdCA9IG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIChBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSB8fCBpc0FycmF5QnVmZmVyVmlldyhib2R5KSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgQm9keUluaXQgdHlwZScpXG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlCbG9iICYmIHRoaXMuX2JvZHlCbG9iLnR5cGUpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCB0aGlzLl9ib2R5QmxvYi50eXBlKVxuICAgICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCcpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgICB0aGlzLmJsb2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlCbG9iKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyBibG9iJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5VGV4dF0pKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHJldHVybiBjb25zdW1lZCh0aGlzKSB8fCBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUFycmF5QnVmZmVyKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmJsb2IoKS50aGVuKHJlYWRCbG9iQXNBcnJheUJ1ZmZlcilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgIHJldHVybiByZWFkQmxvYkFzVGV4dCh0aGlzLl9ib2R5QmxvYilcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVhZEFycmF5QnVmZmVyQXNUZXh0KHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgdGV4dCcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlUZXh0KVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdXBwb3J0LmZvcm1EYXRhKSB7XG4gICAgICB0aGlzLmZvcm1EYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKGRlY29kZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmpzb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKEpTT04ucGFyc2UpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIEhUVFAgbWV0aG9kcyB3aG9zZSBjYXBpdGFsaXphdGlvbiBzaG91bGQgYmUgbm9ybWFsaXplZFxuICB2YXIgbWV0aG9kcyA9IFsnREVMRVRFJywgJ0dFVCcsICdIRUFEJywgJ09QVElPTlMnLCAnUE9TVCcsICdQVVQnXVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU1ldGhvZChtZXRob2QpIHtcbiAgICB2YXIgdXBjYXNlZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpXG4gICAgcmV0dXJuIChtZXRob2RzLmluZGV4T2YodXBjYXNlZCkgPiAtMSkgPyB1cGNhc2VkIDogbWV0aG9kXG4gIH1cblxuICBmdW5jdGlvbiBSZXF1ZXN0KGlucHV0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keVxuXG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgICAgaWYgKGlucHV0LmJvZHlVc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpXG4gICAgICB9XG4gICAgICB0aGlzLnVybCA9IGlucHV0LnVybFxuICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGlucHV0LmNyZWRlbnRpYWxzXG4gICAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dC5oZWFkZXJzKVxuICAgICAgfVxuICAgICAgdGhpcy5tZXRob2QgPSBpbnB1dC5tZXRob2RcbiAgICAgIHRoaXMubW9kZSA9IGlucHV0Lm1vZGVcbiAgICAgIGlmICghYm9keSAmJiBpbnB1dC5fYm9keUluaXQgIT0gbnVsbCkge1xuICAgICAgICBib2R5ID0gaW5wdXQuX2JvZHlJbml0XG4gICAgICAgIGlucHV0LmJvZHlVc2VkID0gdHJ1ZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVybCA9IFN0cmluZyhpbnB1dClcbiAgICB9XG5cbiAgICB0aGlzLmNyZWRlbnRpYWxzID0gb3B0aW9ucy5jcmVkZW50aWFscyB8fCB0aGlzLmNyZWRlbnRpYWxzIHx8ICdvbWl0J1xuICAgIGlmIChvcHRpb25zLmhlYWRlcnMgfHwgIXRoaXMuaGVhZGVycykge1xuICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICAgIH1cbiAgICB0aGlzLm1ldGhvZCA9IG5vcm1hbGl6ZU1ldGhvZChvcHRpb25zLm1ldGhvZCB8fCB0aGlzLm1ldGhvZCB8fCAnR0VUJylcbiAgICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlIHx8IG51bGxcbiAgICB0aGlzLnJlZmVycmVyID0gbnVsbFxuXG4gICAgaWYgKCh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJykgJiYgYm9keSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9keSBub3QgYWxsb3dlZCBmb3IgR0VUIG9yIEhFQUQgcmVxdWVzdHMnKVxuICAgIH1cbiAgICB0aGlzLl9pbml0Qm9keShib2R5KVxuICB9XG5cbiAgUmVxdWVzdC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlcXVlc3QodGhpcywgeyBib2R5OiB0aGlzLl9ib2R5SW5pdCB9KVxuICB9XG5cbiAgZnVuY3Rpb24gZGVjb2RlKGJvZHkpIHtcbiAgICB2YXIgZm9ybSA9IG5ldyBGb3JtRGF0YSgpXG4gICAgYm9keS50cmltKCkuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgdmFyIHNwbGl0ID0gYnl0ZXMuc3BsaXQoJz0nKVxuICAgICAgICB2YXIgbmFtZSA9IHNwbGl0LnNoaWZ0KCkucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgdmFyIHZhbHVlID0gc3BsaXQuam9pbignPScpLnJlcGxhY2UoL1xcKy9nLCAnICcpXG4gICAgICAgIGZvcm0uYXBwZW5kKGRlY29kZVVSSUNvbXBvbmVudChuYW1lKSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBmb3JtXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUhlYWRlcnMocmF3SGVhZGVycykge1xuICAgIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKVxuICAgIHJhd0hlYWRlcnMuc3BsaXQoL1xccj9cXG4vKS5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHZhciBwYXJ0cyA9IGxpbmUuc3BsaXQoJzonKVxuICAgICAgdmFyIGtleSA9IHBhcnRzLnNoaWZ0KCkudHJpbSgpXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcnRzLmpvaW4oJzonKS50cmltKClcbiAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBoZWFkZXJzXG4gIH1cblxuICBCb2R5LmNhbGwoUmVxdWVzdC5wcm90b3R5cGUpXG5cbiAgZnVuY3Rpb24gUmVzcG9uc2UoYm9keUluaXQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSB7fVxuICAgIH1cblxuICAgIHRoaXMudHlwZSA9ICdkZWZhdWx0J1xuICAgIHRoaXMuc3RhdHVzID0gJ3N0YXR1cycgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc3RhdHVzIDogMjAwXG4gICAgdGhpcy5vayA9IHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8IDMwMFxuICAgIHRoaXMuc3RhdHVzVGV4dCA9ICdzdGF0dXNUZXh0JyBpbiBvcHRpb25zID8gb3B0aW9ucy5zdGF0dXNUZXh0IDogJ09LJ1xuICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycylcbiAgICB0aGlzLnVybCA9IG9wdGlvbnMudXJsIHx8ICcnXG4gICAgdGhpcy5faW5pdEJvZHkoYm9keUluaXQpXG4gIH1cblxuICBCb2R5LmNhbGwoUmVzcG9uc2UucHJvdG90eXBlKVxuXG4gIFJlc3BvbnNlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UodGhpcy5fYm9keUluaXQsIHtcbiAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICBzdGF0dXNUZXh0OiB0aGlzLnN0YXR1c1RleHQsXG4gICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyh0aGlzLmhlYWRlcnMpLFxuICAgICAgdXJsOiB0aGlzLnVybFxuICAgIH0pXG4gIH1cblxuICBSZXNwb25zZS5lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXNwb25zZSA9IG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiAwLCBzdGF0dXNUZXh0OiAnJ30pXG4gICAgcmVzcG9uc2UudHlwZSA9ICdlcnJvcidcbiAgICByZXR1cm4gcmVzcG9uc2VcbiAgfVxuXG4gIHZhciByZWRpcmVjdFN0YXR1c2VzID0gWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XVxuXG4gIFJlc3BvbnNlLnJlZGlyZWN0ID0gZnVuY3Rpb24odXJsLCBzdGF0dXMpIHtcbiAgICBpZiAocmVkaXJlY3RTdGF0dXNlcy5pbmRleE9mKHN0YXR1cykgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBzdGF0dXMgY29kZScpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiBzdGF0dXMsIGhlYWRlcnM6IHtsb2NhdGlvbjogdXJsfX0pXG4gIH1cblxuICBzZWxmLkhlYWRlcnMgPSBIZWFkZXJzXG4gIHNlbGYuUmVxdWVzdCA9IFJlcXVlc3RcbiAgc2VsZi5SZXNwb25zZSA9IFJlc3BvbnNlXG5cbiAgc2VsZi5mZXRjaCA9IGZ1bmN0aW9uKGlucHV0LCBpbml0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgUmVxdWVzdChpbnB1dCwgaW5pdClcbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuXG4gICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgIHN0YXR1czogeGhyLnN0YXR1cyxcbiAgICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICBoZWFkZXJzOiBwYXJzZUhlYWRlcnMoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpIHx8ICcnKVxuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMudXJsID0gJ3Jlc3BvbnNlVVJMJyBpbiB4aHIgPyB4aHIucmVzcG9uc2VVUkwgOiBvcHRpb25zLmhlYWRlcnMuZ2V0KCdYLVJlcXVlc3QtVVJMJylcbiAgICAgICAgdmFyIGJvZHkgPSAncmVzcG9uc2UnIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHRcbiAgICAgICAgcmVzb2x2ZShuZXcgUmVzcG9uc2UoYm9keSwgb3B0aW9ucykpXG4gICAgICB9XG5cbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpXG4gICAgICB9XG5cbiAgICAgIHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSlcbiAgICAgIH1cblxuICAgICAgeGhyLm9wZW4ocmVxdWVzdC5tZXRob2QsIHJlcXVlc3QudXJsLCB0cnVlKVxuXG4gICAgICBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ2luY2x1ZGUnKSB7XG4gICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlXG4gICAgICB9XG5cbiAgICAgIGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIgJiYgc3VwcG9ydC5ibG9iKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYidcbiAgICAgIH1cblxuICAgICAgcmVxdWVzdC5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWUpXG4gICAgICB9KVxuXG4gICAgICB4aHIuc2VuZCh0eXBlb2YgcmVxdWVzdC5fYm9keUluaXQgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHJlcXVlc3QuX2JvZHlJbml0KVxuICAgIH0pXG4gIH1cbiAgc2VsZi5mZXRjaC5wb2x5ZmlsbCA9IHRydWVcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBwKSB7XHJcbiAgLypqc2hpbnQgY2FtZWxjYXNlOiBmYWxzZSAqL1xyXG4gIGFwcC5jb25maWcoW1xyXG4gICAgJ2Zvcm1pb0NvbXBvbmVudHNQcm92aWRlcicsXHJcbiAgICBmdW5jdGlvbihmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIpIHtcclxuICAgICAgZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyLnJlZ2lzdGVyKCdhZGRyZXNzJywge1xyXG4gICAgICAgIHRpdGxlOiAnQWRkcmVzcycsXHJcbiAgICAgICAgdGVtcGxhdGU6IGZ1bmN0aW9uKCRzY29wZSkge1xyXG4gICAgICAgICAgcmV0dXJuICRzY29wZS5jb21wb25lbnQubXVsdGlwbGUgPyAnZm9ybWlvL2NvbXBvbmVudHMvYWRkcmVzcy1tdWx0aXBsZS5odG1sJyA6ICdmb3JtaW8vY29tcG9uZW50cy9hZGRyZXNzLmh0bWwnO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29udHJvbGxlcjogWyckc2NvcGUnLCAnJGh0dHAnLCBmdW5jdGlvbigkc2NvcGUsICRodHRwKSB7XHJcbiAgICAgICAgICBpZiAoJHNjb3BlLmJ1aWxkZXIpIHJldHVybjtcclxuICAgICAgICAgICRzY29wZS5hZGRyZXNzID0ge307XHJcbiAgICAgICAgICAkc2NvcGUuYWRkcmVzc2VzID0gW107XHJcbiAgICAgICAgICAkc2NvcGUucmVmcmVzaEFkZHJlc3MgPSBmdW5jdGlvbihhZGRyZXNzKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XHJcbiAgICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcclxuICAgICAgICAgICAgICBzZW5zb3I6IGZhbHNlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmICghYWRkcmVzcykge1xyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoJHNjb3BlLmNvbXBvbmVudC5tYXAgJiYgJHNjb3BlLmNvbXBvbmVudC5tYXAucmVnaW9uKSB7XHJcbiAgICAgICAgICAgICAgcGFyYW1zLnJlZ2lvbiA9ICRzY29wZS5jb21wb25lbnQubWFwLnJlZ2lvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoJHNjb3BlLmNvbXBvbmVudC5tYXAgJiYgJHNjb3BlLmNvbXBvbmVudC5tYXAua2V5KSB7XHJcbiAgICAgICAgICAgICAgcGFyYW1zLmtleSA9ICRzY29wZS5jb21wb25lbnQubWFwLmtleTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gJGh0dHAuZ2V0KFxyXG4gICAgICAgICAgICAgICdodHRwczovL21hcHMuZ29vZ2xlYXBpcy5jb20vbWFwcy9hcGkvZ2VvY29kZS9qc29uJyxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkaXNhYmxlSldUOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXHJcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICAgICAgIEF1dGhvcml6YXRpb246IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgUHJhZ21hOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICdDYWNoZS1Db250cm9sJzogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAkc2NvcGUuYWRkcmVzc2VzID0gcmVzcG9uc2UuZGF0YS5yZXN1bHRzO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfV0sXHJcbiAgICAgICAgdGFibGVWaWV3OiBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgICAgICByZXR1cm4gZGF0YSA/IGRhdGEuZm9ybWF0dGVkX2FkZHJlc3MgOiAnJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdyb3VwOiAnYWR2YW5jZWQnLFxyXG4gICAgICAgIHNldHRpbmdzOiB7XHJcbiAgICAgICAgICBpbnB1dDogdHJ1ZSxcclxuICAgICAgICAgIHRhYmxlVmlldzogdHJ1ZSxcclxuICAgICAgICAgIGxhYmVsOiAnJyxcclxuICAgICAgICAgIGtleTogJ2FkZHJlc3NGaWVsZCcsXHJcbiAgICAgICAgICBwbGFjZWhvbGRlcjogJycsXHJcbiAgICAgICAgICBtdWx0aXBsZTogZmFsc2UsXHJcbiAgICAgICAgICBwcm90ZWN0ZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgY2xlYXJPbkhpZGU6IHRydWUsXHJcbiAgICAgICAgICB1bmlxdWU6IGZhbHNlLFxyXG4gICAgICAgICAgcGVyc2lzdGVudDogdHJ1ZSxcclxuICAgICAgICAgIGhpZGRlbjogZmFsc2UsXHJcbiAgICAgICAgICBtYXA6IHtcclxuICAgICAgICAgICAgcmVnaW9uOiAnJyxcclxuICAgICAgICAgICAga2V5OiAnJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHZhbGlkYXRlOiB7XHJcbiAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgXSk7XHJcbiAgYXBwLnJ1bihbXHJcbiAgICAnJHRlbXBsYXRlQ2FjaGUnLFxyXG4gICAgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9hZGRyZXNzLmh0bWwnLFxyXG4gICAgICAgIFwiPGxhYmVsIG5nLWlmPVxcXCJjb21wb25lbnQubGFiZWwgJiYgIWNvbXBvbmVudC5oaWRlTGFiZWxcXFwiIGZvcj1cXFwie3sgY29tcG9uZW50SWQgfX1cXFwiIG5nLWNsYXNzPVxcXCJ7J2ZpZWxkLXJlcXVpcmVkJzogaXNSZXF1aXJlZChjb21wb25lbnQpfVxcXCI+e3sgY29tcG9uZW50LmxhYmVsIHwgZm9ybWlvVHJhbnNsYXRlOm51bGw6YnVpbGRlciB9fTwvbGFiZWw+XFxyXFxuPHNwYW4gbmctaWY9XFxcIiFjb21wb25lbnQubGFiZWwgJiYgaXNSZXF1aXJlZChjb21wb25lbnQpXFxcIiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1hc3RlcmlzayBmb3JtLWNvbnRyb2wtZmVlZGJhY2sgZmllbGQtcmVxdWlyZWQtaW5saW5lXFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+PC9zcGFuPlxcclxcbjx1aS1zZWxlY3QgbmctbW9kZWw9XFxcImRhdGFbY29tcG9uZW50LmtleV1cXFwiIHNhZmUtbXVsdGlwbGUtdG8tc2luZ2xlIG5nLWRpc2FibGVkPVxcXCJyZWFkT25seVxcXCIgbmctcmVxdWlyZWQ9XFxcImlzUmVxdWlyZWQoY29tcG9uZW50KVxcXCIgaWQ9XFxcInt7IGNvbXBvbmVudElkIH19XFxcIiBuYW1lPVxcXCJ7eyBjb21wb25lbnRJZCB9fVxcXCIgdGFiaW5kZXg9XFxcInt7IGNvbXBvbmVudC50YWJpbmRleCB8fCAwIH19XFxcIiB0aGVtZT1cXFwiYm9vdHN0cmFwXFxcIj5cXHJcXG4gIDx1aS1zZWxlY3QtbWF0Y2ggY2xhc3M9XFxcInVpLXNlbGVjdC1tYXRjaFxcXCIgcGxhY2Vob2xkZXI9XFxcInt7IGNvbXBvbmVudC5wbGFjZWhvbGRlciB8IGZvcm1pb1RyYW5zbGF0ZTpudWxsOmJ1aWxkZXIgfX1cXFwiPnt7JGl0ZW0uZm9ybWF0dGVkX2FkZHJlc3MgfHwgJHNlbGVjdC5zZWxlY3RlZC5mb3JtYXR0ZWRfYWRkcmVzc319PC91aS1zZWxlY3QtbWF0Y2g+XFxyXFxuICA8dWktc2VsZWN0LWNob2ljZXMgY2xhc3M9XFxcInVpLXNlbGVjdC1jaG9pY2VzXFxcIiByZXBlYXQ9XFxcImFkZHJlc3MgaW4gYWRkcmVzc2VzXFxcIiByZWZyZXNoPVxcXCJyZWZyZXNoQWRkcmVzcygkc2VsZWN0LnNlYXJjaClcXFwiIHJlZnJlc2gtZGVsYXk9XFxcIjUwMFxcXCI+XFxyXFxuICAgIDxkaXYgbmctYmluZC1odG1sPVxcXCJhZGRyZXNzLmZvcm1hdHRlZF9hZGRyZXNzIHwgaGlnaGxpZ2h0OiAkc2VsZWN0LnNlYXJjaFxcXCI+PC9kaXY+XFxyXFxuICA8L3VpLXNlbGVjdC1jaG9pY2VzPlxcclxcbjwvdWktc2VsZWN0Plxcclxcbjxmb3JtaW8tZXJyb3JzIG5nLWlmPVxcXCI6OiFidWlsZGVyXFxcIj48L2Zvcm1pby1lcnJvcnM+XFxyXFxuXCJcclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIENoYW5nZSB0aGUgdWktc2VsZWN0IHRvIHVpLXNlbGVjdCBtdWx0aXBsZS5cclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9hZGRyZXNzLW11bHRpcGxlLmh0bWwnLFxyXG4gICAgICAgICR0ZW1wbGF0ZUNhY2hlLmdldCgnZm9ybWlvL2NvbXBvbmVudHMvYWRkcmVzcy5odG1sJykucmVwbGFjZSgnPHVpLXNlbGVjdCcsICc8dWktc2VsZWN0IG11bHRpcGxlJylcclxuICAgICAgKTtcclxuICAgIH1cclxuICBdKTtcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcHApIHtcclxuICBhcHAuY29uZmlnKFtcclxuICAgICdmb3JtaW9Db21wb25lbnRzUHJvdmlkZXInLFxyXG4gICAgZnVuY3Rpb24oZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyKSB7XHJcbiAgICAgIGZvcm1pb0NvbXBvbmVudHNQcm92aWRlci5yZWdpc3RlcignYnV0dG9uJywge1xyXG4gICAgICAgIHRpdGxlOiAnQnV0dG9uJyxcclxuICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2J1dHRvbi5odG1sJyxcclxuICAgICAgICBzZXR0aW5nczoge1xyXG4gICAgICAgICAgaW5wdXQ6IHRydWUsXHJcbiAgICAgICAgICBsYWJlbDogJ1N1Ym1pdCcsXHJcbiAgICAgICAgICB0YWJsZVZpZXc6IGZhbHNlLFxyXG4gICAgICAgICAga2V5OiAnc3VibWl0JyxcclxuICAgICAgICAgIHNpemU6ICdtZCcsXHJcbiAgICAgICAgICBsZWZ0SWNvbjogJycsXHJcbiAgICAgICAgICByaWdodEljb246ICcnLFxyXG4gICAgICAgICAgYmxvY2s6IGZhbHNlLFxyXG4gICAgICAgICAgYWN0aW9uOiAnc3VibWl0JyxcclxuICAgICAgICAgIGRpc2FibGVPbkludmFsaWQ6IGZhbHNlLFxyXG4gICAgICAgICAgdGhlbWU6ICdwcmltYXJ5J1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29udHJvbGxlcjogWyckc2NvcGUnLCBmdW5jdGlvbigkc2NvcGUpIHtcclxuICAgICAgICAgIGlmICgkc2NvcGUuYnVpbGRlcikgcmV0dXJuO1xyXG4gICAgICAgICAgdmFyIHNldHRpbmdzID0gJHNjb3BlLmNvbXBvbmVudDtcclxuICAgICAgICAgICRzY29wZS5nZXRCdXR0b25UeXBlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoc2V0dGluZ3MuYWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgY2FzZSAnc3VibWl0JzpcclxuICAgICAgICAgICAgICAgIHJldHVybiAnc3VibWl0JztcclxuICAgICAgICAgICAgICBjYXNlICdyZXNldCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3Jlc2V0JztcclxuICAgICAgICAgICAgICBjYXNlICdldmVudCc6XHJcbiAgICAgICAgICAgICAgY2FzZSAnb2F1dGgnOlxyXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2J1dHRvbic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgdmFyIG9uQ2xpY2sgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChzZXR0aW5ncy5hY3Rpb24pIHtcclxuICAgICAgICAgICAgICBjYXNlICdzdWJtaXQnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgIGNhc2UgJ2V2ZW50JzpcclxuICAgICAgICAgICAgICAgICRzY29wZS4kZW1pdCgkc2NvcGUuY29tcG9uZW50LmV2ZW50LCAkc2NvcGUuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICBjYXNlICdyZXNldCc6XHJcbiAgICAgICAgICAgICAgICAkc2NvcGUucmVzZXRGb3JtKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICBjYXNlICdvYXV0aCc6XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzLm9hdXRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICRzY29wZS5zaG93QWxlcnRzKHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGFuZ2VyJyxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnWW91IG11c3QgYXNzaWduIHRoaXMgYnV0dG9uIHRvIGFuIE9BdXRoIGFjdGlvbiBiZWZvcmUgaXQgd2lsbCB3b3JrLidcclxuICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLm9hdXRoLmVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICRzY29wZS5zaG93QWxlcnRzKHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGFuZ2VyJyxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBzZXR0aW5ncy5vYXV0aC5lcnJvclxyXG4gICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAkc2NvcGUub3Blbk9BdXRoKHNldHRpbmdzLm9hdXRoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICRzY29wZS4kb24oJ2J1dHRvbkNsaWNrJywgZnVuY3Rpb24oZXZlbnQsIGNvbXBvbmVudCwgY29tcG9uZW50SWQpIHtcclxuICAgICAgICAgICAgLy8gRW5zdXJlIHRoZSBjb21wb25lbnRJZCdzIG1hdGNoIChldmVuIHRob3VnaCB0aGV5IGFsd2F5cyBzaG91bGQpLlxyXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50SWQgIT09ICRzY29wZS5jb21wb25lbnRJZCkge1xyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvbkNsaWNrKCk7XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAkc2NvcGUub3Blbk9BdXRoID0gZnVuY3Rpb24oc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgLyplc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cclxuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHtcclxuICAgICAgICAgICAgICByZXNwb25zZV90eXBlOiAnY29kZScsXHJcbiAgICAgICAgICAgICAgY2xpZW50X2lkOiBzZXR0aW5ncy5jbGllbnRJZCxcclxuICAgICAgICAgICAgICByZWRpcmVjdF91cmk6IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gfHwgd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIHdpbmRvdy5sb2NhdGlvbi5ob3N0LFxyXG4gICAgICAgICAgICAgIHN0YXRlOiBzZXR0aW5ncy5zdGF0ZSxcclxuICAgICAgICAgICAgICBzY29wZTogc2V0dGluZ3Muc2NvcGVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyplc2xpbnQtZW5hYmxlIGNhbWVsY2FzZSAqL1xyXG5cclxuICAgICAgICAgICAgLy8gTWFrZSBkaXNwbGF5IG9wdGlvbmFsLlxyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuZGlzcGxheSkge1xyXG4gICAgICAgICAgICAgIHBhcmFtcy5kaXNwbGF5ID0gc2V0dGluZ3MuZGlzcGxheTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwYXJhbXMgPSBPYmplY3Qua2V5cyhwYXJhbXMpLm1hcChmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgICAgICByZXR1cm4ga2V5ICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtc1trZXldKTtcclxuICAgICAgICAgICAgfSkuam9pbignJicpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHVybCA9IHNldHRpbmdzLmF1dGhVUkkgKyAnPycgKyBwYXJhbXM7XHJcblxyXG4gICAgICAgICAgICAvLyBUT0RPOiBtYWtlIHdpbmRvdyBvcHRpb25zIGZyb20gb2F1dGggc2V0dGluZ3MsIGhhdmUgYmV0dGVyIGRlZmF1bHRzXHJcbiAgICAgICAgICAgIHZhciBwb3B1cCA9IHdpbmRvdy5vcGVuKHVybCwgc2V0dGluZ3MucHJvdmlkZXIsICd3aWR0aD0xMDIwLGhlaWdodD02MTgnKTtcclxuICAgICAgICAgICAgdmFyIGludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHZhciBwb3B1cEhvc3QgPSBwb3B1cC5sb2NhdGlvbi5ob3N0O1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRIb3N0ID0gd2luZG93LmxvY2F0aW9uLmhvc3Q7XHJcbiAgICAgICAgICAgICAgICBpZiAocG9wdXAgJiYgIXBvcHVwLmNsb3NlZCAmJiBwb3B1cEhvc3QgPT09IGN1cnJlbnRIb3N0ICYmIHBvcHVwLmxvY2F0aW9uLnNlYXJjaCkge1xyXG4gICAgICAgICAgICAgICAgICBwb3B1cC5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0gcG9wdXAubG9jYXRpb24uc2VhcmNoLnN1YnN0cigxKS5zcGxpdCgnJicpLnJlZHVjZShmdW5jdGlvbihwYXJhbXMsIHBhcmFtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwbGl0ID0gcGFyYW0uc3BsaXQoJz0nKTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXNbc3BsaXRbMF1dID0gc3BsaXRbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcclxuICAgICAgICAgICAgICAgICAgfSwge30pO1xyXG4gICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNob3dBbGVydHMoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RhbmdlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBwYXJhbXMuZXJyb3JfZGVzY3JpcHRpb24gfHwgcGFyYW1zLmVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGNoZWNrIGZvciBlcnJvciByZXNwb25zZSBoZXJlXHJcbiAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zdGF0ZSAhPT0gcGFyYW1zLnN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNob3dBbGVydHMoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RhbmdlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnT0F1dGggc3RhdGUgZG9lcyBub3QgbWF0Y2guIFBsZWFzZSB0cnkgbG9nZ2luZyBpbiBhZ2Fpbi4nXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIHZhciBzdWJtaXNzaW9uID0ge2RhdGE6IHt9LCBvYXV0aDoge319O1xyXG4gICAgICAgICAgICAgICAgICBzdWJtaXNzaW9uLm9hdXRoW3NldHRpbmdzLnByb3ZpZGVyXSA9IHBhcmFtcztcclxuICAgICAgICAgICAgICAgICAgc3VibWlzc2lvbi5vYXV0aFtzZXR0aW5ncy5wcm92aWRlcl0ucmVkaXJlY3RVUkkgPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luIHx8IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyB3aW5kb3cubG9jYXRpb24uaG9zdDtcclxuICAgICAgICAgICAgICAgICAgJHNjb3BlLmZvcm1pb0Zvcm0uc3VibWl0dGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICRzY29wZS5mb3JtaW8uc2F2ZVN1Ym1pc3Npb24oc3VibWlzc2lvbilcclxuICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oc3VibWlzc2lvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyaWdnZXIgdGhlIGZvcm0gc3VibWlzc2lvbi5cclxuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJGVtaXQoJ2Zvcm1TdWJtaXNzaW9uJywgc3VibWlzc2lvbik7XHJcbiAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5zaG93QWxlcnRzKHtcclxuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkYW5nZXInLFxyXG4gICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSB8fCBlcnJvclxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAuZmluYWxseShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZm9ybWlvRm9ybS5zdWJtaXR0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnJvci5uYW1lICE9PSAnU2VjdXJpdHlFcnJvcicpIHtcclxuICAgICAgICAgICAgICAgICAgJHNjb3BlLnNob3dBbGVydHMoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkYW5nZXInLFxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UgfHwgZXJyb3JcclxuICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmICghcG9wdXAgfHwgcG9wdXAuY2xvc2VkIHx8IHBvcHVwLmNsb3NlZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIDEwMCk7XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1dLFxyXG4gICAgICAgIHZpZXdUZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzVmlldy9idXR0b24uaHRtbCdcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgXSk7XHJcbiAgYXBwLnJ1bihbXHJcbiAgICAnJHRlbXBsYXRlQ2FjaGUnLFxyXG4gICAgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9idXR0b24uaHRtbCcsXHJcbiAgICAgICAgXCI8YnV0dG9uIG5nLWF0dHItdHlwZT1cXFwie3sgZ2V0QnV0dG9uVHlwZSgpIH19XFxcIlxcclxcbiAgaWQ9XFxcInt7IGNvbXBvbmVudElkIH19XFxcIlxcclxcbiAgbmFtZT1cXFwie3sgY29tcG9uZW50SWQgfX1cXFwiXFxyXFxuICBuZy1jbGFzcz1cXFwieydidG4tYmxvY2snOiBjb21wb25lbnQuYmxvY2t9XFxcIlxcclxcbiAgY2xhc3M9XFxcImJ0biBidG4te3sgY29tcG9uZW50LnRoZW1lIH19IGJ0bi17eyBjb21wb25lbnQuc2l6ZSB9fVxcXCJcXHJcXG4gIG5nLWRpc2FibGVkPVxcXCJyZWFkT25seSB8fCBmb3JtaW9Gb3JtLnN1Ym1pdHRpbmcgfHwgKGNvbXBvbmVudC5kaXNhYmxlT25JbnZhbGlkICYmIGZvcm1pb0Zvcm0uJGludmFsaWQpXFxcIlxcclxcbiAgdGFiaW5kZXg9XFxcInt7IGNvbXBvbmVudC50YWJpbmRleCB8fCAwIH19XFxcIlxcclxcbiAgbmctY2xpY2s9XFxcIiRlbWl0KCdidXR0b25DbGljaycsIGNvbXBvbmVudCwgY29tcG9uZW50SWQpXFxcIj5cXHJcXG4gIDxzcGFuIG5nLWlmPVxcXCJjb21wb25lbnQubGVmdEljb25cXFwiIGNsYXNzPVxcXCJ7eyBjb21wb25lbnQubGVmdEljb24gfX1cXFwiIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIj48L3NwYW4+XFxyXFxuICA8c3BhbiBuZy1pZj1cXFwiY29tcG9uZW50LmxlZnRJY29uICYmIGNvbXBvbmVudC5sYWJlbFxcXCI+Jm5ic3A7PC9zcGFuPnt7IGNvbXBvbmVudC5sYWJlbCB8IGZvcm1pb1RyYW5zbGF0ZTpudWxsOmJ1aWxkZXIgfX08c3BhbiBuZy1pZj1cXFwiY29tcG9uZW50LnJpZ2h0SWNvbiAmJiBjb21wb25lbnQubGFiZWxcXFwiPiZuYnNwOzwvc3Bhbj5cXHJcXG4gIDxzcGFuIG5nLWlmPVxcXCJjb21wb25lbnQucmlnaHRJY29uXFxcIiBjbGFzcz1cXFwie3sgY29tcG9uZW50LnJpZ2h0SWNvbiB9fVxcXCIgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiPjwvc3Bhbj5cXHJcXG4gICA8aSBuZy1pZj1cXFwiY29tcG9uZW50LmFjdGlvbiA9PSAnc3VibWl0JyAmJiBmb3JtaW9Gb3JtLnN1Ym1pdHRpbmdcXFwiIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLXJlZnJlc2ggZ2x5cGhpY29uLXNwaW5cXFwiPjwvaT5cXHJcXG48L2J1dHRvbj5cXHJcXG5cIlxyXG4gICAgICApO1xyXG5cclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50c1ZpZXcvYnV0dG9uLmh0bWwnLFxyXG4gICAgICAgIFwiXCJcclxuICAgICAgKTtcclxuICAgIH1cclxuICBdKTtcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcHApIHtcclxuICBhcHAuY29uZmlnKFtcclxuICAgICdmb3JtaW9Db21wb25lbnRzUHJvdmlkZXInLFxyXG4gICAgZnVuY3Rpb24oZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyKSB7XHJcbiAgICAgIGZvcm1pb0NvbXBvbmVudHNQcm92aWRlci5yZWdpc3RlcignY2hlY2tib3gnLCB7XHJcbiAgICAgICAgdGl0bGU6ICdDaGVjayBCb3gnLFxyXG4gICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvY2hlY2tib3guaHRtbCcsXHJcbiAgICAgICAgdGFibGVWaWV3OiBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgICAgICByZXR1cm4gZGF0YSA/ICdZZXMnIDogJ05vJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IFsnJHNjb3BlJywgJyR0aW1lb3V0JywgZnVuY3Rpb24oJHNjb3BlLCAkdGltZW91dCkge1xyXG4gICAgICAgICAgaWYgKCRzY29wZS5idWlsZGVyKSByZXR1cm47XHJcbiAgICAgICAgICB2YXIgYm9vbGVhbiA9IHtcclxuICAgICAgICAgICAgdHJ1ZTogdHJ1ZSxcclxuICAgICAgICAgICAgZmFsc2U6IGZhbHNlXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9ICRzY29wZS5jb21wb25lbnQuaGFzT3duUHJvcGVydHkoJ2RlZmF1bHRWYWx1ZScpXHJcbiAgICAgICAgICAgID8gYm9vbGVhblskc2NvcGUuY29tcG9uZW50LmRlZmF1bHRWYWx1ZV0gfHwgZmFsc2VcclxuICAgICAgICAgICAgOiBmYWxzZTtcclxuXHJcbiAgICAgICAgICAvLyBGT1ItNDQwIC0gT25seSB1c2UgdGhlIGRlZmF1bHQgdmFsdWUgaWYgdGhlIGRhdGEgaXNuJ3QgZGVmaW5lZC5cclxuICAgICAgICAgIC8vIE9uIHRoZSBmaXJzdCBsb2FkLCBhdHRlbXB0IHRvIHNldCB0aGUgZGVmYXVsdCB2YWx1ZS5cclxuICAgICAgICAgICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSA9ICRzY29wZS5kYXRhLmhhc093blByb3BlcnR5KCRzY29wZS5jb21wb25lbnQua2V5KSAmJiBib29sZWFuLmhhc093blByb3BlcnR5KCRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSlcclxuICAgICAgICAgICAgPyBib29sZWFuWyRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XV1cclxuICAgICAgICAgICAgOiBkZWZhdWx0VmFsdWU7XHJcblxyXG4gICAgICAgICAgLy8gRkEtODUwIC0gRW5zdXJlIHRoZSBjaGVja2VkIHZhbHVlIGlzIGFsd2F5cyBhIGJvb2xlYW4gb2JqZWN0IHdoZW4gbG9hZGVkLCB0aGVuIHVuYmluZCB0aGUgd2F0Y2guXHJcbiAgICAgICAgICBpZiAoJHNjb3BlLmNvbXBvbmVudC5pbnB1dFR5cGUgPT09ICdjaGVja2JveCcpIHtcclxuICAgICAgICAgICAgJHNjb3BlLiR3YXRjaCgnZGF0YS4nICsgJHNjb3BlLmNvbXBvbmVudC5rZXksIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgIGlmICghJHNjb3BlLmRhdGEgfHwgISRzY29wZS5jb21wb25lbnQua2V5KSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgIC8vIElmIHRoZSBjb21wb25lbnQgaXMgcmVxdWlyZWQsIGFuZCBpdHMgY3VycmVudCB2YWx1ZSBpcyBmYWxzZSwgZGVsZXRlIHRoZSBlbnRyeS5cclxuICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAkc2NvcGUuY29tcG9uZW50LnZhbGlkYXRlXHJcbiAgICAgICAgICAgICAgICAmJiAkc2NvcGUuY29tcG9uZW50LnZhbGlkYXRlLnJlcXVpcmVkXHJcbiAgICAgICAgICAgICAgICAmJiAoYm9vbGVhblskc2NvcGUuZGF0YVskc2NvcGUuY29tcG9uZW50LmtleV1dIHx8IGZhbHNlKSA9PT0gZmFsc2VcclxuICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICBkZWxldGUgJHNjb3BlLmRhdGFbJHNjb3BlLmNvbXBvbmVudC5rZXldO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XSxcclxuICAgICAgICBzZXR0aW5nczoge1xyXG4gICAgICAgICAgaW5wdXQ6IHRydWUsXHJcbiAgICAgICAgICBpbnB1dFR5cGU6ICdjaGVja2JveCcsXHJcbiAgICAgICAgICB0YWJsZVZpZXc6IHRydWUsXHJcbiAgICAgICAgICAvLyBUaGlzIGhpZGVzIHRoZSBkZWZhdWx0IGxhYmVsIGxheW91dCBzbyB3ZSBjYW4gdXNlIGEgc3BlY2lhbCBpbmxpbmUgbGFiZWxcclxuICAgICAgICAgIGhpZGVMYWJlbDogdHJ1ZSxcclxuICAgICAgICAgIGxhYmVsOiAnJyxcclxuICAgICAgICAgIGRhdGFncmlkTGFiZWw6IHRydWUsXHJcbiAgICAgICAgICBrZXk6ICdjaGVja2JveEZpZWxkJyxcclxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZmFsc2UsXHJcbiAgICAgICAgICBwcm90ZWN0ZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgcGVyc2lzdGVudDogdHJ1ZSxcclxuICAgICAgICAgIGhpZGRlbjogZmFsc2UsXHJcbiAgICAgICAgICBuYW1lOiAnJyxcclxuICAgICAgICAgIHZhbHVlOiAnJyxcclxuICAgICAgICAgIGNsZWFyT25IaWRlOiB0cnVlLFxyXG4gICAgICAgICAgdmFsaWRhdGU6IHtcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICBdKTtcclxuICBhcHAucnVuKFtcclxuICAgICckdGVtcGxhdGVDYWNoZScsXHJcbiAgICBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL2NoZWNrYm94Lmh0bWwnLFxyXG4gICAgICAgIFwiPGRpdiBjbGFzcz1cXFwiY2hlY2tib3hcXFwiPlxcclxcbiAgPGxhYmVsIGZvcj1cXFwie3sgY29tcG9uZW50SWQgfX1cXFwiIG5nLWNsYXNzPVxcXCJ7J2ZpZWxkLXJlcXVpcmVkJzogaXNSZXF1aXJlZChjb21wb25lbnQpfVxcXCI+XFxyXFxuICAgIDxpbnB1dFxcclxcbiAgICAgIG5nLWlmPVxcXCJjb21wb25lbnQubmFtZVxcXCJcXHJcXG4gICAgICB0eXBlPVxcXCJ7eyBjb21wb25lbnQuaW5wdXRUeXBlIH19XFxcIlxcclxcbiAgICAgIGlkPVxcXCJ7eyBjb21wb25lbnRJZCB9fVxcXCJcXHJcXG4gICAgICBuYW1lPVxcXCJ7eyBjb21wb25lbnQubmFtZSB9fVxcXCJcXHJcXG4gICAgICB2YWx1ZT1cXFwie3sgY29tcG9uZW50LnZhbHVlIH19XFxcIlxcclxcbiAgICAgIHRhYmluZGV4PVxcXCJ7eyBjb21wb25lbnQudGFiaW5kZXggfHwgMCB9fVxcXCJcXHJcXG4gICAgICBuZy1kaXNhYmxlZD1cXFwicmVhZE9ubHlcXFwiXFxyXFxuICAgICAgbmctbW9kZWw9XFxcImRhdGFbY29tcG9uZW50Lm5hbWVdXFxcIlxcclxcbiAgICAgIG5nLXJlcXVpcmVkPVxcXCJjb21wb25lbnQudmFsaWRhdGUucmVxdWlyZWRcXFwiXFxyXFxuICAgID5cXHJcXG4gICAgPGlucHV0XFxyXFxuICAgICAgbmctaWY9XFxcIiFjb21wb25lbnQubmFtZVxcXCJcXHJcXG4gICAgICB0eXBlPVxcXCJ7eyBjb21wb25lbnQuaW5wdXRUeXBlIH19XFxcIlxcclxcbiAgICAgIGlkPVxcXCJ7eyBjb21wb25lbnRJZCB9fVxcXCJcXHJcXG4gICAgICB0YWJpbmRleD1cXFwie3sgY29tcG9uZW50LnRhYmluZGV4IHx8IDAgfX1cXFwiXFxyXFxuICAgICAgbmctZGlzYWJsZWQ9XFxcInJlYWRPbmx5XFxcIlxcclxcbiAgICAgIG5nLW1vZGVsPVxcXCJkYXRhW2NvbXBvbmVudC5rZXldXFxcIlxcclxcbiAgICAgIG5nLXJlcXVpcmVkPVxcXCJpc1JlcXVpcmVkKGNvbXBvbmVudClcXFwiXFxyXFxuICAgICAgY3VzdG9tLXZhbGlkYXRvcj1cXFwiY29tcG9uZW50LnZhbGlkYXRlLmN1c3RvbVxcXCJcXHJcXG4gICAgPlxcclxcbiAgICA8c3BhbiBuZy1pZj1cXFwiIShjb21wb25lbnQuaGlkZUxhYmVsICYmIGNvbXBvbmVudC5kYXRhZ3JpZExhYmVsID09PSBmYWxzZSlcXFwiPnt7IGNvbXBvbmVudC5sYWJlbCB8IGZvcm1pb1RyYW5zbGF0ZTpudWxsOmJ1aWxkZXIgfX08L3NwYW4+XFxyXFxuICA8L2xhYmVsPlxcclxcbjwvZGl2PlxcclxcbjxkaXYgbmctaWY9XFxcIiEhY29tcG9uZW50LmRlc2NyaXB0aW9uXFxcIiBjbGFzcz1cXFwiaGVscC1ibG9ja1xcXCI+XFxyXFxuICA8c3Bhbj57eyBjb21wb25lbnQuZGVzY3JpcHRpb24gfX08L3NwYW4+XFxyXFxuPC9kaXY+XFxyXFxuXCJcclxuICAgICAgKTtcclxuICAgIH1cclxuICBdKTtcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cclxudmFyIEdyaWRVdGlscyA9IHJlcXVpcmUoJy4uL2ZhY3Rvcmllcy9HcmlkVXRpbHMnKSgpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcHApIHtcclxuICBhcHAuY29uZmlnKFtcclxuICAgICdmb3JtaW9Db21wb25lbnRzUHJvdmlkZXInLFxyXG4gICAgZnVuY3Rpb24oZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyKSB7XHJcbiAgICAgIGZvcm1pb0NvbXBvbmVudHNQcm92aWRlci5yZWdpc3RlcignY29sdW1ucycsIHtcclxuICAgICAgICB0aXRsZTogJ0NvbHVtbnMnLFxyXG4gICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvY29sdW1ucy5odG1sJyxcclxuICAgICAgICBncm91cDogJ2xheW91dCcsXHJcbiAgICAgICAgc2V0dGluZ3M6IHtcclxuICAgICAgICAgIGlucHV0OiBmYWxzZSxcclxuICAgICAgICAgIHRhYmxlVmlldzogdHJ1ZSxcclxuICAgICAgICAgIGtleTogJ2NvbHVtbnMnLFxyXG4gICAgICAgICAgY29sdW1uczogW3tjb21wb25lbnRzOiBbXSwgd2lkdGg6IDYsIG9mZnNldDogMCwgcHVzaDogMCwgcHVsbDogMH0sXHJcbiAgICAgICAgICAgICAgICAgICAge2NvbXBvbmVudHM6IFtdLCB3aWR0aDogNiwgb2Zmc2V0OiAwLCBwdXNoOiAwLCBwdWxsOiAwfV1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IFsnJHNjb3BlJywgZnVuY3Rpb24oJHNjb3BlKSB7XHJcbiAgICAgICAgICAvLyBBZGp1c3QgY29sdW1uIGNvbXBvbmVudCBzZXR0aW5nIGZyb20gYmVmb3JlIHdpZHRoLCBvZmZzZXQuLi5cclxuICAgICAgICAgIGlmICgkc2NvcGUuY29tcG9uZW50LmNvbHVtbnMubGVuZ3RoICAgPT09IDJcclxuICAgICAgICAgICYmICAkc2NvcGUuY29tcG9uZW50LmNvbHVtbnNbMF0ud2lkdGggPT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgJiYgICRzY29wZS5jb21wb25lbnQuY29sdW1uc1sxXS53aWR0aCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgJHNjb3BlLmNvbXBvbmVudC5jb2x1bW5zWzBdLndpZHRoICAgPSA2O1xyXG4gICAgICAgICAgICAgICRzY29wZS5jb21wb25lbnQuY29sdW1uc1swXS5vZmZzZXQgID0gMDtcclxuICAgICAgICAgICAgICAkc2NvcGUuY29tcG9uZW50LmNvbHVtbnNbMF0ucHVzaCAgICA9IDA7XHJcbiAgICAgICAgICAgICAgJHNjb3BlLmNvbXBvbmVudC5jb2x1bW5zWzBdLnB1bGwgICAgPSAwO1xyXG4gICAgICAgICAgICAgICRzY29wZS5jb21wb25lbnQuY29sdW1uc1sxXS53aWR0aCAgID0gNjtcclxuICAgICAgICAgICAgICAkc2NvcGUuY29tcG9uZW50LmNvbHVtbnNbMV0ub2Zmc2V0ICA9IDA7XHJcbiAgICAgICAgICAgICAgJHNjb3BlLmNvbXBvbmVudC5jb2x1bW5zWzFdLnB1c2ggICAgPSAwO1xyXG4gICAgICAgICAgICAgICRzY29wZS5jb21wb25lbnQuY29sdW1uc1sxXS5wdWxsICAgID0gMDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XSxcclxuICAgICAgICB2aWV3VGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50c1ZpZXcvY29sdW1ucy5odG1sJyxcclxuICAgICAgICB0YWJsZVZpZXc6IGZ1bmN0aW9uKGRhdGEsIGNvbXBvbmVudCwgJGludGVycG9sYXRlLCBjb21wb25lbnRJbmZvLCB0YWJsZUNoaWxkKSB7XHJcbiAgICAgICAgICB2YXIgdmlldyA9ICc8dGFibGUgY2xhc3M9XCJ0YWJsZSB0YWJsZS1zdHJpcGVkIHRhYmxlLWJvcmRlcmVkIHRhYmxlLWNoaWxkXCI+JztcclxuICAgICAgICAgIGlmICghdGFibGVDaGlsZCkge1xyXG4gICAgICAgICAgICB2aWV3ICs9ICc8dGhlYWQ+PHRyPic7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdmFyIG1heFJvd3MgPSAwO1xyXG4gICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGNvbXBvbmVudC5jb2x1bW5zLCBmdW5jdGlvbihjb2x1bW4sIGluZGV4KSB7XHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgbWF4aW11bSBudW1iZXIgb2Ygcm93cyBiYXNlZCBvbiB0aGUgbnVtYmVyIG9mIGNvbXBvbmVudHMuXHJcbiAgICAgICAgICAgIG1heFJvd3MgPSBNYXRoLm1heChtYXhSb3dzLCAoY29sdW1uLmNvbXBvbmVudHMubGVuZ3RoIHx8IDApKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghdGFibGVDaGlsZCkge1xyXG4gICAgICAgICAgICAgIC8vIEFkZCBhIGhlYWRlciBmb3IgZWFjaCBjb2x1bW4uXHJcbiAgICAgICAgICAgICAgdmlldyArPSAnPHRoPkNvbHVtbiAnICsgKGluZGV4ICsgMSkgKyAnICgnICsgY29tcG9uZW50LmtleSArICcpPC90aD4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICBpZiAoIXRhYmxlQ2hpbGQpIHtcclxuICAgICAgICAgICAgdmlldyArPSAnPC90cj48L3RoZWFkPic7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdmlldyArPSAnPHRib2R5Pic7XHJcbiAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbWF4Um93czsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICB2aWV3ICs9ICc8dHI+JztcclxuICAgICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgY29tcG9uZW50LmNvbHVtbnMubGVuZ3RoOyBjb2wrKykge1xyXG4gICAgICAgICAgICAgIHZpZXcgKz0gR3JpZFV0aWxzLmNvbHVtbkZvckNvbXBvbmVudChkYXRhLCBjb21wb25lbnQuY29sdW1uc1tjb2xdLmNvbXBvbmVudHNbaW5kZXhdIHx8IHVuZGVmaW5lZCwgJGludGVycG9sYXRlLCBjb21wb25lbnRJbmZvLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2aWV3ICs9ICc8L3RyPic7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB2aWV3ICs9ICc8L3Rib2R5PjwvdGFibGU+JztcclxuICAgICAgICAgIHJldHVybiB2aWV3O1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgXSk7XHJcbiAgYXBwLnJ1bihbXHJcbiAgICAnJHRlbXBsYXRlQ2FjaGUnLFxyXG4gICAgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9jb2x1bW5zLmh0bWwnLFxyXG4gICAgICAgIFwiPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXHJcXG4gIDxkaXYgbmctc2hvdz1cXFwiY29sdW1uLndpZHRoXFxcIiBuZy1jbGFzcz1cXFwiJ2NvbC1zbS0nICsgY29sdW1uLndpZHRoICsgJyBjb2wtc20tb2Zmc2V0LScgKyBjb2x1bW4ub2Zmc2V0ICsgJyBjb2wtc20tcHVzaC0nICsgY29sdW1uLnB1c2ggKyAnIGNvbC1zbS1wdWxsLScgKyBjb2x1bW4ucHVsbFxcXCIgbmctcmVwZWF0PVxcXCJjb2x1bW4gaW4gY29tcG9uZW50LmNvbHVtbnMgdHJhY2sgYnkgJGluZGV4XFxcIj5cXHJcXG4gICAgPGZvcm1pby1jb21wb25lbnRcXHJcXG4gICAgICBuZy1yZXBlYXQ9XFxcIl9jb21wb25lbnQgaW4gY29sdW1uLmNvbXBvbmVudHMgdHJhY2sgYnkgJGluZGV4XFxcIlxcclxcbiAgICAgIGNvbXBvbmVudD1cXFwiX2NvbXBvbmVudFxcXCJcXHJcXG4gICAgICBkYXRhPVxcXCJkYXRhXFxcIlxcclxcbiAgICAgIGZvcm1pbz1cXFwiZm9ybWlvXFxcIlxcclxcbiAgICAgIHN1Ym1pc3Npb249XFxcInN1Ym1pc3Npb25cXFwiXFxyXFxuICAgICAgaGlkZS1jb21wb25lbnRzPVxcXCJoaWRlQ29tcG9uZW50c1xcXCJcXHJcXG4gICAgICBuZy1pZj1cXFwiYnVpbGRlciA/ICc6OnRydWUnIDogaXNWaXNpYmxlKF9jb21wb25lbnQsIGRhdGEpXFxcIlxcclxcbiAgICAgIGZvcm1pby1mb3JtPVxcXCJmb3JtaW9Gb3JtXFxcIlxcclxcbiAgICAgIHJlYWQtb25seT1cXFwiaXNEaXNhYmxlZChfY29tcG9uZW50LCBkYXRhKVxcXCJcXHJcXG4gICAgICBncmlkLXJvdz1cXFwiZ3JpZFJvd1xcXCJcXHJcXG4gICAgICBncmlkLWNvbD1cXFwiZ3JpZENvbFxcXCJcXHJcXG4gICAgICBidWlsZGVyPVxcXCJidWlsZGVyXFxcIlxcclxcbiAgICA+PC9mb3JtaW8tY29tcG9uZW50PlxcclxcbiAgPC9kaXY+XFxyXFxuPC9kaXY+XFxyXFxuXCJcclxuICAgICAgKTtcclxuXHJcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHNWaWV3L2NvbHVtbnMuaHRtbCcsXHJcbiAgICAgICAgXCI8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcclxcbiAgPGRpdiBuZy1zaG93PVxcXCJjb2x1bW4ud2lkdGhcXFwiIG5nLWNsYXNzPVxcXCInY29sLXNtLScgKyBjb2x1bW4ud2lkdGggKyAnIGNvbC1zbS1vZmZzZXQtJyArIGNvbHVtbi5vZmZzZXQgKyAnIGNvbC1zbS1wdXNoLScgKyBjb2x1bW4ucHVzaCArICcgY29sLXNtLXB1bGwtJyArIGNvbHVtbi5wdWxsXFxcIiBuZy1yZXBlYXQ9XFxcImNvbHVtbiBpbiBjb21wb25lbnQuY29sdW1ucyB0cmFjayBieSAkaW5kZXhcXFwiPlxcclxcbiAgICA8Zm9ybWlvLWNvbXBvbmVudC12aWV3XFxyXFxuICAgICAgbmctcmVwZWF0PVxcXCJfY29tcG9uZW50IGluIGNvbHVtbi5jb21wb25lbnRzIHRyYWNrIGJ5ICRpbmRleFxcXCJcXHJcXG4gICAgICBjb21wb25lbnQ9XFxcIl9jb21wb25lbnRcXFwiXFxyXFxuICAgICAgZGF0YT1cXFwiZGF0YVxcXCJcXHJcXG4gICAgICBmb3JtPVxcXCJmb3JtXFxcIlxcclxcbiAgICAgIHN1Ym1pc3Npb249XFxcInN1Ym1pc3Npb25cXFwiXFxyXFxuICAgICAgaWdub3JlPVxcXCJpZ25vcmVcXFwiXFxyXFxuICAgICAgbmctaWY9XFxcImJ1aWxkZXIgPyAnOjp0cnVlJyA6IGlzVmlzaWJsZShfY29tcG9uZW50LCBkYXRhKVxcXCJcXHJcXG4gICAgICBidWlsZGVyPVxcXCJidWlsZGVyXFxcIlxcclxcbiAgICA+PC9mb3JtaW8tY29tcG9uZW50LXZpZXc+XFxyXFxuICA8L2Rpdj5cXHJcXG48L2Rpdj5cXHJcXG5cIlxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIF0pO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBwKSB7XHJcbiAgYXBwLnByb3ZpZGVyKCdmb3JtaW9Db21wb25lbnRzJywgZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgY29tcG9uZW50cyA9IHt9O1xyXG4gICAgdmFyIGdyb3VwcyA9IHtcclxuICAgICAgX19jb21wb25lbnQ6IHtcclxuICAgICAgICB0aXRsZTogJ0Jhc2ljIENvbXBvbmVudHMnXHJcbiAgICAgIH0sXHJcbiAgICAgIGFkdmFuY2VkOiB7XHJcbiAgICAgICAgdGl0bGU6ICdTcGVjaWFsIENvbXBvbmVudHMnXHJcbiAgICAgIH0sXHJcbiAgICAgIGxheW91dDoge1xyXG4gICAgICAgIHRpdGxlOiAnTGF5b3V0IENvbXBvbmVudHMnXHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBhZGRHcm91cDogZnVuY3Rpb24obmFtZSwgZ3JvdXApIHtcclxuICAgICAgICBncm91cHNbbmFtZV0gPSBncm91cDtcclxuICAgICAgfSxcclxuICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKHR5cGUsIGNvbXBvbmVudCwgZ3JvdXApIHtcclxuICAgICAgICBpZiAoIWNvbXBvbmVudHNbdHlwZV0pIHtcclxuICAgICAgICAgIGNvbXBvbmVudHNbdHlwZV0gPSBjb21wb25lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgYW5ndWxhci5leHRlbmQoY29tcG9uZW50c1t0eXBlXSwgY29tcG9uZW50KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFNldCB0aGUgdHlwZSBmb3IgdGhpcyBjb21wb25lbnQuXHJcbiAgICAgICAgaWYgKCFjb21wb25lbnRzW3R5cGVdLmdyb3VwKSB7XHJcbiAgICAgICAgICBjb21wb25lbnRzW3R5cGVdLmdyb3VwID0gZ3JvdXAgfHwgJ19fY29tcG9uZW50JztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcG9uZW50c1t0eXBlXS5zZXR0aW5ncy50eXBlID0gdHlwZTtcclxuICAgICAgfSxcclxuICAgICAgJGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHMsXHJcbiAgICAgICAgICBncm91cHM6IGdyb3Vwc1xyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfSk7XHJcblxyXG4gIGFwcC5kaXJlY3RpdmUoJ3NhZmVNdWx0aXBsZVRvU2luZ2xlJywgW2Z1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcmVxdWlyZTogJ25nTW9kZWwnLFxyXG4gICAgICByZXN0cmljdDogJ0EnLFxyXG4gICAgICBsaW5rOiBmdW5jdGlvbigkc2NvcGUsIGVsLCBhdHRycywgbmdNb2RlbCkge1xyXG4gICAgICAgIG5nTW9kZWwuJGZvcm1hdHRlcnMucHVzaChmdW5jdGlvbihtb2RlbFZhbHVlKSB7XHJcbiAgICAgICAgICBpZiAoISRzY29wZS5jb21wb25lbnQubXVsdGlwbGUgJiYgQXJyYXkuaXNBcnJheShtb2RlbFZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9kZWxWYWx1ZVswXSB8fCAnJztcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4gbW9kZWxWYWx1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XSk7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xuXHJcbnZhciBHcmlkVXRpbHMgPSByZXF1aXJlKCcuLi9mYWN0b3JpZXMvR3JpZFV0aWxzJykoKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBwKSB7XHJcbiAgYXBwLmNvbmZpZyhbXHJcbiAgICAnZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyJyxcclxuICAgIGZ1bmN0aW9uKGZvcm1pb0NvbXBvbmVudHNQcm92aWRlcikge1xyXG4gICAgICBmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIucmVnaXN0ZXIoJ2NvbnRhaW5lcicsIHtcclxuICAgICAgICB0aXRsZTogJ0NvbnRhaW5lcicsXHJcbiAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9jb250YWluZXIuaHRtbCcsXHJcbiAgICAgICAgdmlld1RlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHNWaWV3L2NvbnRhaW5lci5odG1sJyxcclxuICAgICAgICBncm91cDogJ2FkdmFuY2VkJyxcclxuICAgICAgICBpY29uOiAnZmEgZmEtZm9sZGVyLW9wZW4nLFxyXG4gICAgICAgIHRhYmxlVmlldzogZnVuY3Rpb24oZGF0YSwgY29tcG9uZW50LCAkaW50ZXJwb2xhdGUsIGNvbXBvbmVudEluZm8sIHRhYmxlQ2hpbGQpIHtcclxuICAgICAgICAgIHZhciB2aWV3ID0gJzx0YWJsZSBjbGFzcz1cInRhYmxlIHRhYmxlLXN0cmlwZWQgdGFibGUtYm9yZGVyZWQgdGFibGUtY2hpbGRcIj4nO1xyXG5cclxuICAgICAgICAgIGlmICghdGFibGVDaGlsZCkge1xyXG4gICAgICAgICAgICB2aWV3ICs9ICc8dGhlYWQ+PHRyPic7XHJcbiAgICAgICAgICAgIHZpZXcgKz0gJzx0aD4nICsgKGNvbXBvbmVudC5sYWJlbCB8fCAnJykgKyAnICgnICsgY29tcG9uZW50LmtleSArICcpPC90aD4nO1xyXG4gICAgICAgICAgICB2aWV3ICs9ICc8L3RyPjwvdGhlYWQ+JztcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB2aWV3ICs9ICc8dGJvZHk+JztcclxuXHJcbiAgICAgICAgICAvLyBSZW5kZXIgYSB2YWx1ZSBmb3IgZWFjaCBjb2x1bW4gaXRlbS5cclxuICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChjb21wb25lbnQuY29tcG9uZW50cywgZnVuY3Rpb24oY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIHZpZXcgKz0gJzx0cj4nICsgR3JpZFV0aWxzLmNvbHVtbkZvckNvbXBvbmVudChkYXRhLCBjb21wb25lbnQsICRpbnRlcnBvbGF0ZSwgY29tcG9uZW50SW5mbywgdHJ1ZSkgKyAnPC90cj4nO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgdmlldyArPSAnPC90Ym9keT48L3RhYmxlPic7XHJcbiAgICAgICAgICByZXR1cm4gdmlldztcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldHRpbmdzOiB7XHJcbiAgICAgICAgICBpbnB1dDogdHJ1ZSxcclxuICAgICAgICAgIHRyZWU6IHRydWUsXHJcbiAgICAgICAgICBjb21wb25lbnRzOiBbXSxcclxuICAgICAgICAgIHRhYmxlVmlldzogdHJ1ZSxcclxuICAgICAgICAgIGxhYmVsOiAnJyxcclxuICAgICAgICAgIGtleTogJ2NvbnRhaW5lcicsXHJcbiAgICAgICAgICBwcm90ZWN0ZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgcGVyc2lzdGVudDogdHJ1ZSxcclxuICAgICAgICAgIGNsZWFyT25IaWRlOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICBdKTtcclxuICBhcHAuY29udHJvbGxlcignZm9ybWlvQ29udGFpbmVyQ29tcG9uZW50JywgW1xyXG4gICAgJyRzY29wZScsXHJcbiAgICBmdW5jdGlvbigkc2NvcGUpIHtcclxuICAgICAgJHNjb3BlLmRhdGFbJHNjb3BlLmNvbXBvbmVudC5rZXldID0gJHNjb3BlLmRhdGFbJHNjb3BlLmNvbXBvbmVudC5rZXldIHx8IHt9O1xyXG4gICAgICAkc2NvcGUucGFyZW50S2V5ID0gJHNjb3BlLmNvbXBvbmVudC5rZXk7XHJcbiAgICB9XHJcbiAgXSk7XHJcbiAgYXBwLnJ1bihbXHJcbiAgICAnJHRlbXBsYXRlQ2FjaGUnLFxyXG4gICAgJ0Zvcm1pb1V0aWxzJyxcclxuICAgIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlLCBGb3JtaW9VdGlscykge1xyXG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL2NvbnRhaW5lci5odG1sJywgRm9ybWlvVXRpbHMuZmllbGRXcmFwKFxyXG4gICAgICAgIFwiPGRpdiBuZy1jb250cm9sbGVyPVxcXCJmb3JtaW9Db250YWluZXJDb21wb25lbnRcXFwiIGNsYXNzPVxcXCJmb3JtaW8tY29udGFpbmVyLWNvbXBvbmVudFxcXCI+XFxyXFxuICA8Zm9ybWlvLWNvbXBvbmVudFxcclxcbiAgICBuZy1yZXBlYXQ9XFxcIl9jb21wb25lbnQgaW4gY29tcG9uZW50LmNvbXBvbmVudHMgdHJhY2sgYnkgJGluZGV4XFxcIlxcclxcbiAgICBjb21wb25lbnQ9XFxcIl9jb21wb25lbnRcXFwiXFxyXFxuICAgIGRhdGE9XFxcImRhdGFbcGFyZW50S2V5XVxcXCJcXHJcXG4gICAgZm9ybWlvPVxcXCJmb3JtaW9cXFwiXFxyXFxuICAgIHN1Ym1pc3Npb249XFxcInN1Ym1pc3Npb25cXFwiXFxyXFxuICAgIGhpZGUtY29tcG9uZW50cz1cXFwiaGlkZUNvbXBvbmVudHNcXFwiXFxyXFxuICAgIG5nLWlmPVxcXCJidWlsZGVyID8gJzo6dHJ1ZScgOiBpc1Zpc2libGUoX2NvbXBvbmVudCwgZGF0YVtwYXJlbnRLZXldKVxcXCJcXHJcXG4gICAgZm9ybWlvLWZvcm09XFxcImZvcm1pb0Zvcm1cXFwiXFxyXFxuICAgIHJlYWQtb25seT1cXFwiaXNEaXNhYmxlZChfY29tcG9uZW50LCBkYXRhW3BhcmVudEtleV0pXFxcIlxcclxcbiAgICBncmlkLXJvdz1cXFwiZ3JpZFJvd1xcXCJcXHJcXG4gICAgZ3JpZC1jb2w9XFxcImdyaWRDb2xcXFwiXFxyXFxuICAgIGJ1aWxkZXI9XFxcImJ1aWxkZXJcXFwiXFxyXFxuICA+PC9mb3JtaW8tY29tcG9uZW50PlxcclxcbjwvZGl2PlxcclxcblwiXHJcbiAgICAgICkpO1xyXG4gICAgfVxyXG4gIF0pO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFwcCkge1xyXG4gIGFwcC5jb25maWcoW1xyXG4gICAgJ2Zvcm1pb0NvbXBvbmVudHNQcm92aWRlcicsXHJcbiAgICBmdW5jdGlvbihmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIpIHtcclxuICAgICAgZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyLnJlZ2lzdGVyKCdjb250ZW50Jywge1xyXG4gICAgICAgIHRpdGxlOiAnQ29udGVudCcsXHJcbiAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9jb250ZW50Lmh0bWwnLFxyXG4gICAgICAgIHNldHRpbmdzOiB7XHJcbiAgICAgICAgICBrZXk6ICdjb250ZW50JyxcclxuICAgICAgICAgIGlucHV0OiBmYWxzZSxcclxuICAgICAgICAgIGh0bWw6ICcnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB2aWV3VGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9jb250ZW50Lmh0bWwnXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIF0pO1xyXG4gIGFwcC5ydW4oW1xyXG4gICAgJyR0ZW1wbGF0ZUNhY2hlJyxcclxuICAgIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvY29udGVudC5odG1sJyxcclxuICAgICAgICBcIjxkaXYgbmctYmluZC1odG1sPVxcXCJjb21wb25lbnQuaHRtbCB8IHNhZmVodG1sIHwgZm9ybWlvVHJhbnNsYXRlOmNvbXBvbmVudC5rZXk6YnVpbGRlclxcXCIgaWQ9XFxcInt7IGNvbXBvbmVudC5rZXkgfX1cXFwiPjwvZGl2PlxcclxcblwiXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgXSk7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFwcCkge1xyXG4gIGFwcC5kaXJlY3RpdmUoJ2N1cnJlbmN5SW5wdXQnLCBmdW5jdGlvbigpIHtcclxuICAgIC8vIE1heSBiZSBiZXR0ZXIgd2F5IHRoYW4gYWRkaW5nIHRvIHByb3RvdHlwZS5cclxuICAgIHZhciBzcGxpY2UgPSBmdW5jdGlvbihzdHJpbmcsIGlkeCwgcmVtLCBzKSB7XHJcbiAgICAgIHJldHVybiAoc3RyaW5nLnNsaWNlKDAsIGlkeCkgKyBzICsgc3RyaW5nLnNsaWNlKGlkeCArIE1hdGguYWJzKHJlbSkpKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICByZXN0cmljdDogJ0EnLFxyXG4gICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCkge1xyXG4gICAgICAgIGlmIChzY29wZS5idWlsZGVyKSByZXR1cm47XHJcbiAgICAgICAgZWxlbWVudC5iaW5kKCdrZXl1cCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgdmFyIGRhdGEgPSBzY29wZS5kYXRhW3Njb3BlLmNvbXBvbmVudC5rZXldO1xyXG5cclxuICAgICAgICAgIC8vY2xlYXJpbmcgbGVmdCBzaWRlIHplcm9zXHJcbiAgICAgICAgICB3aGlsZSAoZGF0YS5jaGFyQXQoMCkgPT09ICcwJykge1xyXG4gICAgICAgICAgICBkYXRhID0gZGF0YS5zdWJzdHIoMSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZGF0YSA9IGRhdGEucmVwbGFjZSgvW15cXGQuXFwnLCddL2csICcnKTtcclxuXHJcbiAgICAgICAgICB2YXIgcG9pbnQgPSBkYXRhLmluZGV4T2YoJy4nKTtcclxuICAgICAgICAgIGlmIChwb2ludCA+PSAwKSB7XHJcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhLnNsaWNlKDAsIHBvaW50ICsgMyk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdmFyIGRlY2ltYWxTcGxpdCA9IGRhdGEuc3BsaXQoJy4nKTtcclxuICAgICAgICAgIHZhciBpbnRQYXJ0ID0gZGVjaW1hbFNwbGl0WzBdO1xyXG4gICAgICAgICAgdmFyIGRlY1BhcnQgPSBkZWNpbWFsU3BsaXRbMV07XHJcblxyXG4gICAgICAgICAgaW50UGFydCA9IGludFBhcnQucmVwbGFjZSgvW15cXGRdL2csICcnKTtcclxuICAgICAgICAgIGlmIChpbnRQYXJ0Lmxlbmd0aCA+IDMpIHtcclxuICAgICAgICAgICAgdmFyIGludERpdiA9IE1hdGguZmxvb3IoaW50UGFydC5sZW5ndGggLyAzKTtcclxuICAgICAgICAgICAgd2hpbGUgKGludERpdiA+IDApIHtcclxuICAgICAgICAgICAgICB2YXIgbGFzdENvbW1hID0gaW50UGFydC5pbmRleE9mKCcsJyk7XHJcbiAgICAgICAgICAgICAgaWYgKGxhc3RDb21tYSA8IDApIHtcclxuICAgICAgICAgICAgICAgIGxhc3RDb21tYSA9IGludFBhcnQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgaWYgKGxhc3RDb21tYSAtIDMgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBpbnRQYXJ0ID0gc3BsaWNlKGludFBhcnQsIGxhc3RDb21tYSAtIDMsIDAsICcsJyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGludERpdi0tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKGRlY1BhcnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBkZWNQYXJ0ID0gJyc7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZGVjUGFydCA9ICcuJyArIGRlY1BhcnQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB2YXIgcmVzID0gaW50UGFydCArIGRlY1BhcnQ7XHJcbiAgICAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHNjb3BlLmRhdGFbc2NvcGUuY29tcG9uZW50LmtleV0gPSByZXM7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9KTtcclxuICBhcHAuY29uZmlnKFtcclxuICAgICdmb3JtaW9Db21wb25lbnRzUHJvdmlkZXInLFxyXG4gICAgZnVuY3Rpb24oZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyKSB7XHJcbiAgICAgIGZvcm1pb0NvbXBvbmVudHNQcm92aWRlci5yZWdpc3RlcignY3VycmVuY3knLCB7XHJcbiAgICAgICAgdGl0bGU6ICdDdXJyZW5jeScsXHJcbiAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9jdXJyZW5jeS5odG1sJyxcclxuICAgICAgICBncm91cDogJ2FkdmFuY2VkJyxcclxuICAgICAgICBzZXR0aW5nczoge1xyXG4gICAgICAgICAgaW5wdXQ6IHRydWUsXHJcbiAgICAgICAgICB0YWJsZVZpZXc6IHRydWUsXHJcbiAgICAgICAgICBpbnB1dFR5cGU6ICd0ZXh0JyxcclxuICAgICAgICAgIGlucHV0TWFzazogJycsXHJcbiAgICAgICAgICBsYWJlbDogJycsXHJcbiAgICAgICAgICBrZXk6ICdjdXJyZW5jeUZpZWxkJyxcclxuICAgICAgICAgIHBsYWNlaG9sZGVyOiAnJyxcclxuICAgICAgICAgIHByZWZpeDogJycsXHJcbiAgICAgICAgICBzdWZmaXg6ICcnLFxyXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiAnJyxcclxuICAgICAgICAgIHByb3RlY3RlZDogZmFsc2UsXHJcbiAgICAgICAgICBwZXJzaXN0ZW50OiB0cnVlLFxyXG4gICAgICAgICAgaGlkZGVuOiBmYWxzZSxcclxuICAgICAgICAgIGNsZWFyT25IaWRlOiB0cnVlLFxyXG4gICAgICAgICAgdmFsaWRhdGU6IHtcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBtdWx0aXBsZTogJycsXHJcbiAgICAgICAgICAgIGN1c3RvbTogJydcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBjb25kaXRpb25hbDoge1xyXG4gICAgICAgICAgICBzaG93OiBudWxsLFxyXG4gICAgICAgICAgICB3aGVuOiBudWxsLFxyXG4gICAgICAgICAgICBlcTogJydcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIF0pO1xyXG5cclxuICBhcHAucnVuKFtcclxuICAgICckdGVtcGxhdGVDYWNoZScsXHJcbiAgICAnRm9ybWlvVXRpbHMnLFxyXG4gICAgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUsIEZvcm1pb1V0aWxzKSB7XHJcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvY3VycmVuY3kuaHRtbCcsIEZvcm1pb1V0aWxzLmZpZWxkV3JhcChcclxuICAgICAgICBcIjxpbnB1dFxcclxcbiAgdHlwZT1cXFwie3sgY29tcG9uZW50LmlucHV0VHlwZSB9fVxcXCJcXHJcXG4gIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiXFxyXFxuICBpZD1cXFwie3sgY29tcG9uZW50SWQgfX1cXFwiXFxyXFxuICBuYW1lPVxcXCJ7eyBjb21wb25lbnRJZCB9fVxcXCJcXHJcXG4gIHRhYmluZGV4PVxcXCJ7eyBjb21wb25lbnQudGFiaW5kZXggfHwgMCB9fVxcXCJcXHJcXG4gIG5nLW1vZGVsPVxcXCJkYXRhW2NvbXBvbmVudC5rZXldXFxcIlxcclxcbiAgbmctcmVxdWlyZWQ9XFxcImlzUmVxdWlyZWQoY29tcG9uZW50KVxcXCJcXHJcXG4gIG5nLWRpc2FibGVkPVxcXCJyZWFkT25seVxcXCJcXHJcXG4gIHNhZmUtbXVsdGlwbGUtdG8tc2luZ2xlXFxyXFxuICBuZy1hdHRyLXBsYWNlaG9sZGVyPVxcXCJ7eyBjb21wb25lbnQucGxhY2Vob2xkZXIgfX1cXFwiXFxyXFxuICBjdXN0b20tdmFsaWRhdG9yPVxcXCJjb21wb25lbnQudmFsaWRhdGUuY3VzdG9tXFxcIlxcclxcbiAgY3VycmVuY3ktaW5wdXRcXHJcXG4gIHVpLW1hc2stcGxhY2Vob2xkZXI9XFxcIlxcXCJcXHJcXG4gIHVpLW9wdGlvbnM9XFxcInVpTWFza09wdGlvbnNcXFwiXFxyXFxuPlxcclxcblwiXHJcbiAgICAgICkpO1xyXG4gICAgfVxyXG4gIF0pO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcblxyXG52YXIgR3JpZFV0aWxzID0gcmVxdWlyZSgnLi4vZmFjdG9yaWVzL0dyaWRVdGlscycpKCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFwcCkge1xyXG4gIGFwcC5jb25maWcoW1xyXG4gICAgJ2Zvcm1pb0NvbXBvbmVudHNQcm92aWRlcicsXHJcbiAgICBmdW5jdGlvbihmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIpIHtcclxuICAgICAgZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyLnJlZ2lzdGVyKCdjdXN0b20nLCB7XHJcbiAgICAgICAgdGl0bGU6ICdDdXN0b20nLFxyXG4gICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvY3VzdG9tLmh0bWwnLFxyXG4gICAgICAgIGdyb3VwOiAnYWR2YW5jZWQnLFxyXG4gICAgICAgIHNldHRpbmdzOiB7fSxcclxuICAgICAgICB0YWJsZVZpZXc6IEdyaWRVdGlscy5nZW5lcmljXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIF0pO1xyXG4gIGFwcC5ydW4oW1xyXG4gICAgJyR0ZW1wbGF0ZUNhY2hlJyxcclxuICAgIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvY3VzdG9tLmh0bWwnLFxyXG4gICAgICAgIFwiPGRpdiBjbGFzcz1cXFwicGFuZWwgcGFuZWwtZGVmYXVsdFxcXCI+XFxyXFxuICA8ZGl2IGNsYXNzPVxcXCJwYW5lbC1ib2R5IHRleHQtbXV0ZWQgdGV4dC1jZW50ZXJcXFwiPlxcclxcbiAgICBDdXN0b20gQ29tcG9uZW50ICh7eyBjb21wb25lbnQudHlwZSB9fSlcXHJcXG4gIDwvZGl2PlxcclxcbjwvZGl2PlxcclxcblwiXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgXSk7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xuXHJcbnZhciBmb3JtaW9VdGlscyA9IHJlcXVpcmUoJ2Zvcm1pb2pzL3V0aWxzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFwcCkge1xyXG4gIGFwcC5jb25maWcoW1xyXG4gICAgJ2Zvcm1pb0NvbXBvbmVudHNQcm92aWRlcicsXHJcbiAgICBmdW5jdGlvbihmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIpIHtcclxuICAgICAgZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyLnJlZ2lzdGVyKCdkYXRhZ3JpZCcsIHtcclxuICAgICAgICB0aXRsZTogJ0RhdGEgR3JpZCcsXHJcbiAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9kYXRhZ3JpZC5odG1sJyxcclxuICAgICAgICBncm91cDogJ2FkdmFuY2VkJyxcclxuICAgICAgICB0YWJsZVZpZXc6IGZ1bmN0aW9uKGRhdGEsIGNvbXBvbmVudCwgJGludGVycG9sYXRlLCBjb21wb25lbnRJbmZvLCB0YWJsZUNoaWxkKSB7XHJcbiAgICAgICAgICB2YXIgdmlldyA9ICc8dGFibGUgY2xhc3M9XCJ0YWJsZSB0YWJsZS1zdHJpcGVkIHRhYmxlLWJvcmRlcmVkIHRhYmxlLWNoaWxkXCI+JztcclxuXHJcbiAgICAgICAgICBpZiAoIXRhYmxlQ2hpbGQpIHtcclxuICAgICAgICAgICAgdmlldyArPSAnPHRoZWFkPjx0cj4nO1xyXG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goY29tcG9uZW50LmNvbXBvbmVudHMsIGZ1bmN0aW9uKGNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgIHZpZXcgKz0gJzx0aD4nICsgKGNvbXBvbmVudC5sYWJlbCB8fCAnJykgKyAnICgnICsgY29tcG9uZW50LmtleSArICcpPC90aD4nO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmlldyArPSAnPC90cj48L3RoZWFkPic7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdmlldyArPSAnPHRib2R5Pic7XHJcbiAgICAgICAgICBhbmd1bGFyLmZvckVhY2goZGF0YSwgZnVuY3Rpb24ocm93KSB7XHJcbiAgICAgICAgICAgIHZpZXcgKz0gJzx0cj4nO1xyXG4gICAgICAgICAgICBmb3JtaW9VdGlscy5lYWNoQ29tcG9uZW50KGNvbXBvbmVudC5jb21wb25lbnRzLCBmdW5jdGlvbihjb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAvLyBEb24ndCByZW5kZXIgZGlzYWJsZWQgZmllbGRzLCBvciBmaWVsZHMgd2l0aCB1bmRlZmluZWQgZGF0YS5cclxuICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudC50YWJsZVZpZXcgfHwgcm93W2NvbXBvbmVudC5rZXldID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIC8vIElmIHRoZSBjb21wb25lbnQgaGFzIGEgZGVmaW5lZCB0YWJsZVZpZXcsIHVzZSB0aGF0LCBvdGhlcndpc2UgdHJ5IGFuZCB1c2UgdGhlIHJhdyBkYXRhIGFzIGEgc3RyaW5nLlxyXG4gICAgICAgICAgICAgIHZhciBpbmZvID0gY29tcG9uZW50SW5mby5jb21wb25lbnRzLmhhc093blByb3BlcnR5KGNvbXBvbmVudC50eXBlKSA/IGNvbXBvbmVudEluZm8uY29tcG9uZW50c1tjb21wb25lbnQudHlwZV0gOiB7fTtcclxuICAgICAgICAgICAgICBpZiAoaW5mby50YWJsZVZpZXcpIHtcclxuICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSB0YWJsZUNoaWxkIHZhbHVlIGZvciBkYXRhZ3JpZHMsIHNvIHRoYXQgY29tcG9uZW50cyBoYXZlIGhlYWRlcnMuXHJcbiAgICAgICAgICAgICAgICB2aWV3ICs9ICc8dGQ+JyArIGluZm8udGFibGVWaWV3KHJvd1tjb21wb25lbnQua2V5XSB8fCAnJywgY29tcG9uZW50LCAkaW50ZXJwb2xhdGUsIGNvbXBvbmVudEluZm8sIGZhbHNlKSArICc8L3RkPic7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmlldyArPSAnPHRkPic7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50LnByZWZpeCkge1xyXG4gICAgICAgICAgICAgICAgICB2aWV3ICs9IGNvbXBvbmVudC5wcmVmaXg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2aWV3ICs9IHJvd1tjb21wb25lbnQua2V5XSB8fCAnJztcclxuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQuc3VmZml4KSB7XHJcbiAgICAgICAgICAgICAgICAgIHZpZXcgKz0gJyAnICsgY29tcG9uZW50LnN1ZmZpeDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZpZXcgKz0gJzwvdGQ+JztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2aWV3ICs9ICc8L3RyPic7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHZpZXcgKz0gJzwvdGJvZHk+PC90YWJsZT4nO1xyXG4gICAgICAgICAgcmV0dXJuIHZpZXc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXR0aW5nczoge1xyXG4gICAgICAgICAgaW5wdXQ6IHRydWUsXHJcbiAgICAgICAgICB0cmVlOiB0cnVlLFxyXG4gICAgICAgICAgY29tcG9uZW50czogW10sXHJcbiAgICAgICAgICB0YWJsZVZpZXc6IHRydWUsXHJcbiAgICAgICAgICBsYWJlbDogJycsXHJcbiAgICAgICAgICBrZXk6ICdkYXRhZ3JpZCcsXHJcbiAgICAgICAgICBwcm90ZWN0ZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgcGVyc2lzdGVudDogdHJ1ZSxcclxuICAgICAgICAgIGhpZGRlbjogZmFsc2UsXHJcbiAgICAgICAgICBjbGVhck9uSGlkZTogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgXSk7XHJcbiAgYXBwLmNvbnRyb2xsZXIoJ2Zvcm1pb0RhdGFHcmlkJywgW1xyXG4gICAgJyRzY29wZScsXHJcbiAgICAnRm9ybWlvVXRpbHMnLFxyXG4gICAgZnVuY3Rpb24oJHNjb3BlLCBGb3JtaW9VdGlscykge1xyXG4gICAgICBpZiAoJHNjb3BlLmJ1aWxkZXIpIHJldHVybjtcclxuICAgICAgLy8gRW5zdXJlIGVhY2ggZGF0YSBncmlkIGhhcyBhIHZhbGlkIGRhdGEgbW9kZWwuXHJcbiAgICAgICRzY29wZS5kYXRhID0gJHNjb3BlLmRhdGEgfHwge307XHJcbiAgICAgICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSA9ICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSB8fCBbe31dO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIGlmIGFueSBjb21wb25lbnQgaXMgdmlzaWJsZS5cclxuICAgICAgJHNjb3BlLmFueVZpc2libGUgPSBmdW5jdGlvbihjb21wb25lbnQpIHtcclxuICAgICAgICB2YXIgZGF0YSA9ICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XTtcclxuICAgICAgICB2YXIgdmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChkYXRhLCBmdW5jdGlvbihyb3dEYXRhKSB7XHJcbiAgICAgICAgICB2aXNpYmxlID0gKHZpc2libGUgfHwgRm9ybWlvVXRpbHMuaXNWaXNpYmxlKGNvbXBvbmVudCwgcm93RGF0YSwgJHNjb3BlLmRhdGEsICRzY29wZS5oaWRlQ29tcG9uZW50cykpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB2aXNpYmxlO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gUHVsbCBvdXQgdGhlIHJvd3MgYW5kIGNvbHMgZm9yIGVhc3kgaXRlcmF0aW9uLlxyXG4gICAgICAkc2NvcGUucm93cyA9ICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XTtcclxuICAgICAgLy8gSWYgbGVzcyB0aGFuIG1pbkxlbmd0aCwgYWRkIHRoYXQgbWFueSByb3dzLlxyXG4gICAgICBpZiAoJHNjb3BlLmNvbXBvbmVudC52YWxpZGF0ZSAmJiAkc2NvcGUuY29tcG9uZW50LnZhbGlkYXRlLmhhc093blByb3BlcnR5KCdtaW5MZW5ndGgnKSAmJiAkc2NvcGUucm93cy5sZW5ndGggPCAkc2NvcGUuY29tcG9uZW50LnZhbGlkYXRlLm1pbkxlbmd0aCkge1xyXG4gICAgICAgIHZhciB0b0FkZCA9ICRzY29wZS5jb21wb25lbnQudmFsaWRhdGUubWluTGVuZ3RoIC0gJHNjb3BlLnJvd3MubGVuZ3RoO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9BZGQ7IGkrKykge1xyXG4gICAgICAgICAgJHNjb3BlLnJvd3MucHVzaCh7fSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIC8vIElmIG1vcmUgdGhhbiBtYXhMZW5ndGgsIHJlbW92ZSBleHRyYSByb3dzLlxyXG4gICAgICBpZiAoJHNjb3BlLmNvbXBvbmVudC52YWxpZGF0ZSAmJiAkc2NvcGUuY29tcG9uZW50LnZhbGlkYXRlLmhhc093blByb3BlcnR5KCdtYXhMZW5ndGgnKSAmJiAkc2NvcGUucm93cy5sZW5ndGggPCAkc2NvcGUuY29tcG9uZW50LnZhbGlkYXRlLm1heExlbmd0aCkge1xyXG4gICAgICAgICRzY29wZS5yb3dzID0gJHNjb3BlLnJvd3Muc2xpY2UoMCwgJHNjb3BlLmNvbXBvbmVudC52YWxpZGF0ZS5tYXhMZW5ndGgpO1xyXG4gICAgICB9XHJcbiAgICAgICRzY29wZS5jb2xzID0gJHNjb3BlLmNvbXBvbmVudC5jb21wb25lbnRzO1xyXG4gICAgICAkc2NvcGUubG9jYWxLZXlzID0gJHNjb3BlLmNvbXBvbmVudC5jb21wb25lbnRzLm1hcChmdW5jdGlvbihjb21wb25lbnQpIHtcclxuICAgICAgICByZXR1cm4gY29tcG9uZW50LmtleTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBBZGQgYSByb3cgdGhlIHRvIGdyaWQuXHJcbiAgICAgICRzY29wZS5hZGRSb3cgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoJHNjb3BlLnJvd3MpKSB7XHJcbiAgICAgICAgICAkc2NvcGUucm93cyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAkc2NvcGUucm93cy5wdXNoKHt9KTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIFJlbW92ZSBhIHJvdyBmcm9tIHRoZSBncmlkLlxyXG4gICAgICAkc2NvcGUucmVtb3ZlUm93ID0gZnVuY3Rpb24oaW5kZXgpIHtcclxuICAgICAgICAkc2NvcGUucm93cy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIF0pO1xyXG4gIGFwcC5ydW4oW1xyXG4gICAgJyR0ZW1wbGF0ZUNhY2hlJyxcclxuICAgICdGb3JtaW9VdGlscycsXHJcbiAgICBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSwgRm9ybWlvVXRpbHMpIHtcclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9kYXRhZ3JpZC5odG1sJywgRm9ybWlvVXRpbHMuZmllbGRXcmFwKFxyXG4gICAgICAgIFwiPGRpdiBjbGFzcz1cXFwiZm9ybWlvLWRhdGEtZ3JpZFxcXCIgbmctY29udHJvbGxlcj1cXFwiZm9ybWlvRGF0YUdyaWRcXFwiPlxcclxcbiAgPHRhYmxlIG5nLWNsYXNzPVxcXCJ7J3RhYmxlLXN0cmlwZWQnOiBjb21wb25lbnQuc3RyaXBlZCwgJ3RhYmxlLWJvcmRlcmVkJzogY29tcG9uZW50LmJvcmRlcmVkLCAndGFibGUtaG92ZXInOiBjb21wb25lbnQuaG92ZXIsICd0YWJsZS1jb25kZW5zZWQnOiBjb21wb25lbnQuY29uZGVuc2VkfVxcXCIgY2xhc3M9XFxcInRhYmxlIGRhdGFncmlkLXRhYmxlXFxcIj5cXHJcXG4gICAgPHRyPlxcclxcbiAgICAgIDx0aFxcclxcbiAgICAgICAgbmctcmVwZWF0PVxcXCJjb2wgaW4gY29scyB0cmFjayBieSAkaW5kZXhcXFwiXFxyXFxuICAgICAgICBuZy1jbGFzcz1cXFwieydmaWVsZC1yZXF1aXJlZCc6IGNvbC52YWxpZGF0ZS5yZXF1aXJlZH1cXFwiXFxyXFxuICAgICAgICBuZy1pZj1cXFwiYnVpbGRlciA/ICc6OnRydWUnIDogYW55VmlzaWJsZShjb2wpXFxcIlxcclxcbiAgICAgID57eyBjb2wubGFiZWwgfCBmb3JtaW9UcmFuc2xhdGU6bnVsbDpidWlsZGVyIH19PC90aD5cXHJcXG4gICAgPC90cj5cXHJcXG4gICAgPHRyIG5nLXJlcGVhdD1cXFwicm93IGluIHJvd3MgdHJhY2sgYnkgJGluZGV4XFxcIiBuZy1pbml0PVxcXCJyb3dJbmRleCA9ICRpbmRleFxcXCI+XFxyXFxuICAgICAgPHRkIG5nLXJlcGVhdD1cXFwiY29sIGluIGNvbHMgdHJhY2sgYnkgJGluZGV4XFxcIiBuZy1pbml0PVxcXCJjb2wuaGlkZUxhYmVsID0gdHJ1ZTsgY29sSW5kZXggPSAkaW5kZXhcXFwiIGNsYXNzPVxcXCJmb3JtaW8tZGF0YS1ncmlkLXJvd1xcXCIgbmctaWY9XFxcImJ1aWxkZXIgPyAnOjp0cnVlJyA6IGFueVZpc2libGUoY29sKVxcXCI+XFxyXFxuICAgICAgICA8Zm9ybWlvLWNvbXBvbmVudFxcclxcbiAgICAgICAgICBjb21wb25lbnQ9XFxcImNvbFxcXCJcXHJcXG4gICAgICAgICAgZGF0YT1cXFwicm93c1tyb3dJbmRleF1cXFwiXFxyXFxuICAgICAgICAgIGZvcm1pby1mb3JtPVxcXCJmb3JtaW9Gb3JtXFxcIlxcclxcbiAgICAgICAgICBmb3JtaW89XFxcImZvcm1pb1xcXCJcXHJcXG4gICAgICAgICAgc3VibWlzc2lvbj1cXFwic3VibWlzc2lvblxcXCJcXHJcXG4gICAgICAgICAgaGlkZS1jb21wb25lbnRzPVxcXCJoaWRlQ29tcG9uZW50c1xcXCJcXHJcXG4gICAgICAgICAgbmctaWY9XFxcImJ1aWxkZXIgPyAnOjp0cnVlJyA6IGlzVmlzaWJsZShjb2wsIHJvdylcXFwiXFxyXFxuICAgICAgICAgIHJlYWQtb25seT1cXFwiaXNEaXNhYmxlZChjb2wsIHJvdylcXFwiXFxyXFxuICAgICAgICAgIGdyaWQtcm93PVxcXCJyb3dJbmRleFxcXCJcXHJcXG4gICAgICAgICAgZ3JpZC1jb2w9XFxcImNvbEluZGV4XFxcIlxcclxcbiAgICAgICAgICBidWlsZGVyPVxcXCJidWlsZGVyXFxcIlxcclxcbiAgICAgICAgPjwvZm9ybWlvLWNvbXBvbmVudD5cXHJcXG4gICAgICA8L3RkPlxcclxcbiAgICAgIDx0ZCBuZy1pZj1cXFwiIWNvbXBvbmVudC5oYXNPd25Qcm9wZXJ0eSgndmFsaWRhdGUnKSB8fCAhY29tcG9uZW50LnZhbGlkYXRlLmhhc093blByb3BlcnR5KCdtaW5MZW5ndGgnKSB8fCByb3dzLmxlbmd0aCA+IGNvbXBvbmVudC52YWxpZGF0ZS5taW5MZW5ndGhcXFwiPlxcclxcbiAgICAgICAgPGEgbmctY2xpY2s9XFxcInJlbW92ZVJvdyhyb3dJbmRleClcXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHRcXFwiPlxcclxcbiAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1yZW1vdmUtY2lyY2xlXFxcIj48L3NwYW4+XFxyXFxuICAgICAgICA8L2E+XFxyXFxuICAgICAgPC90ZD5cXHJcXG4gICAgPC90cj5cXHJcXG4gIDwvdGFibGU+XFxyXFxuICA8ZGl2IGNsYXNzPVxcXCJkYXRhZ3JpZC1hZGRcXFwiIG5nLWlmPVxcXCIhY29tcG9uZW50Lmhhc093blByb3BlcnR5KCd2YWxpZGF0ZScpIHx8ICFjb21wb25lbnQudmFsaWRhdGUuaGFzT3duUHJvcGVydHkoJ21heExlbmd0aCcpIHx8IHJvd3MubGVuZ3RoIDwgY29tcG9uZW50LnZhbGlkYXRlLm1heExlbmd0aFxcXCI+XFxyXFxuICAgIDxhIG5nLWNsaWNrPVxcXCJhZGRSb3coKVxcXCIgY2xhc3M9XFxcImJ0biBidG4tcHJpbWFyeVxcXCI+XFxyXFxuICAgICAgPHNwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tcGx1c1xcXCIgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiPjwvc3Bhbj4ge3sgY29tcG9uZW50LmFkZEFub3RoZXIgfHwgXFxcIkFkZCBBbm90aGVyXFxcIiB8IGZvcm1pb1RyYW5zbGF0ZTpudWxsOmJ1aWxkZXIgfX1cXHJcXG4gICAgPC9hPlxcclxcbiAgPC9kaXY+XFxyXFxuPC9kaXY+XFxyXFxuXCJcclxuICAgICAgKSk7XHJcbiAgICB9XHJcbiAgXSk7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBwKSB7XHJcbiAgYXBwLmNvbmZpZyhbXHJcbiAgICAnZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyJyxcclxuICAgIGZ1bmN0aW9uKGZvcm1pb0NvbXBvbmVudHNQcm92aWRlcikge1xyXG4gICAgICBmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIucmVnaXN0ZXIoJ2RhdGV0aW1lJywge1xyXG4gICAgICAgIHRpdGxlOiAnRGF0ZSAvIFRpbWUnLFxyXG4gICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvZGF0ZXRpbWUuaHRtbCcsXHJcbiAgICAgICAgdGFibGVWaWV3OiBmdW5jdGlvbihkYXRhLCBjb21wb25lbnQsICRpbnRlcnBvbGF0ZSkge1xyXG4gICAgICAgICAgcmV0dXJuICRpbnRlcnBvbGF0ZSgnPHNwYW4+e3sgXCInICsgZGF0YSArICdcIiB8IGRhdGU6IFwiJyArIGNvbXBvbmVudC5mb3JtYXQgKyAnXCIgfX08L3NwYW4+JykoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdyb3VwOiAnYWR2YW5jZWQnLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IFsnJHNjb3BlJywgJyR0aW1lb3V0JywgZnVuY3Rpb24oJHNjb3BlLCAkdGltZW91dCkge1xyXG4gICAgICAgICAgLy8gQ2xvc2UgY2FsZW5kYXIgcG9wIHVwIHdoZW4gdGFiYmluZyBvZmYgYnV0dG9uXHJcbiAgICAgICAgICAkc2NvcGUub25LZXlEb3duID0gZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGUgPT09IDkgPyBmYWxzZSA6ICRzY29wZS5jYWxlbmRhck9wZW47XHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIHZhciBkYXRlVmFsdWUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgLy8gSWYgdGhlIGRhdGUgaXMgc2V0LCB0aGVuIHJldHVybiB0aGUgdHJ1ZSBkYXRlIHZhbHVlLlxyXG4gICAgICAgICAgICBpZiAoJHNjb3BlLmRhdGFbJHNjb3BlLmNvbXBvbmVudC5rZXldKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuICgkc2NvcGUuZGF0YVskc2NvcGUuY29tcG9uZW50LmtleV0gaW5zdGFuY2VvZiBEYXRlKSA/ICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSA6IG5ldyBEYXRlKCRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNlZSBpZiBhIGRlZmF1bHQgZGF0ZSBpcyBzZXQuXHJcbiAgICAgICAgICAgIGlmICgkc2NvcGUuY29tcG9uZW50LmRlZmF1bHREYXRlKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGRlZmF1bHREYXRlID0gbmV3IERhdGUoJHNjb3BlLmNvbXBvbmVudC5kZWZhdWx0RGF0ZSk7XHJcbiAgICAgICAgICAgICAgaWYgKCFkZWZhdWx0RGF0ZSB8fCBpc05hTihkZWZhdWx0RGF0ZS5nZXREYXRlKCkpKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICBkZWZhdWx0RGF0ZSA9IG5ldyBEYXRlKGV2YWwoJHNjb3BlLmNvbXBvbmVudC5kZWZhdWx0RGF0ZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgZGVmYXVsdERhdGUgPSAnJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGlmIChkZWZhdWx0RGF0ZSAmJiAhaXNOYU4oZGVmYXVsdERhdGUuZ2V0RGF0ZSgpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRGVmYXVsdCB0byBlbXB0eS5cclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAvLyBFbnN1cmUgdGhlIGRhdGUgdmFsdWUgaXMgYWx3YXlzIGEgZGF0ZSBvYmplY3Qgd2hlbiBsb2FkZWQsIHRoZW4gdW5iaW5kIHRoZSB3YXRjaC5cclxuICAgICAgICAgICRzY29wZS4kd2F0Y2goJ2RhdGEuJyArICRzY29wZS5jb21wb25lbnQua2V5LCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gZGF0ZVZhbHVlKCk7XHJcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAvLyBXYXRjaCBmb3IgY2hhbmdlcyB0byB0aGUgbWVyaWRpYW4gc2V0dGluZ3MgdG8gc3luY2hyb25pemUgdGhlIHN1Ym1pc3Npb25HcmlkIGFuZCBjb21wb25lbnQgdmlldy5cclxuICAgICAgICAgICRzY29wZS4kd2F0Y2goJ2NvbXBvbmVudC50aW1lUGlja2VyLnNob3dNZXJpZGlhbicsIGZ1bmN0aW9uKHVwZGF0ZSkge1xyXG4gICAgICAgICAgICAvLyBSZW1vdmUgYW55IG1lcmlkaWFuIHJlZmVyZW5jZSwgYmVjYXVzZSB3ZXJlIG5vdCBpbiAxMiBoci5cclxuICAgICAgICAgICAgaWYgKCEkc2NvcGUuY29tcG9uZW50LmVuYWJsZVRpbWUgfHwgIXVwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICRzY29wZS5jb21wb25lbnQuZm9ybWF0ID0gJHNjb3BlLmNvbXBvbmVudC5mb3JtYXQucmVwbGFjZSgvIGEvLCAnJyk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBtaXNzaW5nIHRoZSBtZXJpZGlhbiBzdHJpbmcgYW5kIHdlcmUgaW4gMTIgaHIsIGFkZCBpdC5cclxuICAgICAgICAgICAgaWYgKHVwZGF0ZSAmJiAkc2NvcGUuY29tcG9uZW50LmZvcm1hdC5pbmRleE9mKCcgYScpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICRzY29wZS5jb21wb25lbnQuZm9ybWF0ICs9ICcgYSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGlmICghJHNjb3BlLmNvbXBvbmVudC5kYXRlUGlja2VyLm1heERhdGUpIHtcclxuICAgICAgICAgICAgZGVsZXRlICRzY29wZS5jb21wb25lbnQuZGF0ZVBpY2tlci5tYXhEYXRlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBtYXhEYXRlID0gbmV3IERhdGUoJHNjb3BlLmNvbXBvbmVudC5kYXRlUGlja2VyLm1heERhdGUpO1xyXG4gICAgICAgICAgICAkc2NvcGUuY29tcG9uZW50LmRhdGVQaWNrZXIubWF4RGF0ZSA9IG5ldyBEYXRlKFxyXG4gICAgICAgICAgICAgIG1heERhdGUuZ2V0VVRDRnVsbFllYXIoKSxcclxuICAgICAgICAgICAgICBtYXhEYXRlLmdldFVUQ01vbnRoKCksXHJcbiAgICAgICAgICAgICAgbWF4RGF0ZS5nZXRVVENEYXRlKCksXHJcbiAgICAgICAgICAgICAgMjMsXHJcbiAgICAgICAgICAgICAgNTksXHJcbiAgICAgICAgICAgICAgNTksXHJcbiAgICAgICAgICAgICAgOTk5XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKCEkc2NvcGUuY29tcG9uZW50LmRhdGVQaWNrZXIubWluRGF0ZSkge1xyXG4gICAgICAgICAgICBkZWxldGUgJHNjb3BlLmNvbXBvbmVudC5kYXRlUGlja2VyLm1pbkRhdGU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIG1pbkRhdGUgPSBuZXcgRGF0ZSgkc2NvcGUuY29tcG9uZW50LmRhdGVQaWNrZXIubWluRGF0ZSk7XHJcbiAgICAgICAgICAgICRzY29wZS5jb21wb25lbnQuZGF0ZVBpY2tlci5taW5EYXRlID0gbmV3IERhdGUoXHJcbiAgICAgICAgICAgICAgbWluRGF0ZS5nZXRVVENGdWxsWWVhcigpLFxyXG4gICAgICAgICAgICAgIG1pbkRhdGUuZ2V0VVRDTW9udGgoKSxcclxuICAgICAgICAgICAgICBtaW5EYXRlLmdldFVUQ0RhdGUoKSxcclxuICAgICAgICAgICAgICAwLFxyXG4gICAgICAgICAgICAgIDAsXHJcbiAgICAgICAgICAgICAgMCxcclxuICAgICAgICAgICAgICAwXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgJHNjb3BlLmF1dG9PcGVuID0gdHJ1ZTtcclxuICAgICAgICAgICRzY29wZS5vbkNsb3NlZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAkc2NvcGUuYXV0b09wZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgJHNjb3BlLmF1dG9PcGVuID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSwgMjUwKTtcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfV0sXHJcbiAgICAgICAgc2V0dGluZ3M6IHtcclxuICAgICAgICAgIGlucHV0OiB0cnVlLFxyXG4gICAgICAgICAgdGFibGVWaWV3OiB0cnVlLFxyXG4gICAgICAgICAgbGFiZWw6ICcnLFxyXG4gICAgICAgICAga2V5OiAnZGF0ZXRpbWVGaWVsZCcsXHJcbiAgICAgICAgICBwbGFjZWhvbGRlcjogJycsXHJcbiAgICAgICAgICBmb3JtYXQ6ICd5eXl5LU1NLWRkIEhIOm1tIGEnLFxyXG4gICAgICAgICAgZW5hYmxlRGF0ZTogdHJ1ZSxcclxuICAgICAgICAgIGVuYWJsZVRpbWU6IHRydWUsXHJcbiAgICAgICAgICBkZWZhdWx0RGF0ZTogJycsXHJcbiAgICAgICAgICBkYXRlcGlja2VyTW9kZTogJ2RheScsXHJcbiAgICAgICAgICBkYXRlUGlja2VyOiB7XHJcbiAgICAgICAgICAgIHNob3dXZWVrczogdHJ1ZSxcclxuICAgICAgICAgICAgc3RhcnRpbmdEYXk6IDAsXHJcbiAgICAgICAgICAgIGluaXREYXRlOiAnJyxcclxuICAgICAgICAgICAgbWluTW9kZTogJ2RheScsXHJcbiAgICAgICAgICAgIG1heE1vZGU6ICd5ZWFyJyxcclxuICAgICAgICAgICAgeWVhclJvd3M6IDQsXHJcbiAgICAgICAgICAgIHllYXJDb2x1bW5zOiA1LFxyXG4gICAgICAgICAgICBtaW5EYXRlOiBudWxsLFxyXG4gICAgICAgICAgICBtYXhEYXRlOiBudWxsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgdGltZVBpY2tlcjoge1xyXG4gICAgICAgICAgICBob3VyU3RlcDogMSxcclxuICAgICAgICAgICAgbWludXRlU3RlcDogMSxcclxuICAgICAgICAgICAgc2hvd01lcmlkaWFuOiB0cnVlLFxyXG4gICAgICAgICAgICByZWFkb25seUlucHV0OiBmYWxzZSxcclxuICAgICAgICAgICAgbW91c2V3aGVlbDogdHJ1ZSxcclxuICAgICAgICAgICAgYXJyb3drZXlzOiB0cnVlXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgcHJvdGVjdGVkOiBmYWxzZSxcclxuICAgICAgICAgIHBlcnNpc3RlbnQ6IHRydWUsXHJcbiAgICAgICAgICBoaWRkZW46IGZhbHNlLFxyXG4gICAgICAgICAgY2xlYXJPbkhpZGU6IHRydWUsXHJcbiAgICAgICAgICB2YWxpZGF0ZToge1xyXG4gICAgICAgICAgICByZXF1aXJlZDogZmFsc2UsXHJcbiAgICAgICAgICAgIGN1c3RvbTogJydcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIF0pO1xyXG4gIGFwcC5ydW4oW1xyXG4gICAgJyR0ZW1wbGF0ZUNhY2hlJyxcclxuICAgICdGb3JtaW9VdGlscycsXHJcbiAgICBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSwgRm9ybWlvVXRpbHMpIHtcclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9kYXRldGltZS5odG1sJywgRm9ybWlvVXRpbHMuZmllbGRXcmFwKFxyXG4gICAgICAgIFwiPGRpdiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXBcXFwiPlxcclxcbiAgPGlucHV0XFxyXFxuICAgIHR5cGU9XFxcInRleHRcXFwiXFxyXFxuICAgIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiXFxyXFxuICAgIG5hbWU9XFxcInt7IGNvbXBvbmVudElkIH19XFxcIlxcclxcbiAgICBpZD1cXFwie3sgY29tcG9uZW50SWQgfX1cXFwiXFxyXFxuICAgIG5nLWZvY3VzPVxcXCJjYWxlbmRhck9wZW4gPSBhdXRvT3BlblxcXCJcXHJcXG4gICAgbmctY2xpY2s9XFxcImNhbGVuZGFyT3BlbiA9IHRydWVcXFwiXFxyXFxuICAgIG5nLWluaXQ9XFxcImNhbGVuZGFyT3BlbiA9IGZhbHNlXFxcIlxcclxcbiAgICBuZy1kaXNhYmxlZD1cXFwicmVhZE9ubHlcXFwiXFxyXFxuICAgIG5nLXJlcXVpcmVkPVxcXCJpc1JlcXVpcmVkKGNvbXBvbmVudClcXFwiXFxyXFxuICAgIGlzLW9wZW49XFxcImNhbGVuZGFyT3BlblxcXCJcXHJcXG4gICAgZGF0ZXRpbWUtcGlja2VyPVxcXCJ7eyBjb21wb25lbnQuZm9ybWF0IH19XFxcIlxcclxcbiAgICBkYXRlcGlja2VyLW1vZGU9XFxcImNvbXBvbmVudC5kYXRlcGlja2VyTW9kZVxcXCJcXHJcXG4gICAgd2hlbi1jbG9zZWQ9XFxcIm9uQ2xvc2VkKClcXFwiXFxyXFxuICAgIGN1c3RvbS12YWxpZGF0b3I9XFxcImNvbXBvbmVudC52YWxpZGF0ZS5jdXN0b21cXFwiXFxyXFxuICAgIGVuYWJsZS1kYXRlPVxcXCJjb21wb25lbnQuZW5hYmxlRGF0ZVxcXCJcXHJcXG4gICAgZW5hYmxlLXRpbWU9XFxcImNvbXBvbmVudC5lbmFibGVUaW1lXFxcIlxcclxcbiAgICBuZy1tb2RlbD1cXFwiZGF0YVtjb21wb25lbnQua2V5XVxcXCJcXHJcXG4gICAgdGFiaW5kZXg9XFxcInt7IGNvbXBvbmVudC50YWJpbmRleCB8fCAwIH19XFxcIlxcclxcbiAgICBuZy1hdHRyLXBsYWNlaG9sZGVyPVxcXCJ7eyBjb21wb25lbnQucGxhY2Vob2xkZXIgfCBmb3JtaW9UcmFuc2xhdGU6bnVsbDpidWlsZGVyIH19XFxcIlxcclxcbiAgICBkYXRlcGlja2VyLW9wdGlvbnM9XFxcImNvbXBvbmVudC5kYXRlUGlja2VyXFxcIlxcclxcbiAgICB0aW1lcGlja2VyLW9wdGlvbnM9XFxcImNvbXBvbmVudC50aW1lUGlja2VyXFxcIlxcclxcbiAgLz5cXHJcXG4gIDxzcGFuIGNsYXNzPVxcXCJpbnB1dC1ncm91cC1idG5cXFwiPlxcclxcbiAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgbmctZGlzYWJsZWQ9XFxcInJlYWRPbmx5XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0XFxcIiBuZy1jbGljaz1cXFwiY2FsZW5kYXJPcGVuID0gdHJ1ZVxcXCIgbmcta2V5ZG93bj1cXFwiY2FsZW5kYXJPcGVuID0gb25LZXlEb3duKCRldmVudClcXFwiPlxcclxcbiAgICAgIDxpIG5nLWlmPVxcXCJjb21wb25lbnQuZW5hYmxlRGF0ZVxcXCIgY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tY2FsZW5kYXJcXFwiPjwvaT5cXHJcXG4gICAgICA8aSBuZy1pZj1cXFwiIWNvbXBvbmVudC5lbmFibGVEYXRlXFxcIiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi10aW1lXFxcIj48L2k+XFxyXFxuICAgIDwvYnV0dG9uPlxcclxcbiAgPC9zcGFuPlxcclxcbjwvZGl2PlxcclxcblwiXHJcbiAgICAgICkpO1xyXG4gICAgfVxyXG4gIF0pO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFwcCkge1xyXG4gIGFwcC5kaXJlY3RpdmUoJ2RheVBhcnQnLCBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHJlc3RyaWN0OiAnQScsXHJcbiAgICAgIHJlcGxhY2U6IHRydWUsXHJcbiAgICAgIHJlcXVpcmU6ICduZ01vZGVsJyxcclxuICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW0sIGF0dHJzLCBuZ01vZGVsKSB7XHJcbiAgICAgICAgaWYgKHNjb3BlLmJ1aWxkZXIpIHJldHVybjtcclxuICAgICAgICB2YXIgbGltaXRMZW5ndGggPSBhdHRycy5jaGFyYWN0ZXJzIHx8IDI7XHJcbiAgICAgICAgc2NvcGUuJHdhdGNoKGF0dHJzLm5nTW9kZWwsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgaWYgKCFuZ01vZGVsLiR2aWV3VmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdmFyIHJlbmRlciA9IGZhbHNlO1xyXG4gICAgICAgICAgaWYgKG5nTW9kZWwuJHZpZXdWYWx1ZS5sZW5ndGggPiBsaW1pdExlbmd0aCkge1xyXG4gICAgICAgICAgICBuZ01vZGVsLiRzZXRWaWV3VmFsdWUobmdNb2RlbC4kdmlld1ZhbHVlLnN1YnN0cmluZygwLCBsaW1pdExlbmd0aCkpO1xyXG4gICAgICAgICAgICByZW5kZXIgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGlzTmFOKG5nTW9kZWwuJHZpZXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgbmdNb2RlbC4kc2V0Vmlld1ZhbHVlKG5nTW9kZWwuJHZpZXdWYWx1ZS5yZXBsYWNlKC9cXEQvZywnJykpO1xyXG4gICAgICAgICAgICByZW5kZXIgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICBwYXJzZUludChuZ01vZGVsLiR2aWV3VmFsdWUpIDwgcGFyc2VJbnQoYXR0cnMubWluKSB8fFxyXG4gICAgICAgICAgICBwYXJzZUludChuZ01vZGVsLiR2aWV3VmFsdWUpID4gcGFyc2VJbnQoYXR0cnMubWF4KVxyXG4gICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIG5nTW9kZWwuJHNldFZpZXdWYWx1ZShuZ01vZGVsLiR2aWV3VmFsdWUuc3Vic3RyaW5nKDAsIGxpbWl0TGVuZ3RoIC0gMSkpO1xyXG4gICAgICAgICAgICByZW5kZXIgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHJlbmRlcikge1xyXG4gICAgICAgICAgICBuZ01vZGVsLiRyZW5kZXIoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9KTtcclxuICBhcHAuZGlyZWN0aXZlKCdkYXlJbnB1dCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgcmVwbGFjZTogdHJ1ZSxcclxuICAgICAgcmVxdWlyZTogJ25nTW9kZWwnLFxyXG4gICAgICBzY29wZToge1xyXG4gICAgICAgIGNvbXBvbmVudDogJz0nLFxyXG4gICAgICAgIGNvbXBvbmVudElkOiAnPScsXHJcbiAgICAgICAgcmVhZE9ubHk6ICc9JyxcclxuICAgICAgICBuZ01vZGVsOiAnPScsXHJcbiAgICAgICAgZ3JpZFJvdzogJz0nLFxyXG4gICAgICAgIGdyaWRDb2w6ICc9JyxcclxuICAgICAgICBidWlsZGVyOiAnPT8nXHJcbiAgICAgIH0sXHJcbiAgICAgIHRlbXBsYXRlVXJsOiAnZm9ybWlvL2NvbXBvbmVudHMvZGF5LWlucHV0Lmh0bWwnLFxyXG4gICAgICBjb250cm9sbGVyOiBbJyRzY29wZScsIGZ1bmN0aW9uKCRzY29wZSkge1xyXG4gICAgICAgIGlmICgkc2NvcGUuYnVpbGRlcikgcmV0dXJuO1xyXG4gICAgICAgICRzY29wZS5tb250aHMgPSBbXHJcbiAgICAgICAgICB7dmFsdWU6ICcnLCBsYWJlbDogJHNjb3BlLmNvbXBvbmVudC5maWVsZHMubW9udGgucGxhY2Vob2xkZXJ9LFxyXG4gICAgICAgICAge3ZhbHVlOiAnMDEnLCBsYWJlbDogJ0phbnVhcnknfSxcclxuICAgICAgICAgIHt2YWx1ZTogJzAyJywgbGFiZWw6ICdGZWJydWFyeSd9LFxyXG4gICAgICAgICAge3ZhbHVlOiAnMDMnLCBsYWJlbDogJ01hcmNoJ30sXHJcbiAgICAgICAgICB7dmFsdWU6ICcwNCcsIGxhYmVsOiAnQXByaWwnfSxcclxuICAgICAgICAgIHt2YWx1ZTogJzA1JywgbGFiZWw6ICdNYXknfSxcclxuICAgICAgICAgIHt2YWx1ZTogJzA2JywgbGFiZWw6ICdKdW5lJ30sXHJcbiAgICAgICAgICB7dmFsdWU6ICcwNycsIGxhYmVsOiAnSnVseSd9LFxyXG4gICAgICAgICAge3ZhbHVlOiAnMDgnLCBsYWJlbDogJ0F1Z3VzdCd9LFxyXG4gICAgICAgICAge3ZhbHVlOiAnMDknLCBsYWJlbDogJ1NlcHRlbWJlcid9LFxyXG4gICAgICAgICAge3ZhbHVlOiAnMTAnLCBsYWJlbDogJ09jdG9iZXInfSxcclxuICAgICAgICAgIHt2YWx1ZTogJzExJywgbGFiZWw6ICdOb3ZlbWJlcid9LFxyXG4gICAgICAgICAge3ZhbHVlOiAnMTInLCBsYWJlbDogJ0RlY2VtYmVyJ31cclxuICAgICAgICBdO1xyXG5cclxuICAgICAgICAkc2NvcGUuZGF0ZSA9IHtcclxuICAgICAgICAgIGRheTogJycsXHJcbiAgICAgICAgICBtb250aDogJycsXHJcbiAgICAgICAgICB5ZWFyOiAnJ1xyXG4gICAgICAgIH07XHJcbiAgICAgIH1dLFxyXG4gICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbSwgYXR0cnMsIG5nTW9kZWwpIHtcclxuICAgICAgICBpZiAoc2NvcGUuYnVpbGRlcikgcmV0dXJuO1xyXG4gICAgICAgIC8vIFNldCB0aGUgc2NvcGUgdmFsdWVzIGJhc2VkIG9uIHRoZSBjdXJyZW50IG1vZGVsLlxyXG4gICAgICAgIHNjb3BlLiR3YXRjaCgnbmdNb2RlbCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgLy8gT25seSB1cGRhdGUgb24gbG9hZC5cclxuICAgICAgICAgIGlmIChuZ01vZGVsLiR2aWV3VmFsdWUgJiYgIW5nTW9kZWwuJGRpcnR5KSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IHR5cGVvZiBuZ01vZGVsLiR2aWV3VmFsdWUgPT09ICdzdHJpbmcnXHJcbiAgICAgICAgICAgICAgPyBuZ01vZGVsLiR2aWV3VmFsdWUuc3BsaXQoJy8nKVxyXG4gICAgICAgICAgICAgIDogbmdNb2RlbC4kdmlld1ZhbHVlO1xyXG4gICAgICAgICAgICBpZiAoKHBhcnRzIGluc3RhbmNlb2YgQXJyYXkpICYmIHBhcnRzLmxlbmd0aCA9PT0gMykge1xyXG4gICAgICAgICAgICAgIHNjb3BlLmRhdGUuZGF5ID0gcGFydHNbKHNjb3BlLmNvbXBvbmVudC5kYXlGaXJzdCA/IDAgOiAxKV07XHJcbiAgICAgICAgICAgICAgc2NvcGUuZGF0ZS5tb250aCA9IHBhcnRzWyhzY29wZS5jb21wb25lbnQuZGF5Rmlyc3QgPyAxIDogMCldO1xyXG4gICAgICAgICAgICAgIHNjb3BlLmRhdGUueWVhciA9IHBhcnRzWzJdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHZhciBwYWRMZWZ0ID0gZnVuY3Rpb24gcGFkTGVmdChuciwgbiwgc3RyKSB7XHJcbiAgICAgICAgICBuciA9IG5yLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICBpZiAobnIubGVuZ3RoID4gbikge1xyXG4gICAgICAgICAgICByZXR1cm4gbnIuc3Vic3RyKDAsIG4pO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybiBBcnJheSgobiAtIG5yLmxlbmd0aCkgKyAxKS5qb2luKHN0ciB8fCAnMCcpICsgbnI7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgc2NvcGUub25DaGFuZ2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHZhciBkYXkgPSBwYWRMZWZ0KHNjb3BlLmRhdGUuZGF5LCAyKTtcclxuICAgICAgICAgIHZhciBtb250aCA9IHBhZExlZnQoc2NvcGUuZGF0ZS5tb250aCwgMik7XHJcbiAgICAgICAgICB2YXIgeWVhciA9IHBhZExlZnQoc2NvcGUuZGF0ZS55ZWFyLCA0KTtcclxuICAgICAgICAgIHZhciB2YWx1ZSA9IHNjb3BlLmNvbXBvbmVudC5kYXlGaXJzdCA/IGRheSA6IG1vbnRoO1xyXG4gICAgICAgICAgdmFsdWUgKz0gJy8nO1xyXG4gICAgICAgICAgdmFsdWUgKz0gc2NvcGUuY29tcG9uZW50LmRheUZpcnN0ID8gbW9udGggOiBkYXk7XHJcbiAgICAgICAgICB2YWx1ZSArPSAnLycgKyB5ZWFyO1xyXG4gICAgICAgICAgbmdNb2RlbC4kc2V0Vmlld1ZhbHVlKHZhbHVlKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBuZ01vZGVsLiR2YWxpZGF0b3JzLmRheSA9IGZ1bmN0aW9uKG1vZGVsVmFsdWUsIHZpZXdWYWx1ZSkge1xyXG4gICAgICAgICAgdmFyIHZhbHVlID0gbW9kZWxWYWx1ZSB8fCB2aWV3VmFsdWU7XHJcbiAgICAgICAgICB2YXIgcmVxdWlyZWQgPSBzY29wZS5jb21wb25lbnQuZmllbGRzLmRheS5yZXF1aXJlZCB8fCBzY29wZS5jb21wb25lbnQuZmllbGRzLm1vbnRoLnJlcXVpcmVkIHx8IHNjb3BlLmNvbXBvbmVudC5maWVsZHMueWVhci5yZXF1aXJlZDtcclxuXHJcbiAgICAgICAgICBpZiAoIXJlcXVpcmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCF2YWx1ZSAmJiByZXF1aXJlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB2YXIgcGFydHMgPSB2YWx1ZS5zcGxpdCgnLycpO1xyXG4gICAgICAgICAgaWYgKHNjb3BlLmNvbXBvbmVudC5maWVsZHMuZGF5LnJlcXVpcmVkKSB7XHJcbiAgICAgICAgICAgIGlmIChwYXJ0c1soc2NvcGUuY29tcG9uZW50LmRheUZpcnN0ID8gMCA6IDEpXSA9PT0gJzAwJykge1xyXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHNjb3BlLmNvbXBvbmVudC5maWVsZHMubW9udGgucmVxdWlyZWQpIHtcclxuICAgICAgICAgICAgaWYgKHBhcnRzWyhzY29wZS5jb21wb25lbnQuZGF5Rmlyc3QgPyAxIDogMCldID09PSAnMDAnKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoc2NvcGUuY29tcG9uZW50LmZpZWxkcy55ZWFyLnJlcXVpcmVkKSB7XHJcbiAgICAgICAgICAgIGlmIChwYXJ0c1syXSA9PT0gJzAwMDAnKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH0pO1xyXG4gIGFwcC5jb25maWcoW1xyXG4gICAgJ2Zvcm1pb0NvbXBvbmVudHNQcm92aWRlcicsXHJcbiAgICBmdW5jdGlvbihmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIpIHtcclxuICAgICAgZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyLnJlZ2lzdGVyKCdkYXknLCB7XHJcbiAgICAgICAgdGl0bGU6ICdEYXknLFxyXG4gICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvZGF5Lmh0bWwnLFxyXG4gICAgICAgIGdyb3VwOiAnYWR2YW5jZWQnLFxyXG4gICAgICAgIHNldHRpbmdzOiB7XHJcbiAgICAgICAgICBpbnB1dDogdHJ1ZSxcclxuICAgICAgICAgIHRhYmxlVmlldzogdHJ1ZSxcclxuICAgICAgICAgIGxhYmVsOiAnJyxcclxuICAgICAgICAgIGtleTogJ2RheUZpZWxkJyxcclxuICAgICAgICAgIGZpZWxkczoge1xyXG4gICAgICAgICAgICBkYXk6IHtcclxuICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXHJcbiAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICcnLFxyXG4gICAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBtb250aDoge1xyXG4gICAgICAgICAgICAgIHR5cGU6ICdzZWxlY3QnLFxyXG4gICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiAnJyxcclxuICAgICAgICAgICAgICByZXF1aXJlZDogZmFsc2VcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgeWVhcjoge1xyXG4gICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcclxuICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogJycsXHJcbiAgICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBkYXlGaXJzdDogZmFsc2UsXHJcbiAgICAgICAgICBwcm90ZWN0ZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgcGVyc2lzdGVudDogdHJ1ZSxcclxuICAgICAgICAgIGhpZGRlbjogZmFsc2UsXHJcbiAgICAgICAgICBjbGVhck9uSGlkZTogdHJ1ZSxcclxuICAgICAgICAgIHZhbGlkYXRlOiB7XHJcbiAgICAgICAgICAgIGN1c3RvbTogJydcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIF0pO1xyXG4gIGFwcC5ydW4oW1xyXG4gICAgJyR0ZW1wbGF0ZUNhY2hlJyxcclxuICAgICdGb3JtaW9VdGlscycsXHJcbiAgICBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSwgRm9ybWlvVXRpbHMpIHtcclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9kYXkuaHRtbCcsIEZvcm1pb1V0aWxzLmZpZWxkV3JhcChcclxuICAgICAgICBcIjxkaXYgY2xhc3M9XFxcImRheS1pbnB1dFxcXCI+XFxyXFxuICA8ZGF5LWlucHV0XFxyXFxuICAgIG5hbWU9XFxcInt7Y29tcG9uZW50SWR9fVxcXCJcXHJcXG4gICAgY29tcG9uZW50LWlkPVxcXCJjb21wb25lbnRJZFxcXCJcXHJcXG4gICAgcmVhZC1vbmx5PVxcXCJpc0Rpc2FibGVkKGNvbXBvbmVudCwgZGF0YSlcXFwiXFxyXFxuICAgIGNvbXBvbmVudD1cXFwiY29tcG9uZW50XFxcIlxcclxcbiAgICBuZy1yZXF1aXJlZD1cXFwiaXNSZXF1aXJlZChjb21wb25lbnQpXFxcIlxcclxcbiAgICBjdXN0b20tdmFsaWRhdG9yPVxcXCJjb21wb25lbnQudmFsaWRhdGUuY3VzdG9tXFxcIlxcclxcbiAgICBuZy1tb2RlbD1cXFwiZGF0YVtjb21wb25lbnQua2V5XVxcXCJcXHJcXG4gICAgdGFiaW5kZXg9XFxcInt7IGNvbXBvbmVudC50YWJpbmRleCB8fCAwIH19XFxcIlxcclxcbiAgICBidWlsZGVyPVxcXCJidWlsZGVyXFxcIlxcclxcbiAgPjwvZGF5LWlucHV0PlxcclxcbjwvZGl2PlxcclxcblwiXHJcbiAgICAgICkpO1xyXG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL2RheS1pbnB1dC5odG1sJyxcclxuICAgICAgICBcIjxkaXYgY2xhc3M9XFxcImRheVNlbGVjdCBmb3JtIHJvd1xcXCI+XFxyXFxuICA8ZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwIGNvbC14cy0zXFxcIiBuZy1pZj1cXFwiY29tcG9uZW50LmRheUZpcnN0ICYmICFjb21wb25lbnQuZmllbGRzLmRheS5oaWRlXFxcIj5cXHJcXG4gICAgPGxhYmVsIGZvcj1cXFwie3tjb21wb25lbnRJZH19LWRheVxcXCIgbmctY2xhc3M9XFxcInsnZmllbGQtcmVxdWlyZWQnOiBjb21wb25lbnQuZmllbGRzLmRheS5yZXF1aXJlZH1cXFwiPnt7IFxcXCJEYXlcXFwiIHwgZm9ybWlvVHJhbnNsYXRlOm51bGw6YnVpbGRlciB9fTwvbGFiZWw+XFxyXFxuICAgIDxpbnB1dFxcclxcbiAgICAgIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiXFxyXFxuICAgICAgdHlwZT1cXFwidGV4dFxcXCJcXHJcXG4gICAgICBpZD1cXFwie3tjb21wb25lbnRJZH19LWRheVxcXCJcXHJcXG4gICAgICBuZy1tb2RlbD1cXFwiZGF0ZS5kYXlcXFwiXFxyXFxuICAgICAgbmctY2hhbmdlPVxcXCJvbkNoYW5nZSgpXFxcIlxcclxcbiAgICAgIHN0eWxlPVxcXCJwYWRkaW5nLXJpZ2h0OiAxMHB4O1xcXCJcXHJcXG4gICAgICBuZy1hdHRyLXBsYWNlaG9sZGVyPVxcXCJ7e2NvbXBvbmVudC5maWVsZHMuZGF5LnBsYWNlaG9sZGVyfX1cXFwiXFxyXFxuICAgICAgZGF5LXBhcnRcXHJcXG4gICAgICBjaGFyYWN0ZXJzPVxcXCIyXFxcIlxcclxcbiAgICAgIG1pbj1cXFwiMFxcXCJcXHJcXG4gICAgICBtYXg9XFxcIjMxXFxcIlxcclxcbiAgICAgIG5nLWRpc2FibGVkPVxcXCJyZWFkT25seVxcXCJcXHJcXG4gICAgLz5cXHJcXG4gIDwvZGl2PlxcclxcbiAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cCBjb2wteHMtNFxcXCIgbmctaWY9XFxcIiFjb21wb25lbnQuZmllbGRzLm1vbnRoLmhpZGVcXFwiPlxcclxcbiAgICA8bGFiZWwgZm9yPVxcXCJ7e2NvbXBvbmVudElkfX0tbW9udGhcXFwiIG5nLWNsYXNzPVxcXCJ7J2ZpZWxkLXJlcXVpcmVkJzogY29tcG9uZW50LmZpZWxkcy5tb250aC5yZXF1aXJlZH1cXFwiPnt7IFxcXCJNb250aFxcXCIgfCBmb3JtaW9UcmFuc2xhdGU6bnVsbDpidWlsZGVyIH19PC9sYWJlbD5cXHJcXG4gICAgPHNlbGVjdFxcclxcbiAgICAgIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiXFxyXFxuICAgICAgdHlwZT1cXFwidGV4dFxcXCJcXHJcXG4gICAgICBpZD1cXFwie3tjb21wb25lbnRJZH19LW1vbnRoXFxcIlxcclxcbiAgICAgIG5nLW1vZGVsPVxcXCJkYXRlLm1vbnRoXFxcIlxcclxcbiAgICAgIG5nLWNoYW5nZT1cXFwib25DaGFuZ2UoKVxcXCJcXHJcXG4gICAgICBuZy1kaXNhYmxlZD1cXFwicmVhZE9ubHlcXFwiXFxyXFxuICAgICAgbmctb3B0aW9ucz1cXFwibW9udGgudmFsdWUgYXMgbW9udGgubGFiZWwgfCBmb3JtaW9UcmFuc2xhdGU6bnVsbDpidWlsZGVyIGZvciBtb250aCBpbiBtb250aHNcXFwiXFxyXFxuICAgID48L3NlbGVjdD5cXHJcXG4gIDwvZGl2PlxcclxcbiAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cCBjb2wteHMtM1xcXCIgbmctaWY9XFxcIiFjb21wb25lbnQuZGF5Rmlyc3QgJiYgIWNvbXBvbmVudC5maWVsZHMuZGF5LmhpZGVcXFwiPlxcclxcbiAgICA8bGFiZWwgZm9yPVxcXCJ7e2NvbXBvbmVudElkfX0tZGF5XFxcIiBuZy1jbGFzcz1cXFwieydmaWVsZC1yZXF1aXJlZCc6IGNvbXBvbmVudC5maWVsZHMuZGF5LnJlcXVpcmVkfVxcXCI+e3sgXFxcIkRheVxcXCIgfCBmb3JtaW9UcmFuc2xhdGU6bnVsbDpidWlsZGVyIH19PC9sYWJlbD5cXHJcXG4gICAgPGlucHV0XFxyXFxuICAgICAgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCJcXHJcXG4gICAgICB0eXBlPVxcXCJ0ZXh0XFxcIlxcclxcbiAgICAgIGlkPVxcXCJ7e2NvbXBvbmVudElkfX0tZGF5MVxcXCJcXHJcXG4gICAgICBuZy1tb2RlbD1cXFwiZGF0ZS5kYXlcXFwiXFxyXFxuICAgICAgbmctY2hhbmdlPVxcXCJvbkNoYW5nZSgpXFxcIlxcclxcbiAgICAgIHN0eWxlPVxcXCJwYWRkaW5nLXJpZ2h0OiAxMHB4O1xcXCJcXHJcXG4gICAgICBuZy1hdHRyLXBsYWNlaG9sZGVyPVxcXCJ7e2NvbXBvbmVudC5maWVsZHMuZGF5LnBsYWNlaG9sZGVyfX1cXFwiXFxyXFxuICAgICAgZGF5LXBhcnRcXHJcXG4gICAgICBjaGFyYWN0ZXJzPVxcXCIyXFxcIlxcclxcbiAgICAgIG1pbj1cXFwiMFxcXCJcXHJcXG4gICAgICBtYXg9XFxcIjMxXFxcIlxcclxcbiAgICAgIG5nLWRpc2FibGVkPVxcXCJyZWFkT25seVxcXCJcXHJcXG4gICAgLz5cXHJcXG4gIDwvZGl2PlxcclxcbiAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cCBjb2wteHMtNVxcXCIgbmctaWY9XFxcIiFjb21wb25lbnQuZmllbGRzLnllYXIuaGlkZVxcXCI+XFxyXFxuICAgIDxsYWJlbCBmb3I9XFxcInt7Y29tcG9uZW50SWR9fS15ZWFyXFxcIiBuZy1jbGFzcz1cXFwieydmaWVsZC1yZXF1aXJlZCc6IGNvbXBvbmVudC5maWVsZHMueWVhci5yZXF1aXJlZH1cXFwiPnt7IFxcXCJZZWFyXFxcIiB8IGZvcm1pb1RyYW5zbGF0ZTpudWxsOmJ1aWxkZXIgfX08L2xhYmVsPlxcclxcbiAgICA8aW5wdXRcXHJcXG4gICAgICBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIlxcclxcbiAgICAgIHR5cGU9XFxcInRleHRcXFwiXFxyXFxuICAgICAgaWQ9XFxcInt7Y29tcG9uZW50SWR9fS15ZWFyXFxcIlxcclxcbiAgICAgIG5nLW1vZGVsPVxcXCJkYXRlLnllYXJcXFwiXFxyXFxuICAgICAgbmctY2hhbmdlPVxcXCJvbkNoYW5nZSgpXFxcIlxcclxcbiAgICAgIHN0eWxlPVxcXCJwYWRkaW5nLXJpZ2h0OiAxMHB4O1xcXCJcXHJcXG4gICAgICBuZy1hdHRyLXBsYWNlaG9sZGVyPVxcXCJ7e2NvbXBvbmVudC5maWVsZHMueWVhci5wbGFjZWhvbGRlcn19XFxcIlxcclxcbiAgICAgIGNoYXJhY3RlcnM9XFxcIjRcXFwiXFxyXFxuICAgICAgbWluPVxcXCIwXFxcIlxcclxcbiAgICAgIG1heD1cXFwiMjEwMFxcXCJcXHJcXG4gICAgICBuZy1kaXNhYmxlZD1cXFwicmVhZE9ubHlcXFwiXFxyXFxuICAgIC8+XFxyXFxuICA8L2Rpdj5cXHJcXG48L2Rpdj5cXHJcXG5cIlxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIF0pO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBwKSB7XHJcbiAgYXBwLmNvbmZpZyhbXHJcbiAgICAnZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyJyxcclxuICAgIGZ1bmN0aW9uKGZvcm1pb0NvbXBvbmVudHNQcm92aWRlcikge1xyXG4gICAgICBmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIucmVnaXN0ZXIoJ2VtYWlsJywge1xyXG4gICAgICAgIHRpdGxlOiAnRW1haWwnLFxyXG4gICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvdGV4dGZpZWxkLmh0bWwnLFxyXG4gICAgICAgIGdyb3VwOiAnYWR2YW5jZWQnLFxyXG4gICAgICAgIHNldHRpbmdzOiB7XHJcbiAgICAgICAgICBpbnB1dDogdHJ1ZSxcclxuICAgICAgICAgIHRhYmxlVmlldzogdHJ1ZSxcclxuICAgICAgICAgIGlucHV0VHlwZTogJ2VtYWlsJyxcclxuICAgICAgICAgIGxhYmVsOiAnJyxcclxuICAgICAgICAgIGtleTogJ2VtYWlsRmllbGQnLFxyXG4gICAgICAgICAgcGxhY2Vob2xkZXI6ICcnLFxyXG4gICAgICAgICAgcHJlZml4OiAnJyxcclxuICAgICAgICAgIHN1ZmZpeDogJycsXHJcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6ICcnLFxyXG4gICAgICAgICAgcHJvdGVjdGVkOiBmYWxzZSxcclxuICAgICAgICAgIHVuaXF1ZTogZmFsc2UsXHJcbiAgICAgICAgICBwZXJzaXN0ZW50OiB0cnVlLFxyXG4gICAgICAgICAgaGlkZGVuOiBmYWxzZSxcclxuICAgICAgICAgIGNsZWFyT25IaWRlOiB0cnVlLFxyXG4gICAgICAgICAga2lja2JveDoge1xyXG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgXSk7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xuXHJcbnZhciBHcmlkVXRpbHMgPSByZXF1aXJlKCcuLi9mYWN0b3JpZXMvR3JpZFV0aWxzJykoKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBwKSB7XHJcbiAgYXBwLmNvbmZpZyhbXHJcbiAgICAnZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyJyxcclxuICAgIGZ1bmN0aW9uKGZvcm1pb0NvbXBvbmVudHNQcm92aWRlcikge1xyXG4gICAgICBmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIucmVnaXN0ZXIoJ2ZpZWxkc2V0Jywge1xyXG4gICAgICAgIHRpdGxlOiAnRmllbGQgU2V0JyxcclxuICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL2ZpZWxkc2V0Lmh0bWwnLFxyXG4gICAgICAgIGdyb3VwOiAnbGF5b3V0JyxcclxuICAgICAgICBzZXR0aW5nczoge1xyXG4gICAgICAgICAga2V5OiAnZmllbGRzZXQnLFxyXG4gICAgICAgICAgaW5wdXQ6IGZhbHNlLFxyXG4gICAgICAgICAgdGFibGVWaWV3OiB0cnVlLFxyXG4gICAgICAgICAgbGVnZW5kOiAnJyxcclxuICAgICAgICAgIGNvbXBvbmVudHM6IFtdXHJcbiAgICAgICAgfSxcclxuICAgICAgICB2aWV3VGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50c1ZpZXcvZmllbGRzZXQuaHRtbCcsXHJcbiAgICAgICAgdGFibGVWaWV3OiBmdW5jdGlvbihkYXRhLCBjb21wb25lbnQsICRpbnRlcnBvbGF0ZSwgY29tcG9uZW50SW5mbywgdGFibGVDaGlsZCkge1xyXG4gICAgICAgICAgdmFyIHZpZXcgPSAnPHRhYmxlIGNsYXNzPVwidGFibGUgdGFibGUtc3RyaXBlZCB0YWJsZS1ib3JkZXJlZCB0YWJsZS1jaGlsZFwiPic7XHJcblxyXG4gICAgICAgICAgaWYgKCF0YWJsZUNoaWxkKSB7XHJcbiAgICAgICAgICAgIHZpZXcgKz0gJzx0aGVhZD48dHI+JztcclxuICAgICAgICAgICAgdmlldyArPSAnPHRoPkZpZWxkIFNldCAoJyArIGNvbXBvbmVudC5rZXkgKyAnKTwvdGg+JztcclxuICAgICAgICAgICAgdmlldyArPSAnPC90cj48L3RoZWFkPic7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB2aWV3ICs9ICc8dGJvZHk+JztcclxuICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChjb21wb25lbnQuY29tcG9uZW50cywgZnVuY3Rpb24oY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIHZpZXcgKz0gJzx0cj4nICsgR3JpZFV0aWxzLmNvbHVtbkZvckNvbXBvbmVudChkYXRhLCBjb21wb25lbnQsICRpbnRlcnBvbGF0ZSwgY29tcG9uZW50SW5mbywgdHJ1ZSkgKyAnPC90cj4nO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgdmlldyArPSAnPC90Ym9keT48L3RhYmxlPic7XHJcbiAgICAgICAgICByZXR1cm4gdmlldztcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIF0pO1xyXG4gIGFwcC5ydW4oW1xyXG4gICAgJyR0ZW1wbGF0ZUNhY2hlJyxcclxuICAgIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvZmllbGRzZXQuaHRtbCcsXHJcbiAgICAgICAgXCI8ZmllbGRzZXQgaWQ9XFxcInt7IGNvbXBvbmVudC5rZXkgfX1cXFwiPlxcclxcbiAgPGxlZ2VuZCBuZy1pZj1cXFwiY29tcG9uZW50LmxlZ2VuZFxcXCI+e3sgY29tcG9uZW50LmxlZ2VuZCB8IGZvcm1pb1RyYW5zbGF0ZTpudWxsOmJ1aWxkZXIgfX08L2xlZ2VuZD5cXHJcXG4gIDxmb3JtaW8tY29tcG9uZW50XFxyXFxuICAgIG5nLXJlcGVhdD1cXFwiX2NvbXBvbmVudCBpbiBjb21wb25lbnQuY29tcG9uZW50cyB0cmFjayBieSAkaW5kZXhcXFwiXFxyXFxuICAgIGNvbXBvbmVudD1cXFwiX2NvbXBvbmVudFxcXCJcXHJcXG4gICAgZGF0YT1cXFwiZGF0YVxcXCJcXHJcXG4gICAgZm9ybWlvPVxcXCJmb3JtaW9cXFwiXFxyXFxuICAgIHN1Ym1pc3Npb249XFxcInN1Ym1pc3Npb25cXFwiXFxyXFxuICAgIGhpZGUtY29tcG9uZW50cz1cXFwiaGlkZUNvbXBvbmVudHNcXFwiXFxyXFxuICAgIG5nLWlmPVxcXCJidWlsZGVyID8gJzo6dHJ1ZScgOiBpc1Zpc2libGUoX2NvbXBvbmVudCwgZGF0YSlcXFwiXFxyXFxuICAgIHJlYWQtb25seT1cXFwiaXNEaXNhYmxlZChfY29tcG9uZW50LCBkYXRhKVxcXCJcXHJcXG4gICAgZm9ybWlvLWZvcm09XFxcImZvcm1pb0Zvcm1cXFwiXFxyXFxuICAgIGdyaWQtcm93PVxcXCJncmlkUm93XFxcIlxcclxcbiAgICBncmlkLWNvbD1cXFwiZ3JpZENvbFxcXCJcXHJcXG4gICAgYnVpbGRlcj1cXFwiYnVpbGRlclxcXCJcXHJcXG4gID48L2Zvcm1pby1jb21wb25lbnQ+XFxyXFxuPC9maWVsZHNldD5cXHJcXG5cIlxyXG4gICAgICApO1xyXG5cclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50c1ZpZXcvZmllbGRzZXQuaHRtbCcsXHJcbiAgICAgICAgXCI8ZmllbGRzZXQgaWQ9XFxcInt7IGNvbXBvbmVudC5rZXkgfX1cXFwiPlxcclxcbiAgPGxlZ2VuZCBuZy1pZj1cXFwiY29tcG9uZW50LmxlZ2VuZFxcXCI+e3sgY29tcG9uZW50LmxlZ2VuZCB9fTwvbGVnZW5kPlxcclxcbiAgPGZvcm1pby1jb21wb25lbnQtdmlld1xcclxcbiAgICBuZy1yZXBlYXQ9XFxcIl9jb21wb25lbnQgaW4gY29tcG9uZW50LmNvbXBvbmVudHMgdHJhY2sgYnkgJGluZGV4XFxcIlxcclxcbiAgICBjb21wb25lbnQ9XFxcIl9jb21wb25lbnRcXFwiXFxyXFxuICAgIGRhdGE9XFxcImRhdGFcXFwiXFxyXFxuICAgIHN1Ym1pc3Npb249XFxcInN1Ym1pc3Npb25cXFwiXFxyXFxuICAgIGZvcm09XFxcImZvcm1cXFwiXFxyXFxuICAgIGlnbm9yZT1cXFwiaWdub3JlXFxcIlxcclxcbiAgICBuZy1pZj1cXFwiYnVpbGRlciA/ICc6OnRydWUnIDogaXNWaXNpYmxlKF9jb21wb25lbnQsIGRhdGEpXFxcIlxcclxcbiAgICBidWlsZGVyPVxcXCJidWlsZGVyXFxcIlxcclxcbiAgPjwvZm9ybWlvLWNvbXBvbmVudC12aWV3PlxcclxcbjwvZmllbGRzZXQ+XFxyXFxuXCJcclxuICAgICAgKTtcclxuICAgIH1cclxuICBdKTtcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcHApIHtcclxuICBhcHAuY29uZmlnKFtcclxuICAgICdmb3JtaW9Db21wb25lbnRzUHJvdmlkZXInLFxyXG4gICAgZnVuY3Rpb24oZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyKSB7XHJcbiAgICAgIGZvcm1pb0NvbXBvbmVudHNQcm92aWRlci5yZWdpc3RlcignZmlsZScsIHtcclxuICAgICAgICB0aXRsZTogJ0ZpbGUnLFxyXG4gICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvZmlsZS5odG1sJyxcclxuICAgICAgICBncm91cDogJ2FkdmFuY2VkJyxcclxuICAgICAgICBzZXR0aW5nczoge1xyXG4gICAgICAgICAgaW5wdXQ6IHRydWUsXHJcbiAgICAgICAgICB0YWJsZVZpZXc6IHRydWUsXHJcbiAgICAgICAgICBsYWJlbDogJycsXHJcbiAgICAgICAgICBrZXk6ICdmaWxlJyxcclxuICAgICAgICAgIGltYWdlOiBmYWxzZSxcclxuICAgICAgICAgIGltYWdlU2l6ZTogJzIwMCcsXHJcbiAgICAgICAgICBwbGFjZWhvbGRlcjogJycsXHJcbiAgICAgICAgICBtdWx0aXBsZTogZmFsc2UsXHJcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6ICcnLFxyXG4gICAgICAgICAgcHJvdGVjdGVkOiBmYWxzZSxcclxuICAgICAgICAgIHBlcnNpc3RlbnQ6IHRydWUsXHJcbiAgICAgICAgICBoaWRkZW46IGZhbHNlLFxyXG4gICAgICAgICAgY2xlYXJPbkhpZGU6IHRydWVcclxuICAgICAgICB9LFxyXG4gICAgICAgIHZpZXdUZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzVmlldy9maWxlLmh0bWwnXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIF0pO1xyXG5cclxuICBhcHAuZGlyZWN0aXZlKCdmb3JtaW9GaWxlTGlzdCcsIFtmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgIHJlcGxhY2U6IHRydWUsXHJcbiAgICAgIHNjb3BlOiB7XHJcbiAgICAgICAgZmlsZXM6ICc9JyxcclxuICAgICAgICBmb3JtOiAnPScsXHJcbiAgICAgICAgcmVhZE9ubHk6ICc9J1xyXG4gICAgICB9LFxyXG4gICAgICB0ZW1wbGF0ZVVybDogJ2Zvcm1pby9jb21wb25lbnRzL2Zvcm1pby1maWxlLWxpc3QuaHRtbCcsXHJcbiAgICAgIGNvbnRyb2xsZXI6IFtcclxuICAgICAgICAnJHNjb3BlJyxcclxuICAgICAgICBmdW5jdGlvbigkc2NvcGUpIHtcclxuICAgICAgICAgIGlmICgkc2NvcGUuYnVpbGRlcikgcmV0dXJuO1xyXG4gICAgICAgICAgJHNjb3BlLnJlbW92ZUZpbGUgPSBmdW5jdGlvbihldmVudCwgaW5kZXgpIHtcclxuICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9ICRzY29wZS4kcGFyZW50LmNvbXBvbmVudDtcclxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5zdG9yYWdlID09PSAndXJsJykge1xyXG4gICAgICAgICAgICAgICRzY29wZS4kcGFyZW50LmZvcm1pby5tYWtlUmVxdWVzdCgnJywgY29tcG9uZW50LnVybCArICcvJyArICRzY29wZS5maWxlc1tpbmRleF0ubmFtZSwgJ2RlbGV0ZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICRzY29wZS5maWxlcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAkc2NvcGUuZmlsZVNpemUgPSBmdW5jdGlvbihhLCBiLCBjLCBkLCBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoYiA9IE1hdGgsIGMgPSBiLmxvZywgZCA9IDEwMjQsIGUgPSBjKGEpIC8gYyhkKSB8IDAsIGEgLyBiLnBvdyhkLCBlKSkudG9GaXhlZCgyKSArICcgJyArIChlID8gJ2tNR1RQRVpZJ1stLWVdICsgJ0InIDogJ0J5dGVzJyk7XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgXVxyXG4gICAgfTtcclxuICB9XSk7XHJcblxyXG4gIGFwcC5kaXJlY3RpdmUoJ2Zvcm1pb0ltYWdlTGlzdCcsIFtmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgIHJlcGxhY2U6IHRydWUsXHJcbiAgICAgIHNjb3BlOiB7XHJcbiAgICAgICAgZmlsZXM6ICc9JyxcclxuICAgICAgICBmb3JtOiAnPScsXHJcbiAgICAgICAgd2lkdGg6ICc9JyxcclxuICAgICAgICByZWFkT25seTogJz0nXHJcbiAgICAgIH0sXHJcbiAgICAgIHRlbXBsYXRlVXJsOiAnZm9ybWlvL2NvbXBvbmVudHMvZm9ybWlvLWltYWdlLWxpc3QuaHRtbCcsXHJcbiAgICAgIGNvbnRyb2xsZXI6IFtcclxuICAgICAgICAnJHNjb3BlJyxcclxuICAgICAgICBmdW5jdGlvbigkc2NvcGUpIHtcclxuICAgICAgICAgIGlmICgkc2NvcGUuYnVpbGRlcikgcmV0dXJuO1xyXG4gICAgICAgICAgJHNjb3BlLnJlbW92ZUZpbGUgPSBmdW5jdGlvbihldmVudCwgaW5kZXgpIHtcclxuICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9ICRzY29wZS4kcGFyZW50LmNvbXBvbmVudDtcclxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5zdG9yYWdlID09PSAndXJsJykge1xyXG4gICAgICAgICAgICAgICRzY29wZS4kcGFyZW50LmZvcm1pby5tYWtlUmVxdWVzdCgnJywgY29tcG9uZW50LnVybCArICcvJyArICRzY29wZS5maWxlc1tpbmRleF0ubmFtZSwgJ2RlbGV0ZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICRzY29wZS5maWxlcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgIF1cclxuICAgIH07XHJcbiAgfV0pO1xyXG5cclxuICBhcHAuZGlyZWN0aXZlKCdmb3JtaW9GaWxlJywgW2Z1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgcmVwbGFjZTogdHJ1ZSxcclxuICAgICAgc2NvcGU6IHtcclxuICAgICAgICBmaWxlOiAnPScsXHJcbiAgICAgICAgZm9ybTogJz0nXHJcbiAgICAgIH0sXHJcbiAgICAgIHRlbXBsYXRlOiAnPGEgaHJlZj1cInt7IGZpbGUudXJsIH19XCIgbmctY2xpY2s9XCJnZXRGaWxlKCRldmVudClcIiB0YXJnZXQ9XCJfYmxhbmtcIj57eyBmaWxlLm5hbWUgfX08L2E+JyxcclxuICAgICAgY29udHJvbGxlcjogW1xyXG4gICAgICAgICckd2luZG93JyxcclxuICAgICAgICAnJHJvb3RTY29wZScsXHJcbiAgICAgICAgJyRzY29wZScsXHJcbiAgICAgICAgJ0Zvcm1pbycsXHJcbiAgICAgICAgZnVuY3Rpb24oXHJcbiAgICAgICAgICAkd2luZG93LFxyXG4gICAgICAgICAgJHJvb3RTY29wZSxcclxuICAgICAgICAgICRzY29wZSxcclxuICAgICAgICAgIEZvcm1pb1xyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgaWYgKCRzY29wZS5idWlsZGVyKSByZXR1cm47XHJcbiAgICAgICAgICAkc2NvcGUuZ2V0RmlsZSA9IGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgJHNjb3BlLmZvcm0gPSAkc2NvcGUuZm9ybSB8fCAkcm9vdFNjb3BlLmZpbGVQYXRoO1xyXG4gICAgICAgICAgICB2YXIgZm9ybWlvID0gbmV3IEZvcm1pbygkc2NvcGUuZm9ybSk7XHJcbiAgICAgICAgICAgIGZvcm1pb1xyXG4gICAgICAgICAgICAgIC5kb3dubG9hZEZpbGUoJHNjb3BlLmZpbGUpLnRoZW4oZnVuY3Rpb24oZmlsZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpbGUpIHtcclxuICAgICAgICAgICAgICAgICAgJHdpbmRvdy5vcGVuKGZpbGUudXJsLCAnX2JsYW5rJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24ocmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgIC8vIElzIGFsZXJ0IHRoZSBiZXN0IHdheSB0byBkbyB0aGlzP1xyXG4gICAgICAgICAgICAgICAgLy8gVXNlciBpcyBleHBlY3RpbmcgYW4gaW1tZWRpYXRlIG5vdGlmaWNhdGlvbiBkdWUgdG8gYXR0ZW1wdGluZyB0byBkb3dubG9hZCBhIGZpbGUuXHJcbiAgICAgICAgICAgICAgICBhbGVydChyZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgXVxyXG4gICAgfTtcclxuICB9XSk7XHJcblxyXG4gIGFwcC5kaXJlY3RpdmUoJ2Zvcm1pb0ltYWdlJywgW2Z1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgcmVwbGFjZTogdHJ1ZSxcclxuICAgICAgc2NvcGU6IHtcclxuICAgICAgICBmaWxlOiAnPScsXHJcbiAgICAgICAgZm9ybTogJz0nLFxyXG4gICAgICAgIHdpZHRoOiAnPSdcclxuICAgICAgfSxcclxuICAgICAgdGVtcGxhdGU6ICc8aW1nIG5nLXNyYz1cInt7IGZpbGUuaW1hZ2VTcmMgfX1cIiBhbHQ9XCJ7eyBmaWxlLm5hbWUgfX1cIiBuZy1zdHlsZT1cInt3aWR0aDogd2lkdGh9XCIgLz4nLFxyXG4gICAgICBjb250cm9sbGVyOiBbXHJcbiAgICAgICAgJyRyb290U2NvcGUnLFxyXG4gICAgICAgICckc2NvcGUnLFxyXG4gICAgICAgICdGb3JtaW8nLFxyXG4gICAgICAgIGZ1bmN0aW9uKFxyXG4gICAgICAgICAgJHJvb3RTY29wZSxcclxuICAgICAgICAgICRzY29wZSxcclxuICAgICAgICAgIEZvcm1pb1xyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgaWYgKCRzY29wZS5idWlsZGVyKSByZXR1cm47XHJcbiAgICAgICAgICAkc2NvcGUuZm9ybSA9ICRzY29wZS5mb3JtIHx8ICRyb290U2NvcGUuZmlsZVBhdGg7XHJcbiAgICAgICAgICB2YXIgZm9ybWlvID0gbmV3IEZvcm1pbygkc2NvcGUuZm9ybSk7XHJcbiAgICAgICAgICBmb3JtaW8uZG93bmxvYWRGaWxlKCRzY29wZS5maWxlKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAkc2NvcGUuZmlsZS5pbWFnZVNyYyA9IHJlc3VsdC51cmw7XHJcbiAgICAgICAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIF1cclxuICAgIH07XHJcbiAgfV0pO1xyXG5cclxuICBhcHAuY29udHJvbGxlcignZm9ybWlvRmlsZVVwbG9hZCcsIFtcclxuICAgICckc2NvcGUnLFxyXG4gICAgJyRpbnRlcnBvbGF0ZScsXHJcbiAgICAnRm9ybWlvVXRpbHMnLFxyXG4gICAgZnVuY3Rpb24oXHJcbiAgICAgICRzY29wZSxcclxuICAgICAgJGludGVycG9sYXRlLFxyXG4gICAgICBGb3JtaW9VdGlsc1xyXG4gICAgKSB7XHJcbiAgICAgIGlmICgkc2NvcGUuYnVpbGRlcikgcmV0dXJuO1xyXG4gICAgICAkc2NvcGUuZmlsZVVwbG9hZHMgPSB7fTtcclxuICAgICAgJHNjb3BlLnJlbW92ZVVwbG9hZCA9IGZ1bmN0aW9uKGluZGV4KSB7XHJcbiAgICAgICAgZGVsZXRlICRzY29wZS5maWxlVXBsb2Fkc1tpbmRleF07XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBUaGlzIGZpeGVzIG5ldyBmaWVsZHMgaGF2aW5nIGFuIGVtcHR5IHNwYWNlIGluIHRoZSBhcnJheS5cclxuICAgICAgaWYgKCRzY29wZS5kYXRhICYmICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSA9PT0gJycpIHtcclxuICAgICAgICAkc2NvcGUuZGF0YVskc2NvcGUuY29tcG9uZW50LmtleV0gPSBbXTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoJHNjb3BlLmRhdGEgJiYgJHNjb3BlLmRhdGFbJHNjb3BlLmNvbXBvbmVudC5rZXldID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAkc2NvcGUuZGF0YVskc2NvcGUuY29tcG9uZW50LmtleV0gPSBbXTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoJHNjb3BlLmRhdGEgJiYgJHNjb3BlLmRhdGFbJHNjb3BlLmNvbXBvbmVudC5rZXldICYmICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XVswXSA9PT0gJycpIHtcclxuICAgICAgICAkc2NvcGUuZGF0YVskc2NvcGUuY29tcG9uZW50LmtleV0uc3BsaWNlKDAsIDEpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAkc2NvcGUudXBsb2FkID0gZnVuY3Rpb24oZmlsZXMpIHtcclxuICAgICAgICBpZiAoJHNjb3BlLmNvbXBvbmVudC5zdG9yYWdlICYmIGZpbGVzICYmIGZpbGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGZpbGVzLCBmdW5jdGlvbihmaWxlKSB7XHJcbiAgICAgICAgICAgIC8vIEdldCBhIHVuaXF1ZSBuYW1lIGZvciB0aGlzIGZpbGUgdG8ga2VlcCBmaWxlIGNvbGxpc2lvbnMgZnJvbSBvY2N1cnJpbmcuXHJcbiAgICAgICAgICAgIHZhciBmaWxlTmFtZSA9IEZvcm1pb1V0aWxzLnVuaXF1ZU5hbWUoZmlsZS5uYW1lKTtcclxuICAgICAgICAgICAgJHNjb3BlLmZpbGVVcGxvYWRzW2ZpbGVOYW1lXSA9IHtcclxuICAgICAgICAgICAgICBuYW1lOiBmaWxlTmFtZSxcclxuICAgICAgICAgICAgICBzaXplOiBmaWxlLnNpemUsXHJcbiAgICAgICAgICAgICAgc3RhdHVzOiAnaW5mbycsXHJcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ1N0YXJ0aW5nIHVwbG9hZCdcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIGRpciA9ICRzY29wZS5jb21wb25lbnQuZGlyIHx8ICcnO1xyXG4gICAgICAgICAgICBkaXIgPSAkaW50ZXJwb2xhdGUoZGlyKSh7ZGF0YTogJHNjb3BlLmRhdGEsIHJvdzogJHNjb3BlLnJvd30pO1xyXG4gICAgICAgICAgICB2YXIgZm9ybWlvID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKCRzY29wZS5mb3JtaW8pIHtcclxuICAgICAgICAgICAgICBmb3JtaW8gPSAkc2NvcGUuZm9ybWlvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICRzY29wZS5maWxlVXBsb2Fkc1tmaWxlTmFtZV0uc3RhdHVzID0gJ2Vycm9yJztcclxuICAgICAgICAgICAgICAkc2NvcGUuZmlsZVVwbG9hZHNbZmlsZU5hbWVdLm1lc3NhZ2UgPSAnRmlsZSBVcGxvYWQgVVJMIG5vdCBwcm92aWRlZC4nO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZm9ybWlvKSB7XHJcbiAgICAgICAgICAgICAgZm9ybWlvLnVwbG9hZEZpbGUoJHNjb3BlLmNvbXBvbmVudC5zdG9yYWdlLCBmaWxlLCBmaWxlTmFtZSwgZGlyLCBmdW5jdGlvbiBwcm9jZXNzTm90aWZ5KGV2dCkge1xyXG4gICAgICAgICAgICAgICAgJHNjb3BlLmZpbGVVcGxvYWRzW2ZpbGVOYW1lXS5zdGF0dXMgPSAncHJvZ3Jlc3MnO1xyXG4gICAgICAgICAgICAgICAgJHNjb3BlLmZpbGVVcGxvYWRzW2ZpbGVOYW1lXS5wcm9ncmVzcyA9IHBhcnNlSW50KDEwMC4wICogZXZ0LmxvYWRlZCAvIGV2dC50b3RhbCk7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgJHNjb3BlLmZpbGVVcGxvYWRzW2ZpbGVOYW1lXS5tZXNzYWdlO1xyXG4gICAgICAgICAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xyXG4gICAgICAgICAgICAgIH0sICRzY29wZS5jb21wb25lbnQudXJsKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oZmlsZUluZm8pIHtcclxuICAgICAgICAgICAgICAgICAgZGVsZXRlICRzY29wZS5maWxlVXBsb2Fkc1tmaWxlTmFtZV07XHJcbiAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBmaWxlIGNvbXBvbmVudCBpcyBhbiBhcnJheS5cclxuICAgICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgICEkc2NvcGUuZGF0YVskc2NvcGUuY29tcG9uZW50LmtleV0gfHxcclxuICAgICAgICAgICAgICAgICAgICAhKCRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSBpbnN0YW5jZW9mIEFycmF5KVxyXG4gICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YVskc2NvcGUuY29tcG9uZW50LmtleV0gPSBbXTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YVskc2NvcGUuY29tcG9uZW50LmtleV0ucHVzaChmaWxlSW5mbyk7XHJcbiAgICAgICAgICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24ocmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgICAgJHNjb3BlLmZpbGVVcGxvYWRzW2ZpbGVOYW1lXS5zdGF0dXMgPSAnZXJyb3InO1xyXG4gICAgICAgICAgICAgICAgICAkc2NvcGUuZmlsZVVwbG9hZHNbZmlsZU5hbWVdLm1lc3NhZ2UgPSByZXNwb25zZS5kYXRhO1xyXG4gICAgICAgICAgICAgICAgICBkZWxldGUgJHNjb3BlLmZpbGVVcGxvYWRzW2ZpbGVOYW1lXS5wcm9ncmVzcztcclxuICAgICAgICAgICAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH1cclxuICBdKTtcclxuICBhcHAucnVuKFtcclxuICAgICckdGVtcGxhdGVDYWNoZScsXHJcbiAgICBmdW5jdGlvbihcclxuICAgICAgJHRlbXBsYXRlQ2FjaGVcclxuICAgICkge1xyXG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL2Zvcm1pby1pbWFnZS1saXN0Lmh0bWwnLFxyXG4gICAgICAgIFwiPGRpdj5cXHJcXG4gIDxzcGFuIG5nLXJlcGVhdD1cXFwiZmlsZSBpbiBmaWxlcyB0cmFjayBieSAkaW5kZXhcXFwiIG5nLWlmPVxcXCJmaWxlXFxcIj5cXHJcXG4gICAgPGZvcm1pby1pbWFnZSBmaWxlPVxcXCJmaWxlXFxcIiBmb3JtPVxcXCJmb3JtXFxcIiB3aWR0aD1cXFwid2lkdGhcXFwiPjwvZm9ybWlvLWltYWdlPlxcclxcbiAgICA8c3BhbiBuZy1pZj1cXFwiIXJlYWRPbmx5XFxcIiBzdHlsZT1cXFwid2lkdGg6MSU7d2hpdGUtc3BhY2U6bm93cmFwO1xcXCI+XFxyXFxuICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgbmctY2xpY2s9XFxcInJlbW92ZUZpbGUoJGV2ZW50LCAkaW5kZXgpXFxcIiBzdHlsZT1cXFwicGFkZGluZzogMnB4IDRweDtcXFwiIGNsYXNzPVxcXCJidG4gYnRuLXNtIGJ0bi1kZWZhdWx0XFxcIj48c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1yZW1vdmVcXFwiPjwvc3Bhbj48L2E+XFxyXFxuICAgIDwvc3Bhbj5cXHJcXG4gIDwvc3Bhbj5cXHJcXG48L2Rpdj5cXHJcXG5cIlxyXG4gICAgICApO1xyXG5cclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9mb3JtaW8tZmlsZS1saXN0Lmh0bWwnLFxyXG4gICAgICAgIFwiPHRhYmxlIGNsYXNzPVxcXCJ0YWJsZSB0YWJsZS1zdHJpcGVkIHRhYmxlLWJvcmRlcmVkXFxcIj5cXHJcXG4gIDx0aGVhZD5cXHJcXG4gICAgPHRyPlxcclxcbiAgICAgIDx0ZCBuZy1pZj1cXFwiIXJlYWRPbmx5XFxcIiBzdHlsZT1cXFwid2lkdGg6MSU7d2hpdGUtc3BhY2U6bm93cmFwO1xcXCI+PC90ZD5cXHJcXG4gICAgICA8dGg+RmlsZSBOYW1lPC90aD5cXHJcXG4gICAgICA8dGg+U2l6ZTwvdGg+XFxyXFxuICAgIDwvdHI+XFxyXFxuICA8L3RoZWFkPlxcclxcbiAgPHRib2R5PlxcclxcbiAgICA8dHIgbmctcmVwZWF0PVxcXCJmaWxlIGluIGZpbGVzIHRyYWNrIGJ5ICRpbmRleFxcXCI+XFxyXFxuICAgICAgPHRkIG5nLWlmPVxcXCIhcmVhZE9ubHlcXFwiIHN0eWxlPVxcXCJ3aWR0aDoxJTt3aGl0ZS1zcGFjZTpub3dyYXA7XFxcIj48YSBuZy1pZj1cXFwiIXJlYWRPbmx5XFxcIiBocmVmPVxcXCIjXFxcIiBuZy1jbGljaz1cXFwicmVtb3ZlRmlsZSgkZXZlbnQsICRpbmRleClcXFwiIHN0eWxlPVxcXCJwYWRkaW5nOiAycHggNHB4O1xcXCIgY2xhc3M9XFxcImJ0biBidG4tc20gYnRuLWRlZmF1bHRcXFwiPjxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLXJlbW92ZVxcXCI+PC9zcGFuPjwvYT48L3RkPlxcclxcbiAgICAgIDx0ZD48Zm9ybWlvLWZpbGUgZmlsZT1cXFwiZmlsZVxcXCIgZm9ybT1cXFwiZm9ybVxcXCI+PC9mb3JtaW8tZmlsZT48L3RkPlxcclxcbiAgICAgIDx0ZD57eyBmaWxlU2l6ZShmaWxlLnNpemUpIH19PC90ZD5cXHJcXG4gICAgPC90cj5cXHJcXG4gIDwvdGJvZHk+XFxyXFxuPC90YWJsZT5cXHJcXG5cIlxyXG4gICAgICApO1xyXG5cclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9maWxlLmh0bWwnLFxyXG4gICAgICAgIFwiPGxhYmVsIG5nLWlmPVxcXCJjb21wb25lbnQubGFiZWwgJiYgIWNvbXBvbmVudC5oaWRlTGFiZWxcXFwiIGZvcj1cXFwie3sgY29tcG9uZW50SWQgfX1cXFwiIGNsYXNzPVxcXCJjb250cm9sLWxhYmVsXFxcIiBuZy1jbGFzcz1cXFwieydmaWVsZC1yZXF1aXJlZCc6IGlzUmVxdWlyZWQoY29tcG9uZW50KX1cXFwiPnt7IGNvbXBvbmVudC5sYWJlbCB8IGZvcm1pb1RyYW5zbGF0ZTpudWxsOmJ1aWxkZXIgfX08L2xhYmVsPlxcclxcbjxzcGFuIG5nLWlmPVxcXCIhY29tcG9uZW50LmxhYmVsICYmIGlzUmVxdWlyZWQoY29tcG9uZW50KVxcXCIgY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tYXN0ZXJpc2sgZm9ybS1jb250cm9sLWZlZWRiYWNrIGZpZWxkLXJlcXVpcmVkLWlubGluZVxcXCIgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiPjwvc3Bhbj5cXHJcXG48ZGl2IG5nLWNvbnRyb2xsZXI9XFxcImZvcm1pb0ZpbGVVcGxvYWRcXFwiPlxcclxcbiAgPGZvcm1pby1maWxlLWxpc3QgZmlsZXM9XFxcImRhdGFbY29tcG9uZW50LmtleV1cXFwiIGZvcm09XFxcImZvcm1pby5mb3JtVXJsXFxcIiBuZy1pZj1cXFwiIWNvbXBvbmVudC5pbWFnZVxcXCI+PC9mb3JtaW8tZmlsZS1saXN0PlxcclxcbiAgPGZvcm1pby1pbWFnZS1saXN0IGZpbGVzPVxcXCJkYXRhW2NvbXBvbmVudC5rZXldXFxcIiBmb3JtPVxcXCJmb3JtaW8uZm9ybVVybFxcXCIgd2lkdGg9XFxcImNvbXBvbmVudC5pbWFnZVNpemVcXFwiIG5nLWlmPVxcXCJjb21wb25lbnQuaW1hZ2VcXFwiPjwvZm9ybWlvLWltYWdlLWxpc3Q+XFxyXFxuICA8ZGl2IG5nLWlmPVxcXCIhcmVhZE9ubHkgJiYgKGNvbXBvbmVudC5tdWx0aXBsZSB8fCAoIWNvbXBvbmVudC5tdWx0aXBsZSAmJiAhZGF0YVtjb21wb25lbnQua2V5XS5sZW5ndGgpKVxcXCI+XFxyXFxuICAgIDxkaXYgbmdmLWRyb3A9XFxcInVwbG9hZCgkZmlsZXMpXFxcIiBjbGFzcz1cXFwiZmlsZVNlbGVjdG9yXFxcIiBuZ2YtZHJhZy1vdmVyLWNsYXNzPVxcXCInZmlsZURyYWdPdmVyJ1xcXCIgbmdmLW11bHRpcGxlPVxcXCJjb21wb25lbnQubXVsdGlwbGVcXFwiIGlkPVxcXCJ7eyBjb21wb25lbnRJZCB9fVxcXCIgbmFtZT1cXFwie3sgY29tcG9uZW50SWQgfX1cXFwiPjxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNsb3VkLXVwbG9hZFxcXCI+PC9zcGFuPkRyb3AgZmlsZXMgdG8gYXR0YWNoLCBvciA8YSBzdHlsZT1cXFwiY3Vyc29yOiBwb2ludGVyO1xcXCIgbmdmLXNlbGVjdD1cXFwidXBsb2FkKCRmaWxlcylcXFwiIHRhYmluZGV4PVxcXCJ7eyBjb21wb25lbnQudGFiaW5kZXggfHwgMCB9fVxcXCIgbmdmLW11bHRpcGxlPVxcXCJjb21wb25lbnQubXVsdGlwbGVcXFwiPmJyb3dzZTwvYT4uPC9kaXY+XFxyXFxuICAgIDxkaXYgbmctaWY9XFxcIiFjb21wb25lbnQuc3RvcmFnZVxcXCIgY2xhc3M9XFxcImFsZXJ0IGFsZXJ0LXdhcm5pbmdcXFwiPk5vIHN0b3JhZ2UgaGFzIGJlZW4gc2V0IGZvciB0aGlzIGZpZWxkLiBGaWxlIHVwbG9hZHMgYXJlIGRpc2FibGVkIHVudGlsIHN0b3JhZ2UgaXMgc2V0IHVwLjwvZGl2PlxcclxcbiAgICA8ZGl2IG5nZi1uby1maWxlLWRyb3A+RmlsZSBEcmFnL0Ryb3AgaXMgbm90IHN1cHBvcnRlZCBmb3IgdGhpcyBicm93c2VyPC9kaXY+XFxyXFxuICA8L2Rpdj5cXHJcXG4gIDxkaXYgbmctcmVwZWF0PVxcXCJmaWxlVXBsb2FkIGluIGZpbGVVcGxvYWRzIHRyYWNrIGJ5ICRpbmRleFxcXCIgbmctY2xhc3M9XFxcInsnaGFzLWVycm9yJzogZmlsZVVwbG9hZC5zdGF0dXMgPT09ICdlcnJvcid9XFxcIiBjbGFzcz1cXFwiZmlsZVxcXCI+XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxyXFxuICAgICAgPGRpdiBjbGFzcz1cXFwiZmlsZU5hbWUgY29udHJvbC1sYWJlbCBjb2wtc20tMTBcXFwiPnt7IGZpbGVVcGxvYWQubmFtZSB9fSA8c3BhbiBuZy1jbGljaz1cXFwicmVtb3ZlVXBsb2FkKGZpbGVVcGxvYWQubmFtZSlcXFwiIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLXJlbW92ZVxcXCI+PC9zcGFuPjwvZGl2PlxcclxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImZpbGVTaXplIGNvbnRyb2wtbGFiZWwgY29sLXNtLTIgdGV4dC1yaWdodFxcXCI+e3sgZmlsZVNpemUoZmlsZVVwbG9hZC5zaXplKSB9fTwvZGl2PlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXHJcXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtc20tMTJcXFwiPlxcclxcbiAgICAgICAgPHNwYW4gbmctaWY9XFxcImZpbGVVcGxvYWQuc3RhdHVzID09PSAncHJvZ3Jlc3MnXFxcIj5cXHJcXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwicHJvZ3Jlc3NcXFwiPlxcclxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInByb2dyZXNzLWJhclxcXCIgcm9sZT1cXFwicHJvZ3Jlc3NiYXJcXFwiIGFyaWEtdmFsdWVub3c9XFxcInt7ZmlsZVVwbG9hZC5wcm9ncmVzc319XFxcIiBhcmlhLXZhbHVlbWluPVxcXCIwXFxcIiBhcmlhLXZhbHVlbWF4PVxcXCIxMDBcXFwiIHN0eWxlPVxcXCJ3aWR0aDp7e2ZpbGVVcGxvYWQucHJvZ3Jlc3N9fSVcXFwiPlxcclxcbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNyLW9ubHlcXFwiPnt7ZmlsZVVwbG9hZC5wcm9ncmVzc319JSBDb21wbGV0ZTwvc3Bhbj5cXHJcXG4gICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8L3NwYW4+XFxyXFxuICAgICAgICA8ZGl2IG5nLWlmPVxcXCIhZmlsZVVwbG9hZC5zdGF0dXMgIT09ICdwcm9ncmVzcydcXFwiIGNsYXNzPVxcXCJiZy17eyBmaWxlVXBsb2FkLnN0YXR1cyB9fSBjb250cm9sLWxhYmVsXFxcIj57eyBmaWxlVXBsb2FkLm1lc3NhZ2UgfX08L2Rpdj5cXHJcXG4gICAgICA8L2Rpdj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICA8L2Rpdj5cXHJcXG48L2Rpdj5cXHJcXG5cIlxyXG4gICAgICApO1xyXG5cclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50c1ZpZXcvZmlsZS5odG1sJyxcclxuICAgICAgICBcIjxsYWJlbCBuZy1pZj1cXFwiY29tcG9uZW50LmxhYmVsICYmICFjb21wb25lbnQuaGlkZUxhYmVsXFxcIiBmb3I9XFxcInt7IGNvbXBvbmVudC5rZXkgfX1cXFwiIGNsYXNzPVxcXCJjb250cm9sLWxhYmVsXFxcIiBuZy1jbGFzcz1cXFwieydmaWVsZC1yZXF1aXJlZCc6IGNvbXBvbmVudC52YWxpZGF0ZS5yZXF1aXJlZH1cXFwiPnt7IGNvbXBvbmVudC5sYWJlbCB8IGZvcm1pb1RyYW5zbGF0ZTpudWxsOmJ1aWxkZXIgfX08L2xhYmVsPlxcclxcbjxkaXYgbmctY29udHJvbGxlcj1cXFwiZm9ybWlvRmlsZVVwbG9hZFxcXCI+XFxyXFxuICA8Zm9ybWlvLWZpbGUtbGlzdCBmaWxlcz1cXFwiZGF0YVtjb21wb25lbnQua2V5XVxcXCIgZm9ybT1cXFwiZm9ybVVybFxcXCIgcmVhZC1vbmx5PVxcXCJ0cnVlXFxcIiBuZy1pZj1cXFwiIWNvbXBvbmVudC5pbWFnZVxcXCI+PC9mb3JtaW8tZmlsZS1saXN0PlxcclxcbiAgPGZvcm1pby1pbWFnZS1saXN0IGZpbGVzPVxcXCJkYXRhW2NvbXBvbmVudC5rZXldXFxcIiBmb3JtPVxcXCJmb3JtVXJsXFxcIiByZWFkLW9ubHk9XFxcInRydWVcXFwiIHdpZHRoPVxcXCJjb21wb25lbnQuaW1hZ2VTaXplXFxcIiBuZy1pZj1cXFwiY29tcG9uZW50LmltYWdlXFxcIj48L2Zvcm1pby1pbWFnZS1saXN0PlxcclxcbjwvZGl2PlxcclxcblwiXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgXSk7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xuXHJcbnZhciBHcmlkVXRpbHMgPSByZXF1aXJlKCcuLi9mYWN0b3JpZXMvR3JpZFV0aWxzJykoKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBwKSB7XHJcbiAgYXBwLmNvbmZpZyhbXHJcbiAgICAnZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyJyxcclxuICAgIGZ1bmN0aW9uKGZvcm1pb0NvbXBvbmVudHNQcm92aWRlcikge1xyXG4gICAgICBmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIucmVnaXN0ZXIoJ2hpZGRlbicsIHtcclxuICAgICAgICB0aXRsZTogJ0hpZGRlbicsXHJcbiAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9oaWRkZW4uaHRtbCcsXHJcbiAgICAgICAgZ3JvdXA6ICdhZHZhbmNlZCcsXHJcbiAgICAgICAgc2V0dGluZ3M6IHtcclxuICAgICAgICAgIGlucHV0OiB0cnVlLFxyXG4gICAgICAgICAgdGFibGVWaWV3OiB0cnVlLFxyXG4gICAgICAgICAga2V5OiAnaGlkZGVuRmllbGQnLFxyXG4gICAgICAgICAgbGFiZWw6ICcnLFxyXG4gICAgICAgICAgcHJvdGVjdGVkOiBmYWxzZSxcclxuICAgICAgICAgIHVuaXF1ZTogZmFsc2UsXHJcbiAgICAgICAgICBwZXJzaXN0ZW50OiB0cnVlXHJcbiAgICAgICAgfSxcclxuICAgICAgICB0YWJsZVZpZXc6IEdyaWRVdGlscy5nZW5lcmljXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIF0pO1xyXG4gIGFwcC5ydW4oW1xyXG4gICAgJyR0ZW1wbGF0ZUNhY2hlJyxcclxuICAgIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvaGlkZGVuLmh0bWwnLFxyXG4gICAgICAgIFwiPGlucHV0IHR5cGU9XFxcImhpZGRlblxcXCIgaWQ9XFxcInt7IGNvbXBvbmVudElkIH19XFxcIiBuYW1lPVxcXCJ7eyBjb21wb25lbnRJZCB9fVxcXCIgbmctbW9kZWw9XFxcImRhdGFbY29tcG9uZW50LmtleV1cXFwiPlxcclxcblwiXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgXSk7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFwcCkge1xyXG4gIGFwcC5kaXJlY3RpdmUoJ2Zvcm1pb0h0bWxFbGVtZW50JywgW1xyXG4gICAgJyRzYW5pdGl6ZScsXHJcbiAgICAnJGZpbHRlcicsXHJcbiAgICBmdW5jdGlvbigkc2FuaXRpemUsICRmaWx0ZXIpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHNjb3BlOiB7XHJcbiAgICAgICAgICBjb21wb25lbnQ6ICc9J1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdGVtcGxhdGVVcmw6ICdmb3JtaW8vY29tcG9uZW50cy9odG1sZWxlbWVudC1kaXJlY3RpdmUuaHRtbCcsXHJcbiAgICAgICAgbGluazogZnVuY3Rpb24oJHNjb3BlKSB7XHJcbiAgICAgICAgICBpZiAoJHNjb3BlLmJ1aWxkZXIpIHJldHVybjtcclxuICAgICAgICAgIHZhciBkaXNwbGF5RXJyb3IgPSBmdW5jdGlvbihtc2cpIHtcclxuICAgICAgICAgICAgJHNjb3BlLnBhcnNlRXJyb3IgPSAnSW52YWxpZCBIVE1MOiAnICsgbXNnLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICRzY29wZS4kd2F0Y2goJ2NvbXBvbmVudCcsIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQoKSB7XHJcbiAgICAgICAgICAgIGlmICghJHNjb3BlLmNvbXBvbmVudC50YWcpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gZGlzcGxheUVycm9yKCdObyB0YWcgZ2l2ZW4nKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBhbmd1bGFyLmVsZW1lbnQoJzwnICsgJHNjb3BlLmNvbXBvbmVudC50YWcgKyAnPicgKyAnPC8nICsgJHNjb3BlLmNvbXBvbmVudC50YWcgKyAnPicpO1xyXG4gICAgICAgICAgICBlbGVtZW50Lmh0bWwoJGZpbHRlcignZm9ybWlvVHJhbnNsYXRlJykoJHNjb3BlLmNvbXBvbmVudC5jb250ZW50KSk7XHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgdGhlIGNzcyBjbGFzc2VzIGlmIHN1cHBsaWVkLlxyXG4gICAgICAgICAgICBpZiAoJHNjb3BlLmNvbXBvbmVudC5jbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgICBlbGVtZW50LmF0dHIoJ2NsYXNzJywgJHNjb3BlLmNvbXBvbmVudC5jbGFzc05hbWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goJHNjb3BlLmNvbXBvbmVudC5hdHRycywgZnVuY3Rpb24oYXR0cikge1xyXG4gICAgICAgICAgICAgIGlmICghYXR0ci5hdHRyKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgZWxlbWVudC5hdHRyKGF0dHIuYXR0ciwgYXR0ci52YWx1ZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAkc2NvcGUuaHRtbCA9ICRzYW5pdGl6ZShlbGVtZW50LnByb3AoJ291dGVySFRNTCcpKTtcclxuICAgICAgICAgICAgICAkc2NvcGUucGFyc2VFcnJvciA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgIC8vIElmIHRoZSBzYW5pdGl6ZWQgaHRtbCBpcyBlbXB0eSwgaXQgd2FzIGludmFsaWQ7IENyZWF0ZSBhIHZpc2libGUgZXJyb3Igc28gd2Ugc3RpbGwgcmVuZGVyIHNvbWV0aGluZy5cclxuICAgICAgICAgICAgICBpZiAoISRzY29wZS5odG1sKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlzcGxheUVycm9yKGVsZW1lbnQucHJvcCgnb3V0ZXJIVE1MJykpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgLy8gSXNvbGF0ZSB0aGUgbWVzc2FnZSBhbmQgc3RvcmUgaXQuXHJcbiAgICAgICAgICAgICAgJHNjb3BlLnBhcnNlRXJyb3IgPSBlcnIubWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgLnNwbGl0KCdcXG4nKVswXVxyXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoJ1skc2FuaXRpemU6YmFkcGFyc2VdJywgJycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9LCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgfV0pO1xyXG5cclxuICBhcHAuY29uZmlnKFtcclxuICAgICdmb3JtaW9Db21wb25lbnRzUHJvdmlkZXInLFxyXG4gICAgZnVuY3Rpb24oZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyKSB7XHJcbiAgICAgIGZvcm1pb0NvbXBvbmVudHNQcm92aWRlci5yZWdpc3RlcignaHRtbGVsZW1lbnQnLCB7XHJcbiAgICAgICAgdGl0bGU6ICdIVE1MIEVsZW1lbnQnLFxyXG4gICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvaHRtbGVsZW1lbnQuaHRtbCcsXHJcbiAgICAgICAgdmlld1RlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvaHRtbGVsZW1lbnQuaHRtbCcsXHJcbiAgICAgICAgc2V0dGluZ3M6IHtcclxuICAgICAgICAgIGtleTogJ2h0bWwnLFxyXG4gICAgICAgICAgaW5wdXQ6IGZhbHNlLFxyXG4gICAgICAgICAgdGFnOiAncCcsXHJcbiAgICAgICAgICBhdHRyczogW10sXHJcbiAgICAgICAgICBjbGFzc05hbWU6ICcnLFxyXG4gICAgICAgICAgY29udGVudDogJydcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIF0pO1xyXG5cclxuICBhcHAucnVuKFtcclxuICAgICckdGVtcGxhdGVDYWNoZScsXHJcbiAgICBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL2h0bWxlbGVtZW50Lmh0bWwnLFxyXG4gICAgICAgICc8Zm9ybWlvLWh0bWwtZWxlbWVudCBjb21wb25lbnQ9XCJjb21wb25lbnRcIj48L2Rpdj4nXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL2h0bWxlbGVtZW50LWRpcmVjdGl2ZS5odG1sJyxcclxuICAgICAgICBcIjxkaXYgaWQ9XFxcInt7IGNvbXBvbmVudC5rZXkgfX1cXFwiPlxcclxcbiAgPGRpdiBjbGFzcz1cXFwiYWxlcnQgYWxlcnQtd2FybmluZ1xcXCIgbmctaWY9XFxcInBhcnNlRXJyb3JcXFwiPnt7IHBhcnNlRXJyb3IgfX08L2Rpdj5cXHJcXG4gIDxkaXYgbmctYmluZC1odG1sPVxcXCJodG1sXFxcIj48L2Rpdj5cXHJcXG48L2Rpdj5cXHJcXG5cIlxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIF0pO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBhcHAgPSBhbmd1bGFyLm1vZHVsZSgnZm9ybWlvJyk7XHJcblxyXG4vLyBCYXNpY1xyXG5yZXF1aXJlKCcuL2NvbXBvbmVudHMnKShhcHApO1xyXG5yZXF1aXJlKCcuL3RleHRmaWVsZCcpKGFwcCk7XHJcbnJlcXVpcmUoJy4vbnVtYmVyJykoYXBwKTtcclxucmVxdWlyZSgnLi9wYXNzd29yZCcpKGFwcCk7XHJcbnJlcXVpcmUoJy4vdGV4dGFyZWEnKShhcHApO1xyXG5yZXF1aXJlKCcuL2NoZWNrYm94JykoYXBwKTtcclxucmVxdWlyZSgnLi9zZWxlY3Rib3hlcycpKGFwcCk7XHJcbnJlcXVpcmUoJy4vc2VsZWN0JykoYXBwKTtcclxucmVxdWlyZSgnLi9yYWRpbycpKGFwcCk7XHJcbnJlcXVpcmUoJy4vaHRtbGVsZW1lbnQnKShhcHApO1xyXG5yZXF1aXJlKCcuL2NvbnRlbnQnKShhcHApO1xyXG5yZXF1aXJlKCcuL2J1dHRvbicpKGFwcCk7XHJcblxyXG4vLyBTcGVjaWFsXHJcbnJlcXVpcmUoJy4vZW1haWwnKShhcHApO1xyXG5yZXF1aXJlKCcuL3Bob25lbnVtYmVyJykoYXBwKTtcclxucmVxdWlyZSgnLi9hZGRyZXNzJykoYXBwKTtcclxucmVxdWlyZSgnLi9kYXRldGltZScpKGFwcCk7XHJcbnJlcXVpcmUoJy4vZGF5JykoYXBwKTtcclxucmVxdWlyZSgnLi9jdXJyZW5jeScpKGFwcCk7XHJcbnJlcXVpcmUoJy4vaGlkZGVuJykoYXBwKTtcclxucmVxdWlyZSgnLi9yZXNvdXJjZScpKGFwcCk7XHJcbnJlcXVpcmUoJy4vZmlsZScpKGFwcCk7XHJcbnJlcXVpcmUoJy4vc2lnbmF0dXJlJykoYXBwKTtcclxucmVxdWlyZSgnLi9jdXN0b20nKShhcHApO1xyXG5yZXF1aXJlKCcuL2NvbnRhaW5lcicpKGFwcCk7XHJcbnJlcXVpcmUoJy4vZGF0YWdyaWQnKShhcHApO1xyXG5yZXF1aXJlKCcuL3N1cnZleScpKGFwcCk7XHJcblxyXG4vLyBMYXlvdXRcclxucmVxdWlyZSgnLi9jb2x1bW5zJykoYXBwKTtcclxucmVxdWlyZSgnLi9maWVsZHNldCcpKGFwcCk7XHJcbnJlcXVpcmUoJy4vcGFnZScpKGFwcCk7XHJcbnJlcXVpcmUoJy4vcGFuZWwnKShhcHApO1xyXG5yZXF1aXJlKCcuL3RhYmxlJykoYXBwKTtcclxucmVxdWlyZSgnLi93ZWxsJykoYXBwKTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBwKSB7XHJcbiAgYXBwLmNvbmZpZyhbXHJcbiAgICAnZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyJyxcclxuICAgIGZ1bmN0aW9uKGZvcm1pb0NvbXBvbmVudHNQcm92aWRlcikge1xyXG4gICAgICB2YXIgaXNOdW1lcmljID0gZnVuY3Rpb24gaXNOdW1lcmljKG4pIHtcclxuICAgICAgICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xyXG4gICAgICB9O1xyXG4gICAgICBmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIucmVnaXN0ZXIoJ251bWJlcicsIHtcclxuICAgICAgICB0aXRsZTogJ051bWJlcicsXHJcbiAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9udW1iZXIuaHRtbCcsXHJcbiAgICAgICAgc2V0dGluZ3M6IHtcclxuICAgICAgICAgIGlucHV0OiB0cnVlLFxyXG4gICAgICAgICAgdGFibGVWaWV3OiB0cnVlLFxyXG4gICAgICAgICAgaW5wdXRUeXBlOiAnbnVtYmVyJyxcclxuICAgICAgICAgIGxhYmVsOiAnJyxcclxuICAgICAgICAgIGtleTogJ251bWJlckZpZWxkJyxcclxuICAgICAgICAgIHBsYWNlaG9sZGVyOiAnJyxcclxuICAgICAgICAgIHByZWZpeDogJycsXHJcbiAgICAgICAgICBzdWZmaXg6ICcnLFxyXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiAnJyxcclxuICAgICAgICAgIHByb3RlY3RlZDogZmFsc2UsXHJcbiAgICAgICAgICBwZXJzaXN0ZW50OiB0cnVlLFxyXG4gICAgICAgICAgaGlkZGVuOiBmYWxzZSxcclxuICAgICAgICAgIGNsZWFyT25IaWRlOiB0cnVlLFxyXG4gICAgICAgICAgdmFsaWRhdGU6IHtcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBtaW46ICcnLFxyXG4gICAgICAgICAgICBtYXg6ICcnLFxyXG4gICAgICAgICAgICBzdGVwOiAnYW55JyxcclxuICAgICAgICAgICAgaW50ZWdlcjogJycsXHJcbiAgICAgICAgICAgIG11bHRpcGxlOiAnJyxcclxuICAgICAgICAgICAgY3VzdG9tOiAnJ1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29udHJvbGxlcjogWyckc2NvcGUnLCBmdW5jdGlvbigkc2NvcGUpIHtcclxuICAgICAgICAgIGlmICgkc2NvcGUuYnVpbGRlcikgcmV0dXJuOyAvLyBGT1ItNzEgLSBTa2lwIHBhcnNpbmcgaW5wdXQgZGF0YS5cclxuXHJcbiAgICAgICAgICAvLyBFbnN1cmUgdGhhdCB2YWx1ZXMgYXJlIG51bWJlcnMuXHJcbiAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICRzY29wZS5kYXRhICYmXHJcbiAgICAgICAgICAgICRzY29wZS5kYXRhLmhhc093blByb3BlcnR5KCRzY29wZS5jb21wb25lbnQua2V5KSAmJlxyXG4gICAgICAgICAgICBpc051bWVyaWMoJHNjb3BlLmRhdGFbJHNjb3BlLmNvbXBvbmVudC5rZXldKVxyXG4gICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSA9IHBhcnNlRmxvYXQoJHNjb3BlLmRhdGFbJHNjb3BlLmNvbXBvbmVudC5rZXldKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICBdKTtcclxuXHJcbiAgYXBwLnJ1bihbXHJcbiAgICAnJHRlbXBsYXRlQ2FjaGUnLFxyXG4gICAgJ0Zvcm1pb1V0aWxzJyxcclxuICAgIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlLCBGb3JtaW9VdGlscykge1xyXG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL251bWJlci5odG1sJywgRm9ybWlvVXRpbHMuZmllbGRXcmFwKFxyXG4gICAgICAgIFwiPGlucHV0XFxyXFxuICB0eXBlPVxcXCJ7eyBjb21wb25lbnQuaW5wdXRUeXBlIH19XFxcIlxcclxcbiAgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCJcXHJcXG4gIGlkPVxcXCJ7eyBjb21wb25lbnRJZCB9fVxcXCJcXHJcXG4gIG5hbWU9XFxcInt7IGNvbXBvbmVudElkIH19XFxcIlxcclxcbiAgdGFiaW5kZXg9XFxcInt7IGNvbXBvbmVudC50YWJpbmRleCB8fCAwIH19XFxcIlxcclxcbiAgbmctbW9kZWw9XFxcImRhdGFbY29tcG9uZW50LmtleV1cXFwiXFxyXFxuICBuZy1yZXF1aXJlZD1cXFwiaXNSZXF1aXJlZChjb21wb25lbnQpXFxcIlxcclxcbiAgbmctZGlzYWJsZWQ9XFxcInJlYWRPbmx5XFxcIlxcclxcbiAgc2FmZS1tdWx0aXBsZS10by1zaW5nbGVcXHJcXG4gIG1pbj1cXFwie3sgY29tcG9uZW50LnZhbGlkYXRlLm1pbiB9fVxcXCJcXHJcXG4gIG1heD1cXFwie3sgY29tcG9uZW50LnZhbGlkYXRlLm1heCB9fVxcXCJcXHJcXG4gIHN0ZXA9XFxcInt7IGNvbXBvbmVudC52YWxpZGF0ZS5zdGVwIH19XFxcIlxcclxcbiAgbmctYXR0ci1wbGFjZWhvbGRlcj1cXFwie3sgY29tcG9uZW50LnBsYWNlaG9sZGVyIHwgZm9ybWlvVHJhbnNsYXRlOm51bGw6YnVpbGRlciB9fVxcXCJcXHJcXG4gIGN1c3RvbS12YWxpZGF0b3I9XFxcImNvbXBvbmVudC52YWxpZGF0ZS5jdXN0b21cXFwiXFxyXFxuICB1aS1tYXNrPVxcXCJ7eyBjb21wb25lbnQuaW5wdXRNYXNrIH19XFxcIlxcclxcbiAgdWktbWFzay1wbGFjZWhvbGRlcj1cXFwiXFxcIlxcclxcbiAgdWktb3B0aW9ucz1cXFwidWlNYXNrT3B0aW9uc1xcXCJcXHJcXG4+XFxyXFxuXCJcclxuICAgICAgKSk7XHJcbiAgICB9XHJcbiAgXSk7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBwKSB7XHJcbiAgYXBwLmNvbmZpZyhbXHJcbiAgICAnZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyJyxcclxuICAgIGZ1bmN0aW9uKGZvcm1pb0NvbXBvbmVudHNQcm92aWRlcikge1xyXG4gICAgICBmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIucmVnaXN0ZXIoJ3BhZ2UnLCB7XHJcbiAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9wYWdlLmh0bWwnLFxyXG4gICAgICAgIHNldHRpbmdzOiB7XHJcbiAgICAgICAgICBrZXk6ICdwYWdlJyxcclxuICAgICAgICAgIGlucHV0OiBmYWxzZSxcclxuICAgICAgICAgIGNvbXBvbmVudHM6IFtdXHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICBdKTtcclxuICBhcHAucnVuKFtcclxuICAgICckdGVtcGxhdGVDYWNoZScsXHJcbiAgICBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL3BhZ2UuaHRtbCcsXHJcbiAgICAgICAgXCI8Zm9ybWlvLWNvbXBvbmVudFxcclxcbiAgbmctcmVwZWF0PVxcXCJfY29tcG9uZW50IGluIGNvbXBvbmVudC5jb21wb25lbnRzIHRyYWNrIGJ5ICRpbmRleFxcXCJcXHJcXG4gIGNvbXBvbmVudD1cXFwiX2NvbXBvbmVudFxcXCJcXHJcXG4gIGRhdGE9XFxcImRhdGFcXFwiXFxyXFxuICBmb3JtaW89XFxcImZvcm1pb1xcXCJcXHJcXG4gIHN1Ym1pc3Npb249XFxcInN1Ym1pc3Npb25cXFwiXFxyXFxuICBoaWRlLWNvbXBvbmVudHM9XFxcImhpZGVDb21wb25lbnRzXFxcIlxcclxcbiAgbmctaWY9XFxcImJ1aWxkZXIgPyAnOjp0cnVlJyA6IGlzVmlzaWJsZShfY29tcG9uZW50LCBkYXRhKVxcXCJcXHJcXG4gIHJlYWQtb25seT1cXFwiaXNEaXNhYmxlZChfY29tcG9uZW50LCBkYXRhKVxcXCJcXHJcXG4gIGZvcm1pby1mb3JtPVxcXCJmb3JtaW9Gb3JtXFxcIlxcclxcbiAgZ3JpZC1yb3c9XFxcImdyaWRSb3dcXFwiXFxyXFxuICBncmlkLWNvbD1cXFwiZ3JpZENvbFxcXCJcXHJcXG4gIGJ1aWxkZXI9XFxcImJ1aWxkZXJcXFwiXFxyXFxuPjwvZm9ybWlvLWNvbXBvbmVudD5cXHJcXG5cIlxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIF0pO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFwcCkge1xyXG4gIGFwcC5jb25maWcoW1xyXG4gICAgJ2Zvcm1pb0NvbXBvbmVudHNQcm92aWRlcicsXHJcbiAgICBmdW5jdGlvbihmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIpIHtcclxuICAgICAgZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyLnJlZ2lzdGVyKCdwYW5lbCcsIHtcclxuICAgICAgICB0aXRsZTogJ1BhbmVsJyxcclxuICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL3BhbmVsLmh0bWwnLFxyXG4gICAgICAgIGdyb3VwOiAnbGF5b3V0JyxcclxuICAgICAgICBzZXR0aW5nczoge1xyXG4gICAgICAgICAga2V5OiAncGFuZWwnLFxyXG4gICAgICAgICAgaW5wdXQ6IGZhbHNlLFxyXG4gICAgICAgICAgdGl0bGU6ICcnLFxyXG4gICAgICAgICAgdGhlbWU6ICdkZWZhdWx0JyxcclxuICAgICAgICAgIGNvbXBvbmVudHM6IFtdXHJcbiAgICAgICAgfSxcclxuICAgICAgICB2aWV3VGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50c1ZpZXcvcGFuZWwuaHRtbCdcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgXSk7XHJcbiAgYXBwLnJ1bihbXHJcbiAgICAnJHRlbXBsYXRlQ2FjaGUnLFxyXG4gICAgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9wYW5lbC5odG1sJyxcclxuICAgICAgICBcIjxkaXYgY2xhc3M9XFxcInBhbmVsIHBhbmVsLXt7IGNvbXBvbmVudC50aGVtZSB9fVxcXCIgaWQ9XFxcInt7IGNvbXBvbmVudC5rZXkgfX1cXFwiPlxcclxcbiAgPGRpdiBuZy1pZj1cXFwiY29tcG9uZW50LnRpdGxlXFxcIiBjbGFzcz1cXFwicGFuZWwtaGVhZGluZ1xcXCI+XFxyXFxuICAgIDxoMyBjbGFzcz1cXFwicGFuZWwtdGl0bGVcXFwiPnt7IGNvbXBvbmVudC50aXRsZSB8IGZvcm1pb1RyYW5zbGF0ZTpudWxsOmJ1aWxkZXIgfX08L2gzPlxcclxcbiAgPC9kaXY+XFxyXFxuICA8ZGl2IGNsYXNzPVxcXCJwYW5lbC1ib2R5XFxcIj5cXHJcXG4gICAgPGZvcm1pby1jb21wb25lbnRcXHJcXG4gICAgICBuZy1yZXBlYXQ9XFxcIl9jb21wb25lbnQgaW4gY29tcG9uZW50LmNvbXBvbmVudHMgdHJhY2sgYnkgJGluZGV4XFxcIlxcclxcbiAgICAgIGNvbXBvbmVudD1cXFwiX2NvbXBvbmVudFxcXCJcXHJcXG4gICAgICBkYXRhPVxcXCJkYXRhXFxcIlxcclxcbiAgICAgIGZvcm1pbz1cXFwiZm9ybWlvXFxcIlxcclxcbiAgICAgIHN1Ym1pc3Npb249XFxcInN1Ym1pc3Npb25cXFwiXFxyXFxuICAgICAgaGlkZS1jb21wb25lbnRzPVxcXCJoaWRlQ29tcG9uZW50c1xcXCJcXHJcXG4gICAgICBuZy1pZj1cXFwiYnVpbGRlciA/ICc6OnRydWUnIDogaXNWaXNpYmxlKF9jb21wb25lbnQsIGRhdGEpXFxcIlxcclxcbiAgICAgIHJlYWQtb25seT1cXFwiaXNEaXNhYmxlZChfY29tcG9uZW50LCBkYXRhKVxcXCJcXHJcXG4gICAgICBmb3JtaW8tZm9ybT1cXFwiZm9ybWlvRm9ybVxcXCJcXHJcXG4gICAgICBncmlkLXJvdz1cXFwiZ3JpZFJvd1xcXCJcXHJcXG4gICAgICBncmlkLWNvbD1cXFwiZ3JpZENvbFxcXCJcXHJcXG4gICAgICBidWlsZGVyPVxcXCJidWlsZGVyXFxcIlxcclxcbiAgICA+PC9mb3JtaW8tY29tcG9uZW50PlxcclxcbiAgPC9kaXY+XFxyXFxuPC9kaXY+XFxyXFxuXCJcclxuICAgICAgKTtcclxuXHJcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHNWaWV3L3BhbmVsLmh0bWwnLFxyXG4gICAgICAgIFwiPGRpdiBjbGFzcz1cXFwicGFuZWwgcGFuZWwte3sgY29tcG9uZW50LnRoZW1lIH19XFxcIiBpZD1cXFwie3sgY29tcG9uZW50LmtleSB9fVxcXCI+XFxyXFxuICA8ZGl2IG5nLWlmPVxcXCJjb21wb25lbnQudGl0bGVcXFwiIGNsYXNzPVxcXCJwYW5lbC1oZWFkaW5nXFxcIj5cXHJcXG4gICAgPGgzIGNsYXNzPVxcXCJwYW5lbC10aXRsZVxcXCI+e3sgY29tcG9uZW50LnRpdGxlIH19PC9oMz5cXHJcXG4gIDwvZGl2PlxcclxcbiAgPGRpdiBjbGFzcz1cXFwicGFuZWwtYm9keVxcXCI+XFxyXFxuICAgIDxmb3JtaW8tY29tcG9uZW50LXZpZXdcXHJcXG4gICAgICBuZy1yZXBlYXQ9XFxcIl9jb21wb25lbnQgaW4gY29tcG9uZW50LmNvbXBvbmVudHMgdHJhY2sgYnkgJGluZGV4XFxcIlxcclxcbiAgICAgIGNvbXBvbmVudD1cXFwiX2NvbXBvbmVudFxcXCJcXHJcXG4gICAgICBkYXRhPVxcXCJkYXRhXFxcIlxcclxcbiAgICAgIHN1Ym1pc3Npb249XFxcInN1Ym1pc3Npb25cXFwiXFxyXFxuICAgICAgZm9ybT1cXFwiZm9ybVxcXCJcXHJcXG4gICAgICBpZ25vcmU9XFxcImlnbm9yZVxcXCJcXHJcXG4gICAgICBuZy1pZj1cXFwiYnVpbGRlciA/ICc6OnRydWUnIDogaXNWaXNpYmxlKF9jb21wb25lbnQsIGRhdGEpXFxcIlxcclxcbiAgICAgIGJ1aWxkZXI9XFxcImJ1aWxkZXJcXFwiXFxyXFxuICAgID48L2Zvcm1pby1jb21wb25lbnQtdmlldz5cXHJcXG4gIDwvZGl2PlxcclxcbjwvZGl2PlxcclxcblwiXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgXSk7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcHApIHtcclxuICBhcHAuY29uZmlnKFtcclxuICAgICdmb3JtaW9Db21wb25lbnRzUHJvdmlkZXInLFxyXG4gICAgZnVuY3Rpb24oZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyKSB7XHJcbiAgICAgIGZvcm1pb0NvbXBvbmVudHNQcm92aWRlci5yZWdpc3RlcigncGFzc3dvcmQnLCB7XHJcbiAgICAgICAgdGl0bGU6ICdQYXNzd29yZCcsXHJcbiAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy90ZXh0ZmllbGQuaHRtbCcsXHJcbiAgICAgICAgdGFibGVWaWV3OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHJldHVybiAnLS0tIFBST1RFQ1RFRCAtLS0nO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0dGluZ3M6IHtcclxuICAgICAgICAgIGlucHV0OiB0cnVlLFxyXG4gICAgICAgICAgdGFibGVWaWV3OiBmYWxzZSxcclxuICAgICAgICAgIGlucHV0VHlwZTogJ3Bhc3N3b3JkJyxcclxuICAgICAgICAgIGxhYmVsOiAnJyxcclxuICAgICAgICAgIGtleTogJ3Bhc3N3b3JkRmllbGQnLFxyXG4gICAgICAgICAgcGxhY2Vob2xkZXI6ICcnLFxyXG4gICAgICAgICAgcHJlZml4OiAnJyxcclxuICAgICAgICAgIHN1ZmZpeDogJycsXHJcbiAgICAgICAgICBwcm90ZWN0ZWQ6IHRydWUsXHJcbiAgICAgICAgICBwZXJzaXN0ZW50OiB0cnVlLFxyXG4gICAgICAgICAgaGlkZGVuOiBmYWxzZSxcclxuICAgICAgICAgIGNsZWFyT25IaWRlOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICBdKTtcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFwcCkge1xyXG4gIGFwcC5jb25maWcoW1xyXG4gICAgJ2Zvcm1pb0NvbXBvbmVudHNQcm92aWRlcicsXHJcbiAgICBmdW5jdGlvbihmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIpIHtcclxuICAgICAgZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyLnJlZ2lzdGVyKCdwaG9uZU51bWJlcicsIHtcclxuICAgICAgICB0aXRsZTogJ1Bob25lIE51bWJlcicsXHJcbiAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy90ZXh0ZmllbGQuaHRtbCcsXHJcbiAgICAgICAgZ3JvdXA6ICdhZHZhbmNlZCcsXHJcbiAgICAgICAgc2V0dGluZ3M6IHtcclxuICAgICAgICAgIGlucHV0OiB0cnVlLFxyXG4gICAgICAgICAgdGFibGVWaWV3OiB0cnVlLFxyXG4gICAgICAgICAgaW5wdXRNYXNrOiAnKDk5OSkgOTk5LTk5OTknLFxyXG4gICAgICAgICAgbGFiZWw6ICcnLFxyXG4gICAgICAgICAga2V5OiAncGhvbmVudW1iZXJGaWVsZCcsXHJcbiAgICAgICAgICBwbGFjZWhvbGRlcjogJycsXHJcbiAgICAgICAgICBwcmVmaXg6ICcnLFxyXG4gICAgICAgICAgc3VmZml4OiAnJyxcclxuICAgICAgICAgIG11bHRpcGxlOiBmYWxzZSxcclxuICAgICAgICAgIHByb3RlY3RlZDogZmFsc2UsXHJcbiAgICAgICAgICB1bmlxdWU6IGZhbHNlLFxyXG4gICAgICAgICAgcGVyc2lzdGVudDogdHJ1ZSxcclxuICAgICAgICAgIGhpZGRlbjogZmFsc2UsXHJcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6ICcnLFxyXG4gICAgICAgICAgY2xlYXJPbkhpZGU6IHRydWUsXHJcbiAgICAgICAgICB2YWxpZGF0ZToge1xyXG4gICAgICAgICAgICByZXF1aXJlZDogZmFsc2VcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIF0pO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcHApIHtcclxuICBhcHAuY29uZmlnKFtcclxuICAgICdmb3JtaW9Db21wb25lbnRzUHJvdmlkZXInLFxyXG4gICAgZnVuY3Rpb24oZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyKSB7XHJcbiAgICAgIGZvcm1pb0NvbXBvbmVudHNQcm92aWRlci5yZWdpc3RlcigncmFkaW8nLCB7XHJcbiAgICAgICAgdGl0bGU6ICdSYWRpbycsXHJcbiAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9yYWRpby5odG1sJyxcclxuICAgICAgICB0YWJsZVZpZXc6IGZ1bmN0aW9uKGRhdGEsIGNvbXBvbmVudCkge1xyXG4gICAgICAgICAgZm9yICh2YXIgaSBpbiBjb21wb25lbnQudmFsdWVzKSB7XHJcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQudmFsdWVzW2ldLnZhbHVlID09PSBkYXRhKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudC52YWx1ZXNbaV0ubGFiZWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0dGluZ3M6IHtcclxuICAgICAgICAgIGlucHV0OiB0cnVlLFxyXG4gICAgICAgICAgdGFibGVWaWV3OiB0cnVlLFxyXG4gICAgICAgICAgaW5wdXRUeXBlOiAncmFkaW8nLFxyXG4gICAgICAgICAgbGFiZWw6ICcnLFxyXG4gICAgICAgICAga2V5OiAncmFkaW9GaWVsZCcsXHJcbiAgICAgICAgICB2YWx1ZXM6IFtdLFxyXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiAnJyxcclxuICAgICAgICAgIHByb3RlY3RlZDogZmFsc2UsXHJcbiAgICAgICAgICBwZXJzaXN0ZW50OiB0cnVlLFxyXG4gICAgICAgICAgaGlkZGVuOiBmYWxzZSxcclxuICAgICAgICAgIGNsZWFyT25IaWRlOiB0cnVlLFxyXG4gICAgICAgICAgdmFsaWRhdGU6IHtcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBjdXN0b206ICcnLFxyXG4gICAgICAgICAgICBjdXN0b21Qcml2YXRlOiBmYWxzZVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgXSk7XHJcbiAgYXBwLnJ1bihbXHJcbiAgICAnJHRlbXBsYXRlQ2FjaGUnLFxyXG4gICAgJ0Zvcm1pb1V0aWxzJyxcclxuICAgIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlLCBGb3JtaW9VdGlscykge1xyXG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL3JhZGlvLmh0bWwnLCBGb3JtaW9VdGlscy5maWVsZFdyYXAoXHJcbiAgICAgICAgXCI8bmctZm9ybSBuYW1lPVxcXCJ7eyBjb21wb25lbnRJZCB9fVxcXCIgbmctbW9kZWw9XFxcImRhdGFbY29tcG9uZW50LmtleV1cXFwiIGN1c3RvbS12YWxpZGF0b3I9XFxcImNvbXBvbmVudC52YWxpZGF0ZS5jdXN0b21cXFwiPlxcclxcbiAgPGRpdiBuZy1jbGFzcz1cXFwiY29tcG9uZW50LmlubGluZSA/ICdyYWRpby1pbmxpbmUnIDogJ3JhZGlvJ1xcXCIgbmctcmVwZWF0PVxcXCJ2IGluIGNvbXBvbmVudC52YWx1ZXMgdHJhY2sgYnkgJGluZGV4XFxcIj5cXHJcXG4gICAgPGxhYmVsIGNsYXNzPVxcXCJjb250cm9sLWxhYmVsXFxcIiBmb3I9XFxcInt7IGNvbXBvbmVudElkIH19LXt7IHYudmFsdWUgfX1cXFwiPlxcclxcbiAgICAgIDxpbnB1dFxcclxcbiAgICAgICAgdHlwZT1cXFwie3sgY29tcG9uZW50LmlucHV0VHlwZSB9fVxcXCJcXHJcXG4gICAgICAgIGlkPVxcXCJ7eyBjb21wb25lbnRJZCB9fS17eyB2LnZhbHVlIH19XFxcIlxcclxcbiAgICAgICAgdmFsdWU9XFxcInt7IHYudmFsdWUgfX1cXFwiXFxyXFxuICAgICAgICB0YWJpbmRleD1cXFwie3sgY29tcG9uZW50LnRhYmluZGV4IHx8IDAgfX1cXFwiXFxyXFxuICAgICAgICBuZy1tb2RlbD1cXFwiZGF0YVtjb21wb25lbnQua2V5XVxcXCJcXHJcXG4gICAgICAgIG5nLXJlcXVpcmVkPVxcXCJpc1JlcXVpcmVkKGNvbXBvbmVudClcXFwiXFxyXFxuICAgICAgICBjdXN0b20tdmFsaWRhdG9yPVxcXCJjb21wb25lbnQudmFsaWRhdGUuY3VzdG9tXFxcIlxcclxcbiAgICAgICAgbmctZGlzYWJsZWQ9XFxcInJlYWRPbmx5XFxcIlxcclxcbiAgICAgID5cXHJcXG4gICAgICB7eyB2LmxhYmVsIHwgZm9ybWlvVHJhbnNsYXRlOm51bGw6YnVpbGRlciB9fVxcclxcbiAgICA8L2xhYmVsPlxcclxcbiAgPC9kaXY+XFxyXFxuPC9uZy1mb3JtPlxcclxcblwiXHJcbiAgICAgICkpO1xyXG4gICAgfVxyXG4gIF0pO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFwcCkge1xyXG4gIGFwcC5jb25maWcoW1xyXG4gICAgJ2Zvcm1pb0NvbXBvbmVudHNQcm92aWRlcicsXHJcbiAgICBmdW5jdGlvbihmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIpIHtcclxuICAgICAgZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyLnJlZ2lzdGVyKCdyZXNvdXJjZScsIHtcclxuICAgICAgICB0aXRsZTogJ1Jlc291cmNlJyxcclxuICAgICAgICB0YWJsZVZpZXc6IGZ1bmN0aW9uKGRhdGEsIGNvbXBvbmVudCwgJGludGVycG9sYXRlKSB7XHJcbiAgICAgICAgICBpZiAoJGludGVycG9sYXRlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAkaW50ZXJwb2xhdGUoY29tcG9uZW50LnRlbXBsYXRlKSh7aXRlbTogZGF0YX0pO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybiBkYXRhID8gZGF0YS5faWQgOiAnJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRlbXBsYXRlOiBmdW5jdGlvbigkc2NvcGUpIHtcclxuICAgICAgICAgIHJldHVybiAkc2NvcGUuY29tcG9uZW50Lm11bHRpcGxlID8gJ2Zvcm1pby9jb21wb25lbnRzL3Jlc291cmNlLW11bHRpcGxlLmh0bWwnIDogJ2Zvcm1pby9jb21wb25lbnRzL3Jlc291cmNlLmh0bWwnO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29udHJvbGxlcjogWyckc2NvcGUnLCAnRm9ybWlvJywgJ25nRGlhbG9nJywgZnVuY3Rpb24oJHNjb3BlLCBGb3JtaW8sIG5nRGlhbG9nKSB7XHJcbiAgICAgICAgICBpZiAoJHNjb3BlLmJ1aWxkZXIpIHJldHVybjtcclxuICAgICAgICAgIHZhciBzZXR0aW5ncyA9ICRzY29wZS5jb21wb25lbnQ7XHJcbiAgICAgICAgICB2YXIgcGFyYW1zID0gc2V0dGluZ3MucGFyYW1zIHx8IHt9O1xyXG4gICAgICAgICAgJHNjb3BlLnNlbGVjdEl0ZW1zID0gW107XHJcbiAgICAgICAgICAkc2NvcGUuaGFzTmV4dFBhZ2UgPSBmYWxzZTtcclxuICAgICAgICAgICRzY29wZS5yZXNvdXJjZUxvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgIHBhcmFtcy5saW1pdCA9IDEwMDtcclxuICAgICAgICAgIHBhcmFtcy5za2lwID0gMDtcclxuICAgICAgICAgIGlmIChzZXR0aW5ncy5tdWx0aXBsZSkge1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5kZWZhdWx0VmFsdWUgPSBbXTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChzZXR0aW5ncy5yZXNvdXJjZSkge1xyXG4gICAgICAgICAgICB2YXIgdXJsID0gJyc7XHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5wcm9qZWN0KSB7XHJcbiAgICAgICAgICAgICAgdXJsICs9ICcvcHJvamVjdC8nICsgc2V0dGluZ3MucHJvamVjdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgkc2NvcGUuZm9ybWlvICYmICRzY29wZS5mb3JtaW8ucHJvamVjdFVybCkge1xyXG4gICAgICAgICAgICAgIHVybCArPSAkc2NvcGUuZm9ybWlvLnByb2plY3RVcmw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdXJsICs9ICcvZm9ybS8nICsgc2V0dGluZ3MucmVzb3VyY2U7XHJcbiAgICAgICAgICAgIHZhciBmb3JtaW8gPSBuZXcgRm9ybWlvKHVybCk7XHJcblxyXG4gICAgICAgICAgICAvLyBSZWZyZXNoIHRoZSBpdGVtcy5cclxuICAgICAgICAgICAgJHNjb3BlLnJlZnJlc2hTdWJtaXNzaW9ucyA9IGZ1bmN0aW9uKGlucHV0LCBhcHBlbmQpIHtcclxuICAgICAgICAgICAgICBpZiAoJHNjb3BlLnJlc291cmNlTG9hZGluZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAkc2NvcGUucmVzb3VyY2VMb2FkaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAvLyBJZiB0aGV5IHdpc2ggdG8gcmV0dXJuIG9ubHkgc29tZSBmaWVsZHMuXHJcbiAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnNlbGVjdEZpZWxkcykge1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnNlbGVjdCA9IHNldHRpbmdzLnNlbGVjdEZpZWxkcztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnNlYXJjaEZpZWxkcyAmJiBpbnB1dCkge1xyXG4gICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHNldHRpbmdzLnNlYXJjaEZpZWxkcywgZnVuY3Rpb24oZmllbGQpIHtcclxuICAgICAgICAgICAgICAgICAgcGFyYW1zW2ZpZWxkXSA9IGlucHV0O1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAvLyBMb2FkIHRoZSBzdWJtaXNzaW9ucy5cclxuICAgICAgICAgICAgICBmb3JtaW8ubG9hZFN1Ym1pc3Npb25zKHtcclxuICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zXHJcbiAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihzdWJtaXNzaW9ucykge1xyXG4gICAgICAgICAgICAgICAgc3VibWlzc2lvbnMgPSBzdWJtaXNzaW9ucyB8fCBbXTtcclxuICAgICAgICAgICAgICAgIGlmIChhcHBlbmQpIHtcclxuICAgICAgICAgICAgICAgICAgJHNjb3BlLnNlbGVjdEl0ZW1zID0gJHNjb3BlLnNlbGVjdEl0ZW1zLmNvbmNhdChzdWJtaXNzaW9ucyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgJHNjb3BlLnNlbGVjdEl0ZW1zID0gc3VibWlzc2lvbnM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAkc2NvcGUuaGFzTmV4dFBhZ2UgPSAoc3VibWlzc2lvbnMubGVuZ3RoID49IHBhcmFtcy5saW1pdCkgJiYgKCRzY29wZS5zZWxlY3RJdGVtcy5sZW5ndGggPCBzdWJtaXNzaW9ucy5zZXJ2ZXJDb3VudCk7XHJcbiAgICAgICAgICAgICAgfSlbJ2ZpbmFsbHknXShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICRzY29wZS5yZXNvdXJjZUxvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIExvYWQgbW9yZSBpdGVtcy5cclxuICAgICAgICAgICAgJHNjb3BlLmxvYWRNb3JlSXRlbXMgPSBmdW5jdGlvbigkc2VsZWN0LCAkZXZlbnQpIHtcclxuICAgICAgICAgICAgICAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgcGFyYW1zLnNraXAgKz0gcGFyYW1zLmxpbWl0O1xyXG4gICAgICAgICAgICAgICRzY29wZS5yZWZyZXNoU3VibWlzc2lvbnMobnVsbCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAkc2NvcGUucmVmcmVzaFN1Ym1pc3Npb25zKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgYSBuZXcgcmVzb3VyY2UuXHJcbiAgICAgICAgICAgICRzY29wZS5uZXdSZXNvdXJjZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZSAgPSAnPGJyPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cInJvd1wiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiY29sLXNtLTEyXCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cInBhbmVsIHBhbmVsLWRlZmF1bHRcIj4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJwYW5lbC1oZWFkaW5nXCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxoMyBjbGFzcz1cInBhbmVsLXRpdGxlXCI+e3sgY29tcG9uZW50LmFkZFJlc291cmNlTGFiZWwgfHwgXCJBZGQgUmVzb3VyY2VcIiB8IGZvcm1pb1RyYW5zbGF0ZX19PC9oMz4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cInBhbmVsLWJvZHlcIj4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPGZvcm1pbyBzcmM9XCJmb3JtVXJsXCI+PC9mb3JtaW8+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nO1xyXG5cclxuICAgICAgICAgICAgICBuZ0RpYWxvZy5vcGVuKHtcclxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZSxcclxuICAgICAgICAgICAgICAgIHBsYWluOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgc2NvcGU6ICRzY29wZSxcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6IFsnJHNjb3BlJywgZnVuY3Rpb24oJHNjb3BlKSB7XHJcbiAgICAgICAgICAgICAgICAgICRzY29wZS5mb3JtVXJsID0gJHNjb3BlLmZvcm1pby5mb3Jtc1VybCArICcvJyArICRzY29wZS5jb21wb25lbnQucmVzb3VyY2U7XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBCaW5kIHdoZW4gdGhlIGZvcm0gaXMgbG9hZGVkLlxyXG4gICAgICAgICAgICAgICAgICAkc2NvcGUuJG9uKCdmb3JtTG9hZCcsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7IC8vIERvbid0IGNvbmZ1c2UgYXBwXHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gQmluZCB3aGVuIHRoZSBmb3JtIGlzIHN1Ym1pdHRlZC5cclxuICAgICAgICAgICAgICAgICAgJHNjb3BlLiRvbignZm9ybVN1Ym1pc3Npb24nLCBmdW5jdGlvbihldmVudCwgc3VibWlzc2lvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSAkc2NvcGUuY29tcG9uZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhICAgICAgPSAkc2NvcGUuZGF0YTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5tdWx0aXBsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgZGF0YVtjb21wb25lbnQua2V5XS5wdXNoKHN1Ym1pc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGRhdGFbY29tcG9uZW50LmtleV0gPSBzdWJtaXNzaW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnJlZnJlc2hTdWJtaXNzaW9ucygpO1xyXG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5jbG9zZVRoaXNEaWFsb2coc3VibWlzc2lvbik7XHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfV1cclxuICAgICAgICAgICAgICB9KS5jbG9zZVByb21pc2UudGhlbihmdW5jdGlvbigvKmUqLykge1xyXG4gICAgICAgICAgICAgIC8vdmFyIGNhbmNlbGxlZCA9IGUudmFsdWUgPT09IGZhbHNlIHx8IGUudmFsdWUgPT09ICckY2xvc2VCdXR0b24nIHx8IGUudmFsdWUgPT09ICckZG9jdW1lbnQnO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy8gQ2xvc2UgYWxsIG9wZW4gZGlhbG9ncyBvbiBzdGF0ZSBjaGFuZ2UgKHVzaW5nIFVJLVJvdXRlcikuXHJcbiAgICAgICAgICAgICRzY29wZS4kb24oJyRzdGF0ZUNoYW5nZVN0YXJ0JywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgbmdEaWFsb2cuY2xvc2VBbGwoZmFsc2UpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIENsb3NlIGFsbCBvcGVuIGRpYWxvZ3Mgb24gcm91dGUgY2hhbmdlICh1c2luZyBuZ1JvdXRlKS5cclxuICAgICAgICAgICAgJHNjb3BlLiRvbignJHJvdXRlQ2hhbmdlU3RhcnQnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICBuZ0RpYWxvZy5jbG9zZUFsbChmYWxzZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1dLFxyXG4gICAgICAgIGdyb3VwOiAnYWR2YW5jZWQnLFxyXG4gICAgICAgIHNldHRpbmdzOiB7XHJcbiAgICAgICAgICBpbnB1dDogdHJ1ZSxcclxuICAgICAgICAgIHRhYmxlVmlldzogdHJ1ZSxcclxuICAgICAgICAgIGxhYmVsOiAnJyxcclxuICAgICAgICAgIGtleTogJ3Jlc291cmNlRmllbGQnLFxyXG4gICAgICAgICAgcGxhY2Vob2xkZXI6ICcnLFxyXG4gICAgICAgICAgcmVzb3VyY2U6ICcnLFxyXG4gICAgICAgICAgcHJvamVjdDogJycsXHJcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6ICcnLFxyXG4gICAgICAgICAgdGVtcGxhdGU6ICc8c3Bhbj57eyBpdGVtLmRhdGEgfX08L3NwYW4+JyxcclxuICAgICAgICAgIHNlbGVjdEZpZWxkczogJycsXHJcbiAgICAgICAgICBzZWFyY2hGaWVsZHM6ICcnLFxyXG4gICAgICAgICAgbXVsdGlwbGU6IGZhbHNlLFxyXG4gICAgICAgICAgcHJvdGVjdGVkOiBmYWxzZSxcclxuICAgICAgICAgIHBlcnNpc3RlbnQ6IHRydWUsXHJcbiAgICAgICAgICBoaWRkZW46IGZhbHNlLFxyXG4gICAgICAgICAgY2xlYXJPbkhpZGU6IHRydWUsXHJcbiAgICAgICAgICB2YWxpZGF0ZToge1xyXG4gICAgICAgICAgICByZXF1aXJlZDogZmFsc2VcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBkZWZhdWx0UGVybWlzc2lvbjogJydcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIF0pO1xyXG5cclxuICBhcHAucnVuKFtcclxuICAgICckdGVtcGxhdGVDYWNoZScsXHJcbiAgICBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzL3Jlc291cmNlLmh0bWwnLFxyXG4gICAgICAgIFwiPGRpdiBuZy1pZj1cXFwiIWNvbXBvbmVudC5hZGRSZXNvdXJjZVxcXCI+XFxyXFxuICA8bGFiZWwgbmctaWY9XFxcImNvbXBvbmVudC5sYWJlbCAmJiAhY29tcG9uZW50LmhpZGVMYWJlbFxcXCIgZm9yPVxcXCJ7eyBjb21wb25lbnRJZCB9fVxcXCIgY2xhc3M9XFxcImNvbnRyb2wtbGFiZWxcXFwiIG5nLWNsYXNzPVxcXCJ7J2ZpZWxkLXJlcXVpcmVkJzogaXNSZXF1aXJlZChjb21wb25lbnQpfVxcXCI+e3sgY29tcG9uZW50LmxhYmVsIHwgZm9ybWlvVHJhbnNsYXRlOm51bGw6YnVpbGRlciB9fTwvbGFiZWw+XFxyXFxuICA8c3BhbiBuZy1pZj1cXFwiIWNvbXBvbmVudC5sYWJlbCAmJiBpc1JlcXVpcmVkKGNvbXBvbmVudClcXFwiIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWFzdGVyaXNrIGZvcm0tY29udHJvbC1mZWVkYmFjayBmaWVsZC1yZXF1aXJlZC1pbmxpbmVcXFwiIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIj48L3NwYW4+XFxyXFxuICA8dWktc2VsZWN0IHVpLXNlbGVjdC1yZXF1aXJlZCBzYWZlLW11bHRpcGxlLXRvLXNpbmdsZSB1aS1zZWxlY3Qtb3Blbi1vbi1mb2N1cyBuZy1tb2RlbD1cXFwiZGF0YVtjb21wb25lbnQua2V5XVxcXCIgbmctZGlzYWJsZWQ9XFxcInJlYWRPbmx5XFxcIiBuZy1yZXF1aXJlZD1cXFwiaXNSZXF1aXJlZChjb21wb25lbnQpXFxcIiBpZD1cXFwie3sgY29tcG9uZW50SWQgfX1cXFwiIG5hbWU9XFxcInt7IGNvbXBvbmVudElkIH19XFxcIiB0aGVtZT1cXFwiYm9vdHN0cmFwXFxcIiB0YWJpbmRleD1cXFwie3sgY29tcG9uZW50LnRhYmluZGV4IHx8IDAgfX1cXFwiPlxcclxcbiAgICA8dWktc2VsZWN0LW1hdGNoIGNsYXNzPVxcXCJ1aS1zZWxlY3QtbWF0Y2hcXFwiIHBsYWNlaG9sZGVyPVxcXCJ7eyBjb21wb25lbnQucGxhY2Vob2xkZXIgfCBmb3JtaW9UcmFuc2xhdGU6bnVsbDpidWlsZGVyIH19XFxcIj5cXHJcXG4gICAgICA8Zm9ybWlvLXNlbGVjdC1pdGVtIHRlbXBsYXRlPVxcXCJjb21wb25lbnQudGVtcGxhdGVcXFwiIGl0ZW09XFxcIiRpdGVtIHx8ICRzZWxlY3Quc2VsZWN0ZWRcXFwiIHNlbGVjdD1cXFwiJHNlbGVjdFxcXCI+PC9mb3JtaW8tc2VsZWN0LWl0ZW0+XFxyXFxuICAgIDwvdWktc2VsZWN0LW1hdGNoPlxcclxcbiAgICA8dWktc2VsZWN0LWNob2ljZXMgY2xhc3M9XFxcInVpLXNlbGVjdC1jaG9pY2VzXFxcIiByZXBlYXQ9XFxcIml0ZW0gaW4gc2VsZWN0SXRlbXMgfCBmaWx0ZXI6ICRzZWxlY3Quc2VhcmNoXFxcIiByZWZyZXNoPVxcXCJyZWZyZXNoU3VibWlzc2lvbnMoJHNlbGVjdC5zZWFyY2gpXFxcIiByZWZyZXNoLWRlbGF5PVxcXCIyNTBcXFwiPlxcclxcbiAgICAgIDxmb3JtaW8tc2VsZWN0LWl0ZW0gdGVtcGxhdGU9XFxcImNvbXBvbmVudC50ZW1wbGF0ZVxcXCIgaXRlbT1cXFwiaXRlbVxcXCIgc2VsZWN0PVxcXCIkc2VsZWN0XFxcIj48L2Zvcm1pby1zZWxlY3QtaXRlbT5cXHJcXG4gICAgICA8YnV0dG9uIG5nLWlmPVxcXCJoYXNOZXh0UGFnZSAmJiAoJGluZGV4ID09ICRzZWxlY3QuaXRlbXMubGVuZ3RoLTEpXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1zdWNjZXNzIGJ0bi1ibG9ja1xcXCIgbmctY2xpY2s9XFxcImxvYWRNb3JlSXRlbXMoJHNlbGVjdCwgJGV2ZW50KVxcXCIgbmctZGlzYWJsZWQ9XFxcInJlc291cmNlTG9hZGluZ1xcXCI+TG9hZCBtb3JlLi4uPC9idXR0b24+XFxyXFxuICAgIDwvdWktc2VsZWN0LWNob2ljZXM+XFxyXFxuICA8L3VpLXNlbGVjdD5cXHJcXG4gIDxmb3JtaW8tZXJyb3JzIG5nLWlmPVxcXCI6OiFidWlsZGVyXFxcIj48L2Zvcm1pby1lcnJvcnM+XFxyXFxuPC9kaXY+XFxyXFxuPGRpdiBuZy1pZj1cXFwiY29tcG9uZW50LmFkZFJlc291cmNlXFxcIj5cXHJcXG4gIDx0YWJsZSBjbGFzcz1cXFwidGFibGUgdGFibGUtYm9yZGVyZWRcXFwiPlxcclxcbiAgICA8bGFiZWwgbmctaWY9XFxcImNvbXBvbmVudC5sYWJlbCAmJiAhY29tcG9uZW50LmhpZGVMYWJlbFxcXCIgZm9yPVxcXCJ7eyBjb21wb25lbnRJZCB9fVxcXCIgY2xhc3M9XFxcImNvbnRyb2wtbGFiZWxcXFwiIG5nLWNsYXNzPVxcXCJ7J2ZpZWxkLXJlcXVpcmVkJzogaXNSZXF1aXJlZChjb21wb25lbnQpfVxcXCI+e3sgY29tcG9uZW50LmxhYmVsIHwgZm9ybWlvVHJhbnNsYXRlOm51bGw6YnVpbGRlciB9fTwvbGFiZWw+XFxyXFxuICAgIDxzcGFuIG5nLWlmPVxcXCIhY29tcG9uZW50LmxhYmVsICYmIGlzUmVxdWlyZWQoY29tcG9uZW50KVxcXCIgY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tYXN0ZXJpc2sgZm9ybS1jb250cm9sLWZlZWRiYWNrIGZpZWxkLXJlcXVpcmVkLWlubGluZVxcXCIgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiPjwvc3Bhbj5cXHJcXG4gICAgPHRyPlxcclxcbiAgICAgIDx0ZD5cXHJcXG4gICAgICAgIDx1aS1zZWxlY3QgdWktc2VsZWN0LXJlcXVpcmVkIHNhZmUtbXVsdGlwbGUtdG8tc2luZ2xlIHVpLXNlbGVjdC1vcGVuLW9uLWZvY3VzIG5nLW1vZGVsPVxcXCJkYXRhW2NvbXBvbmVudC5rZXldXFxcIiBuZy1kaXNhYmxlZD1cXFwicmVhZE9ubHlcXFwiIG5nLXJlcXVpcmVkPVxcXCJpc1JlcXVpcmVkKGNvbXBvbmVudClcXFwiIGlkPVxcXCJ7eyBjb21wb25lbnRJZCB9fVxcXCIgbmFtZT1cXFwie3sgY29tcG9uZW50SWQgfX1cXFwiIHRoZW1lPVxcXCJib290c3RyYXBcXFwiIHRhYmluZGV4PVxcXCJ7eyBjb21wb25lbnQudGFiaW5kZXggfHwgMCB9fVxcXCI+XFxyXFxuICAgICAgICAgIDx1aS1zZWxlY3QtbWF0Y2ggY2xhc3M9XFxcInVpLXNlbGVjdC1tYXRjaFxcXCIgcGxhY2Vob2xkZXI9XFxcInt7IGNvbXBvbmVudC5wbGFjZWhvbGRlciB8IGZvcm1pb1RyYW5zbGF0ZTpudWxsOmJ1aWxkZXIgfX1cXFwiPlxcclxcbiAgICAgICAgICAgIDxmb3JtaW8tc2VsZWN0LWl0ZW0gdGVtcGxhdGU9XFxcImNvbXBvbmVudC50ZW1wbGF0ZVxcXCIgaXRlbT1cXFwiJGl0ZW0gfHwgJHNlbGVjdC5zZWxlY3RlZFxcXCIgc2VsZWN0PVxcXCIkc2VsZWN0XFxcIj48L2Zvcm1pby1zZWxlY3QtaXRlbT5cXHJcXG4gICAgICAgICAgPC91aS1zZWxlY3QtbWF0Y2g+XFxyXFxuICAgICAgICAgIDx1aS1zZWxlY3QtY2hvaWNlcyBjbGFzcz1cXFwidWktc2VsZWN0LWNob2ljZXNcXFwiIHJlcGVhdD1cXFwiaXRlbSBpbiBzZWxlY3RJdGVtcyB8IGZpbHRlcjogJHNlbGVjdC5zZWFyY2hcXFwiIHJlZnJlc2g9XFxcInJlZnJlc2hTdWJtaXNzaW9ucygkc2VsZWN0LnNlYXJjaClcXFwiIHJlZnJlc2gtZGVsYXk9XFxcIjI1MFxcXCI+XFxyXFxuICAgICAgICAgICAgPGZvcm1pby1zZWxlY3QtaXRlbSB0ZW1wbGF0ZT1cXFwiY29tcG9uZW50LnRlbXBsYXRlXFxcIiBpdGVtPVxcXCJpdGVtXFxcIiBzZWxlY3Q9XFxcIiRzZWxlY3RcXFwiPjwvZm9ybWlvLXNlbGVjdC1pdGVtPlxcclxcbiAgICAgICAgICAgIDxidXR0b24gbmctaWY9XFxcImhhc05leHRQYWdlICYmICgkaW5kZXggPT0gJHNlbGVjdC5pdGVtcy5sZW5ndGgtMSlcXFwiIGNsYXNzPVxcXCJidG4gYnRuLXN1Y2Nlc3MgYnRuLWJsb2NrXFxcIiBuZy1jbGljaz1cXFwibG9hZE1vcmVJdGVtcygkc2VsZWN0LCAkZXZlbnQpXFxcIiBuZy1kaXNhYmxlZD1cXFwicmVzb3VyY2VMb2FkaW5nXFxcIj5Mb2FkIG1vcmUuLi48L2J1dHRvbj5cXHJcXG4gICAgICAgICAgPC91aS1zZWxlY3QtY2hvaWNlcz5cXHJcXG4gICAgICAgIDwvdWktc2VsZWN0PlxcclxcbiAgICAgICAgPGZvcm1pby1lcnJvcnMgbmctaWY9XFxcIjo6IWJ1aWxkZXJcXFwiPjwvZm9ybWlvLWVycm9ycz5cXHJcXG4gICAgICA8L3RkPlxcclxcbiAgICA8L3RyPlxcclxcbiAgICA8dHI+XFxyXFxuICAgICAgPHRkPlxcclxcbiAgICAgICAgPGEgbmctY2xpY2s9XFxcIm5ld1Jlc291cmNlKClcXFwiIGNsYXNzPVxcXCJidG4gYnRuLXByaW1hcnlcXFwiPlxcclxcbiAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1wbHVzXFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+PC9zcGFuPiB7eyBjb21wb25lbnQuYWRkUmVzb3VyY2VMYWJlbCB8fCBcXFwiQWRkIFJlc291cmNlXFxcIiB8IGZvcm1pb1RyYW5zbGF0ZTpudWxsOmJ1aWxkZXJ9fVxcclxcbiAgICAgICAgPC9hPlxcclxcbiAgICAgIDwvdGQ+XFxyXFxuICAgIDwvdHI+XFxyXFxuICA8L3RhYmxlPlxcclxcbjwvZGl2PlxcclxcblwiXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBDaGFuZ2UgdGhlIHVpLXNlbGVjdCB0byB1aS1zZWxlY3QgbXVsdGlwbGUuXHJcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvcmVzb3VyY2UtbXVsdGlwbGUuaHRtbCcsXHJcbiAgICAgICAgJHRlbXBsYXRlQ2FjaGUuZ2V0KCdmb3JtaW8vY29tcG9uZW50cy9yZXNvdXJjZS5odG1sJykucmVwbGFjZSgvPHVpLXNlbGVjdFxccy9nLCAnPHVpLXNlbGVjdCBtdWx0aXBsZSAnKVxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIF0pO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qZXNsaW50IG1heC1kZXB0aDogW1wiZXJyb3JcIiwgNl0qL1xuXG52YXIgX2dldCA9IHJlcXVpcmUoJ2xvZGFzaC9nZXQnKTtcbnZhciBfaXNFcXVhbCA9IHJlcXVpcmUoJ2xvZGFzaC9pc0VxdWFsJyk7XG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ2xvZGFzaC9hc3NpZ24nKTtcbnZhciBfc2V0ID0gcmVxdWlyZSgnbG9kYXNoL3NldCcpO1xudmFyIF9jbG9uZURlZXAgPSByZXF1aXJlKCdsb2Rhc2gvY2xvbmVEZWVwJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFwcCkge1xuICBhcHAuZGlyZWN0aXZlKCdmb3JtaW9TZWxlY3RJdGVtJywgW1xuICAgICckY29tcGlsZScsXG4gICAgZnVuY3Rpb24oJGNvbXBpbGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc3RyaWN0OiAnRScsXG4gICAgICAgIHNjb3BlOiB7XG4gICAgICAgICAgdGVtcGxhdGU6ICc9JyxcbiAgICAgICAgICBpdGVtOiAnPScsXG4gICAgICAgICAgc2VsZWN0OiAnPSdcbiAgICAgICAgfSxcbiAgICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQpIHtcbiAgICAgICAgICBpZiAoc2NvcGUuYnVpbGRlcikgcmV0dXJuO1xuICAgICAgICAgIGlmIChzY29wZS50ZW1wbGF0ZSkge1xuICAgICAgICAgICAgZWxlbWVudC5hcHBlbmQoJGNvbXBpbGUoYW5ndWxhci5lbGVtZW50KHNjb3BlLnRlbXBsYXRlKSkoc2NvcGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICBdKTtcblxuICBhcHAuZGlyZWN0aXZlKCd1aVNlbGVjdFJlcXVpcmVkJywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlcXVpcmU6ICduZ01vZGVsJyxcbiAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgbmdNb2RlbCkge1xuICAgICAgICBpZiAoc2NvcGUuYnVpbGRlcikgcmV0dXJuO1xuICAgICAgICB2YXIgb2xkSXNFbXB0eSA9IG5nTW9kZWwuJGlzRW1wdHk7XG4gICAgICAgIG5nTW9kZWwuJGlzRW1wdHkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwKSB8fCBvbGRJc0VtcHR5KHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcblxuICAvLyBBIGRpcmVjdGl2ZSB0byBoYXZlIHVpLXNlbGVjdCBvcGVuIG9uIGZvY3VzXG4gIGFwcC5kaXJlY3RpdmUoJ3VpU2VsZWN0T3Blbk9uRm9jdXMnLCBbZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlcXVpcmU6ICd1aVNlbGVjdCcsXG4gICAgICByZXN0cmljdDogJ0EnLFxuICAgICAgbGluazogZnVuY3Rpb24oJHNjb3BlLCBlbCwgYXR0cnMsIHVpU2VsZWN0KSB7XG4gICAgICAgIGlmICgkc2NvcGUuYnVpbGRlcikgcmV0dXJuO1xuICAgICAgICB2YXIgZm9jdXNjb3VudCA9IC0xO1xuXG4gICAgICAgIGFuZ3VsYXIuZWxlbWVudCh1aVNlbGVjdC5mb2N1c3Nlcikub24oJ2ZvY3VzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGZvY3VzY291bnQtLSA8IDApIHtcbiAgICAgICAgICAgIHVpU2VsZWN0LmFjdGl2YXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBEaXNhYmxlIHRoZSBhdXRvIG9wZW4gd2hlbiB0aGlzIHNlbGVjdCBlbGVtZW50IGhhcyBiZWVuIGFjdGl2YXRlZC5cbiAgICAgICAgJHNjb3BlLiRvbigndWlzOmFjdGl2YXRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZm9jdXNjb3VudCA9IDE7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFJlLWVuYWJsZSB0aGUgYXV0byBvcGVuIGFmdGVyIHRoZSBzZWxlY3QgZWxlbWVudCBoYXMgYmVlbiBjbG9zZWRcbiAgICAgICAgJHNjb3BlLiRvbigndWlzOmNsb3NlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZm9jdXNjb3VudCA9IDE7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH1dKTtcblxuICAvLyBDb25maWd1cmUgdGhlIFNlbGVjdCBjb21wb25lbnQuXG4gIGFwcC5jb25maWcoW1xuICAgICdmb3JtaW9Db21wb25lbnRzUHJvdmlkZXInLFxuICAgIGZ1bmN0aW9uKGZvcm1pb0NvbXBvbmVudHNQcm92aWRlcikge1xuICAgICAgZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyLnJlZ2lzdGVyKCdzZWxlY3QnLCB7XG4gICAgICAgIHRpdGxlOiAnU2VsZWN0JyxcbiAgICAgICAgdGVtcGxhdGU6IGZ1bmN0aW9uKCRzY29wZSkge1xuICAgICAgICAgIHJldHVybiAkc2NvcGUuY29tcG9uZW50Lm11bHRpcGxlID8gJ2Zvcm1pby9jb21wb25lbnRzL3NlbGVjdC1tdWx0aXBsZS5odG1sJyA6ICdmb3JtaW8vY29tcG9uZW50cy9zZWxlY3QuaHRtbCc7XG4gICAgICAgIH0sXG4gICAgICAgIHRhYmxlVmlldzogZnVuY3Rpb24oZGF0YSwgY29tcG9uZW50LCAkaW50ZXJwb2xhdGUpIHtcbiAgICAgICAgICB2YXIgZ2V0SXRlbSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY29tcG9uZW50LmRhdGFTcmMpIHtcbiAgICAgICAgICAgICAgY2FzZSAndmFsdWVzJzpcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuZGF0YS52YWx1ZXMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaXRlbS52YWx1ZSA9PT0gZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gaXRlbTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgICAgY2FzZSAnanNvbic6XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudC52YWx1ZVByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0SXRlbXM7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RJdGVtcyA9IGFuZ3VsYXIuZnJvbUpzb24oY29tcG9uZW50LmRhdGEuanNvbik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0SXRlbXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHNlbGVjdEl0ZW1zLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbVtjb21wb25lbnQudmFsdWVQcm9wZXJ0eV0gPT09IGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgdXJsIGFuZCByZXNvdXJjZSB2aWV3LlxuICAgICAgICAgICAgICBjYXNlICd1cmwnOlxuICAgICAgICAgICAgICBjYXNlICdyZXNvdXJjZSc6XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoY29tcG9uZW50Lm11bHRpcGxlICYmIEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLm1hcChnZXRJdGVtKS5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgaXRlbSkge1xuICAgICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICRpbnRlcnBvbGF0ZShjb21wb25lbnQudGVtcGxhdGUpKHtpdGVtOiBpdGVtfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBpdGVtO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiAocHJldiA9PT0gJycgPyAnJyA6ICcsICcpICsgdmFsdWU7XG4gICAgICAgICAgICB9LCAnJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGRhdGEpO1xuICAgICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICB2YWx1ZSA9ICRpbnRlcnBvbGF0ZShjb21wb25lbnQudGVtcGxhdGUpKHtpdGVtOiBpdGVtfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29udHJvbGxlcjogW1xuICAgICAgICAgICckcm9vdFNjb3BlJyxcbiAgICAgICAgICAnJHNjb3BlJyxcbiAgICAgICAgICAnJGh0dHAnLFxuICAgICAgICAgICdGb3JtaW8nLFxuICAgICAgICAgICckaW50ZXJwb2xhdGUnLFxuICAgICAgICAgICckcScsXG4gICAgICAgICAgJyR0aW1lb3V0JyxcbiAgICAgICAgICBmdW5jdGlvbihcbiAgICAgICAgICAgICRyb290U2NvcGUsXG4gICAgICAgICAgICAkc2NvcGUsXG4gICAgICAgICAgICAkaHR0cCxcbiAgICAgICAgICAgIEZvcm1pbyxcbiAgICAgICAgICAgICRpbnRlcnBvbGF0ZSxcbiAgICAgICAgICAgICRxLFxuICAgICAgICAgICAgJHRpbWVvdXRcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIEZPUi03MSAtIFNraXAgZnVuY3Rpb25hbGl0eSBpbiB0aGUgYnVpbGRlciB2aWV3LlxuICAgICAgICAgICAgaWYgKCRzY29wZS5idWlsZGVyKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgc2V0dGluZ3MgPSAkc2NvcGUuY29tcG9uZW50O1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgICRzY29wZS5ub3dyYXAgPSB0cnVlO1xuICAgICAgICAgICAgJHNjb3BlLmhhc05leHRQYWdlID0gZmFsc2U7XG4gICAgICAgICAgICAkc2NvcGUuc2VsZWN0SXRlbXMgPSBbXTtcblxuICAgICAgICAgICAgdmFyIGluaXRpYWxpemVkID0gJHEuZGVmZXIoKTtcbiAgICAgICAgICAgIGluaXRpYWxpemVkLnByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgJHNjb3BlLiRlbWl0KCdzZWxlY3RMb2FkZWQnLCAkc2NvcGUuY29tcG9uZW50KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgc2VsZWN0VmFsdWVzID0gJHNjb3BlLmNvbXBvbmVudC5zZWxlY3RWYWx1ZXM7XG4gICAgICAgICAgICB2YXIgdmFsdWVQcm9wID0gJHNjb3BlLmNvbXBvbmVudC52YWx1ZVByb3BlcnR5O1xuICAgICAgICAgICAgJHNjb3BlLmdldFNlbGVjdEl0ZW0gPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuZGF0YVNyYyA9PT0gJ3ZhbHVlcycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS52YWx1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgaXRlbSB2YWx1ZS5cbiAgICAgICAgICAgICAgdmFyIGl0ZW1WYWx1ZSA9IHZhbHVlUHJvcCA/IF9nZXQoaXRlbSwgdmFsdWVQcm9wKSA6IGl0ZW07XG4gICAgICAgICAgICAgIGlmIChpdGVtVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0Nhbm5vdCBmaW5kIHZhbHVlIHByb3BlcnR5IHdpdGhpbiBzZWxlY3Q6ICcgKyB2YWx1ZVByb3ApO1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBpdGVtVmFsdWU7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAkc2NvcGUucmVmcmVzaEl0ZW1zID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiAkcS5yZXNvbHZlKFtdKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAkc2NvcGUuJG9uKCdyZWZyZXNoTGlzdCcsIGZ1bmN0aW9uKGV2ZW50LCB1cmwsIGlucHV0KSB7XG4gICAgICAgICAgICAgICRzY29wZS5yZWZyZXNoSXRlbXMoaW5wdXQsIHVybCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIHJlZnJlc2hpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciByZWZyZXNoVmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKHJlZnJlc2hpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVmcmVzaGluZyA9IHRydWU7XG4gICAgICAgICAgICAgIHZhciB0ZW1wRGF0YSA9ICRzY29wZS5kYXRhW3NldHRpbmdzLmtleV07XG4gICAgICAgICAgICAgICRzY29wZS5kYXRhW3NldHRpbmdzLmtleV0gPSBzZXR0aW5ncy5tdWx0aXBsZSA/IFtdIDogJyc7XG4gICAgICAgICAgICAgIGlmICghc2V0dGluZ3MuY2xlYXJPblJlZnJlc2gpIHtcbiAgICAgICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICRzY29wZS5kYXRhW3NldHRpbmdzLmtleV0gPSB0ZW1wRGF0YTtcbiAgICAgICAgICAgICAgICAgIHJlZnJlc2hpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICRzY29wZS4kZW1pdCgnc2VsZWN0TG9hZGVkJywgJHNjb3BlLmNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVmcmVzaGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICRzY29wZS4kZW1pdCgnc2VsZWN0TG9hZGVkJywgJHNjb3BlLmNvbXBvbmVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIEVuc3VyZXMgdGhhdCB0aGUgdmFsdWUgaXMgd2l0aGluIHRoZSBzZWxlY3QgaXRlbXMuXG4gICAgICAgICAgICB2YXIgZW5zdXJlVmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gJHNjb3BlLmRhdGFbc2V0dGluZ3Mua2V5XTtcbiAgICAgICAgICAgICAgaWYgKCF2YWx1ZSB8fCAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIGxpc3Qgb2YgaXRlbXMgYW5kIHNlZSBpZiBvdXIgdmFsdWUgZXhpc3RzLi4uXG4gICAgICAgICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCAkc2NvcGUuc2VsZWN0SXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9ICRzY29wZS5zZWxlY3RJdGVtc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0SXRlbSA9ICRzY29wZS5nZXRTZWxlY3RJdGVtKGl0ZW0pO1xuICAgICAgICAgICAgICAgIGlmIChfaXNFcXVhbChzZWxlY3RJdGVtLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIElmIHRoZSBpdGVtIGlzIG5vdCBmb3VuZCBpbiB0aGUgc2VsZWN0IGl0ZW1zIGFycmF5LCB0aGVuIGFkZCBpdCBtYW51YWxseS5cbiAgICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVQcm9wKSB7XG4gICAgICAgICAgICAgICAgICBpdGVtVmFsdWUgPSB7fTtcbiAgICAgICAgICAgICAgICAgIF9zZXQoaXRlbVZhbHVlLCB2YWx1ZVByb3AsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJHNjb3BlLnNlbGVjdEl0ZW1zLnB1c2goaXRlbVZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gUmVmcmVzaCB0aGUgaXRlbXMgd2hlbiByZWFkeS5cbiAgICAgICAgICAgIHZhciByZWZyZXNoSXRlbXNXaGVuUmVhZHkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaW5pdGlhbGl6ZWQucHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciByZWZyZXNoUHJvbWlzZSA9ICRzY29wZS5yZWZyZXNoSXRlbXModHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZnJlc2hQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICByZWZyZXNoUHJvbWlzZS50aGVuKHJlZnJlc2hWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmVmcmVzaFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIEFkZCBhIHdhdGNoIGlmIHRoZXkgd2lzaCB0byByZWZyZXNoIG9uIHNlbGVjdGlvbiBvZiBhbm90aGVyIGZpZWxkLlxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLnJlZnJlc2hPbikge1xuICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MucmVmcmVzaE9uID09PSAnZGF0YScpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuJHdhdGNoKCdkYXRhJywgcmVmcmVzaEl0ZW1zV2hlblJlYWR5LCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAkc2NvcGUuJHdhdGNoKCdkYXRhLicgKyBzZXR0aW5ncy5yZWZyZXNoT24sIHJlZnJlc2hJdGVtc1doZW5SZWFkeSk7XG4gICAgICAgICAgICAgICRzY29wZS4kd2F0Y2goJ3N1Ym1pc3Npb24uZGF0YS4nICsgc2V0dGluZ3MucmVmcmVzaE9uLCByZWZyZXNoSXRlbXNXaGVuUmVhZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFdhdGNoIGZvciB0aGUgZGF0YSB0byBiZSBzZXQsIGFuZCBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBwcm9wZXJseS5cbiAgICAgICAgICAgICAgdmFyIGRhdGFXYXRjaCA9ICRzY29wZS4kd2F0Y2goJ2RhdGEuJyArIHNldHRpbmdzLmtleSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIGluaXRpYWxpemVkLnByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVdhdGNoKCk7XG4gICAgICAgICAgICAgICAgICAgIGVuc3VyZVZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hWYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGxhc3RJbnB1dDtcbiAgICAgICAgICAgIHN3aXRjaCAoc2V0dGluZ3MuZGF0YVNyYykge1xuICAgICAgICAgICAgICBjYXNlICd2YWx1ZXMnOlxuICAgICAgICAgICAgICAgICRzY29wZS5zZWxlY3RJdGVtcyA9IHNldHRpbmdzLmRhdGEudmFsdWVzO1xuICAgICAgICAgICAgICAgIGluaXRpYWxpemVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnanNvbic6XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1zO1xuXG4gICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBuZXcgcmVzdWx0LlxuICAgICAgICAgICAgICAgIHZhciBzZXRSZXN1bHQgPSBmdW5jdGlvbihkYXRhLCBhcHBlbmQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGNvZXJjZSB0aGUgZGF0YSBpbnRvIGFuIGFycmF5LlxuICAgICAgICAgICAgICAgICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gW2RhdGFdO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCBvcHRpb25zLnBhcmFtcy5saW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuaGFzTmV4dFBhZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChhcHBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNlbGVjdEl0ZW1zID0gJHNjb3BlLnNlbGVjdEl0ZW1zLmNvbmNhdChkYXRhKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuc2VsZWN0SXRlbXMgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAkc2NvcGUuY29tcG9uZW50LmRhdGEuanNvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMgPSBhbmd1bGFyLmZyb21Kc29uKCRzY29wZS5jb21wb25lbnQuZGF0YS5qc29uKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiAkc2NvcGUuY29tcG9uZW50LmRhdGEuanNvbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMgPSAkc2NvcGUuY29tcG9uZW50LmRhdGEuanNvbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpdGVtcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0VmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IGRvdCBub3RhdGlvbiBpbiB0aGUgc2VsZWN0VmFsdWUgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RWYWx1ZXMuaW5kZXhPZignLicpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IHNlbGVjdFZhbHVlcy5zcGxpdCgnLicpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3QgPSBpdGVtcztcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIHBhcnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3QgPSBzZWxlY3RbcGFydHNbaV1dO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpdGVtcyA9IHNlbGVjdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBpdGVtcyA9IGl0ZW1zW3NlbGVjdFZhbHVlc107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0Vycm9yIHBhcnNpbmcgSlNPTiBpbiAnICsgJHNjb3BlLmNvbXBvbmVudC5rZXksIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICAgICAgICAgICAgICAgICAgaXRlbXMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICBsaW1pdDogJHNjb3BlLmNvbXBvbmVudC5saW1pdCB8fCAyMCxcbiAgICAgICAgICAgICAgICAgIHNraXA6IDBcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgJHNjb3BlLnJlZnJlc2hJdGVtcyA9IGZ1bmN0aW9uKGlucHV0LCB1cmwsIGFwcGVuZCkge1xuICAgICAgICAgICAgICAgICAgLy8gSWYgdGhleSB0eXBlZCBpbiBhIHNlYXJjaCwgcmVzZXQgc2tpcC5cbiAgICAgICAgICAgICAgICAgIGlmIChsYXN0SW5wdXQgIT09IGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RJbnB1dCA9IGlucHV0O1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhcmFtcy5za2lwID0gMDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RJdGVtcyA9IGl0ZW1zO1xuICAgICAgICAgICAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdEl0ZW1zID0gc2VsZWN0SXRlbXMuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHZpc2libGUgc3RyaW5nIGZyb20gdGhlIGludGVycG9sYXRlZCBpdGVtLlxuICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9ICRpbnRlcnBvbGF0ZSgkc2NvcGUuY29tcG9uZW50LnRlbXBsYXRlKSh7aXRlbTogaXRlbX0pLnJlcGxhY2UoLzwoPzoufFxcbikqPz4vZ20sICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKCRzY29wZS5jb21wb25lbnQuZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzdGFydHNXaXRoJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihpbnB1dC50b0xvd2VyQ2FzZSgpKSAhPT0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjb250YWlucyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKS5sYXN0SW5kZXhPZihpbnB1dC50b0xvd2VyQ2FzZSgpLCAwKSA9PT0gMDtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXJhbXMuc2tpcCA9IHBhcnNlSW50KG9wdGlvbnMucGFyYW1zLnNraXAsIDEwKTtcbiAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGFyYW1zLmxpbWl0ID0gcGFyc2VJbnQob3B0aW9ucy5wYXJhbXMubGltaXQsIDEwKTtcbiAgICAgICAgICAgICAgICAgIHNlbGVjdEl0ZW1zID0gc2VsZWN0SXRlbXMuc2xpY2Uob3B0aW9ucy5wYXJhbXMuc2tpcCwgb3B0aW9ucy5wYXJhbXMuc2tpcCArIG9wdGlvbnMucGFyYW1zLmxpbWl0KTtcbiAgICAgICAgICAgICAgICAgIHNldFJlc3VsdChzZWxlY3RJdGVtcywgYXBwZW5kKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpbml0aWFsaXplZC5yZXNvbHZlKCRzY29wZS5zZWxlY3RJdGVtcyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAkc2NvcGUucmVmcmVzaEl0ZW1zKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ2N1c3RvbSc6XG4gICAgICAgICAgICAgICAgJHNjb3BlLnJlZnJlc2hJdGVtcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBfY2xvbmVEZWVwKCRzY29wZS5zdWJtaXNzaW9uLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm93ID0gX2Nsb25lRGVlcCgkc2NvcGUuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNlbGVjdEl0ZW1zID0gZXZhbCgnKGZ1bmN0aW9uKGRhdGEsIHJvdykgeyB2YXIgdmFsdWVzID0gW107JyArIHNldHRpbmdzLmRhdGEuY3VzdG9tLnRvU3RyaW5nKCkgKyAnOyByZXR1cm4gdmFsdWVzOyB9KShkYXRhLCByb3cpJyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNlbGVjdEl0ZW1zID0gW107XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaW5pdGlhbGl6ZWQucmVzb2x2ZSgkc2NvcGUuc2VsZWN0SXRlbXMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgJHNjb3BlLnJlZnJlc2hJdGVtcygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICd1cmwnOlxuICAgICAgICAgICAgICBjYXNlICdyZXNvdXJjZSc6XG4gICAgICAgICAgICAgICAgdmFyIHVybCA9ICcnO1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5kYXRhU3JjID09PSAndXJsJykge1xuICAgICAgICAgICAgICAgICAgdXJsID0gc2V0dGluZ3MuZGF0YS51cmw7XG4gICAgICAgICAgICAgICAgICBpZiAodXJsLnN1YnN0cigwLCAxKSA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IEZvcm1pby5nZXRCYXNlVXJsKCkgKyBzZXR0aW5ncy5kYXRhLnVybDtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgLy8gRGlzYWJsZSBhdXRoIGZvciBvdXRnb2luZyByZXF1ZXN0cy5cbiAgICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3MuYXV0aGVudGljYXRlICYmIHVybC5pbmRleE9mKEZvcm1pby5nZXRCYXNlVXJsKCkpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRpc2FibGVKV1QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMgfHwge307XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVycy5BdXRob3JpemF0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmhlYWRlcnMuUHJhZ21hID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmhlYWRlcnNbJ0NhY2hlLUNvbnRyb2wnXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICB1cmwgPSBGb3JtaW8uZ2V0QmFzZVVybCgpO1xuICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmRhdGEucHJvamVjdCkge1xuICAgICAgICAgICAgICAgICAgICB1cmwgKz0gJy9wcm9qZWN0LycgKyBzZXR0aW5ncy5kYXRhLnByb2plY3Q7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB1cmwgKz0gJy9mb3JtLycgKyBzZXR0aW5ncy5kYXRhLnJlc291cmNlICsgJy9zdWJtaXNzaW9uJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvcHRpb25zLnBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAgIGxpbWl0OiAkc2NvcGUuY29tcG9uZW50LmxpbWl0IHx8IDEwMCxcbiAgICAgICAgICAgICAgICAgIHNraXA6IDBcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgJHNjb3BlLmxvYWRNb3JlSXRlbXMgPSBmdW5jdGlvbigkc2VsZWN0LCAkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXJhbXMuc2tpcCA9IHBhcnNlSW50KG9wdGlvbnMucGFyYW1zLnNraXAsIDEwKTtcbiAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGFyYW1zLnNraXAgKz0gcGFyc2VJbnQob3B0aW9ucy5wYXJhbXMubGltaXQsIDEwKTtcbiAgICAgICAgICAgICAgICAgICRzY29wZS5yZWZyZXNoSXRlbXModHJ1ZSwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICAgICAgICAgICRzY29wZS5oYXNOZXh0UGFnZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAkc2NvcGUucmVmcmVzaEl0ZW1zID0gZnVuY3Rpb24oaW5wdXQsIG5ld1VybCwgYXBwZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0ID09PSBsYXN0SW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSB0aGUgc2VhcmNoIGhhcyBjaGFuZ2VkLCByZXNldCB0aGUgbGltaXQgYW5kIHNraXAuXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhcmFtcy5saW1pdCA9ICRzY29wZS5jb21wb25lbnQubGltaXQgfHwgMTAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXJhbXMuc2tpcCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbGFzdElucHV0ID0gaW5wdXQ7XG4gICAgICAgICAgICAgICAgICAgIG5ld1VybCA9IG5ld1VybCB8fCB1cmw7XG4gICAgICAgICAgICAgICAgICAgIG5ld1VybCA9ICRpbnRlcnBvbGF0ZShuZXdVcmwpKHtcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhOiAkc2NvcGUuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICBmb3JtaW9CYXNlOiAkcm9vdFNjb3BlLmFwaUJhc2UgfHwgJ2h0dHBzOi8vYXBpLmZvcm0uaW8nXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld1VybCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBzZWFyY2gsIHRoZW4gYWRkIHRoYXQgdG8gdGhlIGZpbHRlci5cbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnNlYXJjaEZpZWxkICYmXG4gICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpICYmXG4gICAgICAgICAgICAgICAgICAgICAgaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXJhbXNbZW5jb2RlVVJJQ29tcG9uZW50KHNldHRpbmdzLnNlYXJjaEZpZWxkKV0gPSBlbmNvZGVVUklDb21wb25lbnQoaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLnBhcmFtc1tlbmNvZGVVUklDb21wb25lbnQoc2V0dGluZ3Muc2VhcmNoRmllbGQpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgb3RoZXIgZmlsdGVyLlxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbHRlciA9ICRpbnRlcnBvbGF0ZShzZXR0aW5ncy5maWx0ZXIpKHtkYXRhOiAkc2NvcGUuZGF0YX0pO1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgY2hhbmdlcyAnYT1iJmM9ZCcgaW50byBhbiBvYmplY3QgYW5kIGFzc2lnbnMgdG8gcGFyYW1zLlxuICAgICAgICAgICAgICAgICAgICAgIF9hc3NpZ24ob3B0aW9ucy5wYXJhbXMsIEpTT04ucGFyc2UoJ3tcIicgKyBkZWNvZGVVUkkoZmlsdGVyKS5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykucmVwbGFjZSgvJi9nLCAnXCIsXCInKS5yZXBsYWNlKC89L2csJ1wiOlwiJykgKyAnXCJ9JykpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhleSB3aXNoIHRvIHJldHVybiBvbmx5IHNvbWUgZmllbGRzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3Muc2VsZWN0RmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXJhbXMuc2VsZWN0ID0gc2V0dGluZ3Muc2VsZWN0RmllbGRzO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBuZXcgcmVzdWx0LlxuICAgICAgICAgICAgICAgICAgICB2YXIgc2V0UmVzdWx0ID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGNvZXJjZSB0aGUgZGF0YSBpbnRvIGFuIGFycmF5LlxuICAgICAgICAgICAgICAgICAgICAgIGlmICghKGRhdGEgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBbZGF0YV07XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgb3B0aW9ucy5wYXJhbXMubGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5oYXNOZXh0UGFnZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5oYXNOZXh0UGFnZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmIChhcHBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5zZWxlY3RJdGVtcyA9ICRzY29wZS5zZWxlY3RJdGVtcy5jb25jYXQoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnNlbGVjdEl0ZW1zID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhlIHZhbHVlIGlzIHNldCB0byB3aGF0IGl0IHNob3VsZCBiZSBzZXQgdG8uXG4gICAgICAgICAgICAgICAgICAgICAgZW5zdXJlVmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmRhdGFTcmMgPT09ICdyZXNvdXJjZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gKG5ldyBGb3JtaW8obmV3VXJsKSkubG9hZFN1Ym1pc3Npb25zKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBpbiBoZWFkZXJzIGlmIHNwZWNpZmllZFxuICAgICAgICAgICAgICAgICAgICAgIGlmICgkc2NvcGUuY29tcG9uZW50LmRhdGEuaGFzT3duUHJvcGVydHkoJ2hlYWRlcnMnKSAmJiAkc2NvcGUuY29tcG9uZW50LmRhdGEuaGVhZGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmhlYWRlcnMgPSBfYXNzaWduKG9wdGlvbnMuaGVhZGVycywgJHNjb3BlLmNvbXBvbmVudC5kYXRhLmhlYWRlcnMucmVkdWNlKGZ1bmN0aW9uKGhlYWRlcnMsIGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1tjdXJyZW50LmtleV0gPSBjdXJyZW50LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwge30pKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgLy9JZiBkaXNhYmxlTGltaXQgaXMgdHJ1ZSBhbmQgZGF0YSBzb3VyY2UgaXMgJ3VybCcgdGhlbiByZW1vdmluZyAnbGltaXQnIGFuZCAnc2tpcCcgcGFyYW1ldGVycyBmcm9tIG9wdGlvbnMuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmRhdGFTcmMgPT09ICd1cmwnICYmIHNldHRpbmdzLmRhdGEuZGlzYWJsZUxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5wYXJhbXMubGltaXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5wYXJhbXMuc2tpcDtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9ICRodHRwLmdldChuZXdVcmwsIG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHNlbGVjdFZhbHVlIHByb3AgaXMgZGVmaW5lZCwgdXNlIGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdFZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRSZXN1bHQoX2dldChkYXRhLCBzZWxlY3RWYWx1ZXMsIFtdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBdHRlbXB0IHRvIGRlZmF1bHQgdG8gdGhlIGZvcm1pbyBzZXR0aW5ncyBmb3IgYSByZXNvdXJjZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoJ2RhdGEnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRSZXN1bHQoZGF0YS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoJ2l0ZW1zJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0UmVzdWx0KGRhdGEuaXRlbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBkYXRhIGl0c2VsZi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRSZXN1bHQoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkc2NvcGUuc2VsZWN0SXRlbXM7XG4gICAgICAgICAgICAgICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbGl6ZWQucmVzb2x2ZSgkc2NvcGUuc2VsZWN0SXRlbXMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAkc2NvcGUucmVmcmVzaEl0ZW1zKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbnN1cmVWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICRzY29wZS5zZWxlY3RJdGVtcyA9IFtdO1xuICAgICAgICAgICAgICAgIGluaXRpYWxpemVkLnJlc29sdmUoJHNjb3BlLnNlbGVjdEl0ZW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgaW5wdXQ6IHRydWUsXG4gICAgICAgICAgdGFibGVWaWV3OiB0cnVlLFxuICAgICAgICAgIGxhYmVsOiAnJyxcbiAgICAgICAgICBrZXk6ICdzZWxlY3RGaWVsZCcsXG4gICAgICAgICAgcGxhY2Vob2xkZXI6ICcnLFxuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHZhbHVlczogW10sXG4gICAgICAgICAgICBqc29uOiAnJyxcbiAgICAgICAgICAgIHVybDogJycsXG4gICAgICAgICAgICByZXNvdXJjZTogJycsXG4gICAgICAgICAgICBjdXN0b206ICcnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkYXRhU3JjOiAndmFsdWVzJyxcbiAgICAgICAgICB2YWx1ZVByb3BlcnR5OiAnJyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6ICcnLFxuICAgICAgICAgIHJlZnJlc2hPbjogJycsXG4gICAgICAgICAgZmlsdGVyOiAnJyxcbiAgICAgICAgICBhdXRoZW50aWNhdGU6IGZhbHNlLFxuICAgICAgICAgIHRlbXBsYXRlOiAnPHNwYW4+e3sgaXRlbS5sYWJlbCB9fTwvc3Bhbj4nLFxuICAgICAgICAgIG11bHRpcGxlOiBmYWxzZSxcbiAgICAgICAgICBwcm90ZWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIHVuaXF1ZTogZmFsc2UsXG4gICAgICAgICAgcGVyc2lzdGVudDogdHJ1ZSxcbiAgICAgICAgICBoaWRkZW46IGZhbHNlLFxuICAgICAgICAgIGNsZWFyT25IaWRlOiB0cnVlLFxuICAgICAgICAgIHZhbGlkYXRlOiB7XG4gICAgICAgICAgICByZXF1aXJlZDogZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgXSk7XG4gIGFwcC5ydW4oW1xuICAgICckdGVtcGxhdGVDYWNoZScsXG4gICAgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvc2VsZWN0Lmh0bWwnLFxuICAgICAgICBcIjxsYWJlbCBuZy1pZj1cXFwiY29tcG9uZW50LmxhYmVsICYmICFjb21wb25lbnQuaGlkZUxhYmVsXFxcIiAgZm9yPVxcXCJ7eyBjb21wb25lbnRJZCB9fVxcXCIgY2xhc3M9XFxcImNvbnRyb2wtbGFiZWxcXFwiIG5nLWNsYXNzPVxcXCJ7J2ZpZWxkLXJlcXVpcmVkJzogaXNSZXF1aXJlZChjb21wb25lbnQpfVxcXCI+e3sgY29tcG9uZW50LmxhYmVsIHwgZm9ybWlvVHJhbnNsYXRlOm51bGw6YnVpbGRlciB9fTwvbGFiZWw+XFxyXFxuPHNwYW4gbmctaWY9XFxcIiFjb21wb25lbnQubGFiZWwgJiYgaXNSZXF1aXJlZChjb21wb25lbnQpXFxcIiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1hc3RlcmlzayBmb3JtLWNvbnRyb2wtZmVlZGJhY2sgZmllbGQtcmVxdWlyZWQtaW5saW5lXFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+PC9zcGFuPlxcclxcbjx1aS1zZWxlY3RcXHJcXG4gIHVpLXNlbGVjdC1yZXF1aXJlZFxcclxcbiAgdWktc2VsZWN0LW9wZW4tb24tZm9jdXNcXHJcXG4gIG5nLW1vZGVsPVxcXCJkYXRhW2NvbXBvbmVudC5rZXldXFxcIlxcclxcbiAgc2FmZS1tdWx0aXBsZS10by1zaW5nbGVcXHJcXG4gIG5hbWU9XFxcInt7IGNvbXBvbmVudElkIH19XFxcIlxcclxcbiAgbmctZGlzYWJsZWQ9XFxcInJlYWRPbmx5XFxcIlxcclxcbiAgbmctcmVxdWlyZWQ9XFxcImlzUmVxdWlyZWQoY29tcG9uZW50KVxcXCJcXHJcXG4gIGlkPVxcXCJ7eyBjb21wb25lbnRJZCB9fVxcXCJcXHJcXG4gIHRoZW1lPVxcXCJib290c3RyYXBcXFwiXFxyXFxuICBjdXN0b20tdmFsaWRhdG9yPVxcXCJjb21wb25lbnQudmFsaWRhdGUuY3VzdG9tXFxcIlxcclxcbiAgdGFiaW5kZXg9XFxcInt7IGNvbXBvbmVudC50YWJpbmRleCB8fCAwIH19XFxcIlxcclxcbj5cXHJcXG4gIDx1aS1zZWxlY3QtbWF0Y2ggY2xhc3M9XFxcInVpLXNlbGVjdC1tYXRjaFxcXCIgcGxhY2Vob2xkZXI9XFxcInt7IGNvbXBvbmVudC5wbGFjZWhvbGRlciB8IGZvcm1pb1RyYW5zbGF0ZTpudWxsOmJ1aWxkZXIgfX1cXFwiPlxcclxcbiAgICA8Zm9ybWlvLXNlbGVjdC1pdGVtIHRlbXBsYXRlPVxcXCJjb21wb25lbnQudGVtcGxhdGVcXFwiIGl0ZW09XFxcIiRpdGVtIHx8ICRzZWxlY3Quc2VsZWN0ZWRcXFwiIHNlbGVjdD1cXFwiJHNlbGVjdFxcXCI+PC9mb3JtaW8tc2VsZWN0LWl0ZW0+XFxyXFxuICA8L3VpLXNlbGVjdC1tYXRjaD5cXHJcXG4gIDx1aS1zZWxlY3QtY2hvaWNlcyBjbGFzcz1cXFwidWktc2VsZWN0LWNob2ljZXNcXFwiIHJlcGVhdD1cXFwiZ2V0U2VsZWN0SXRlbShpdGVtKSBhcyBpdGVtIGluIHNlbGVjdEl0ZW1zIHwgZmlsdGVyOiAkc2VsZWN0LnNlYXJjaFxcXCIgcmVmcmVzaD1cXFwicmVmcmVzaEl0ZW1zKCRzZWxlY3Quc2VhcmNoKVxcXCIgcmVmcmVzaC1kZWxheT1cXFwiMjUwXFxcIj5cXHJcXG4gICAgPGZvcm1pby1zZWxlY3QtaXRlbSB0ZW1wbGF0ZT1cXFwiY29tcG9uZW50LnRlbXBsYXRlXFxcIiBpdGVtPVxcXCJpdGVtXFxcIiBzZWxlY3Q9XFxcIiRzZWxlY3RcXFwiPjwvZm9ybWlvLXNlbGVjdC1pdGVtPlxcclxcbiAgICA8YnV0dG9uIG5nLWlmPVxcXCJoYXNOZXh0UGFnZSAmJiAoJGluZGV4ID09ICRzZWxlY3QuaXRlbXMubGVuZ3RoLTEpXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1zdWNjZXNzIGJ0bi1ibG9ja1xcXCIgbmctY2xpY2s9XFxcImxvYWRNb3JlSXRlbXMoJHNlbGVjdCwgJGV2ZW50KVxcXCIgbmctZGlzYWJsZWQ9XFxcInNlbGVjdExvYWRpbmdcXFwiPkxvYWQgbW9yZS4uLjwvYnV0dG9uPlxcclxcbiAgPC91aS1zZWxlY3QtY2hvaWNlcz5cXHJcXG48L3VpLXNlbGVjdD5cXHJcXG48ZGl2IG5nLWlmPVxcXCIhIWNvbXBvbmVudC5kZXNjcmlwdGlvblxcXCIgY2xhc3M9XFxcImhlbHAtYmxvY2tcXFwiPlxcclxcbiAgPHNwYW4+e3sgY29tcG9uZW50LmRlc2NyaXB0aW9uIH19PC9zcGFuPlxcclxcbjwvZGl2Plxcclxcbjxmb3JtaW8tZXJyb3JzIG5nLWlmPVxcXCI6OiFidWlsZGVyXFxcIj48L2Zvcm1pby1lcnJvcnM+XFxyXFxuXCJcbiAgICAgICk7XG5cbiAgICAgIC8vIENoYW5nZSB0aGUgdWktc2VsZWN0IHRvIHVpLXNlbGVjdCBtdWx0aXBsZS5cbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvc2VsZWN0LW11bHRpcGxlLmh0bWwnLFxuICAgICAgICAkdGVtcGxhdGVDYWNoZS5nZXQoJ2Zvcm1pby9jb21wb25lbnRzL3NlbGVjdC5odG1sJykucmVwbGFjZSgnPHVpLXNlbGVjdCcsICc8dWktc2VsZWN0IG11bHRpcGxlJylcbiAgICAgICk7XG4gICAgfVxuICBdKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcHApIHtcclxuICBhcHAuZGlyZWN0aXZlKCdmb3JtaW9TZWxlY3RCb3hlcycsIFtmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgIHJlcGxhY2U6IHRydWUsXHJcbiAgICAgIHJlcXVpcmU6ICduZ01vZGVsJyxcclxuICAgICAgc2NvcGU6IHtcclxuICAgICAgICBjb21wb25lbnQ6ICc9JyxcclxuICAgICAgICBjb21wb25lbnRJZDogJz0nLFxyXG4gICAgICAgIHJlYWRPbmx5OiAnPScsXHJcbiAgICAgICAgbW9kZWw6ICc9bmdNb2RlbCcsXHJcbiAgICAgICAgZ3JpZFJvdzogJz0nLFxyXG4gICAgICAgIGdyaWRDb2w6ICc9JyxcclxuICAgICAgICBidWlsZGVyOiAnPT8nXHJcbiAgICAgIH0sXHJcbiAgICAgIHRlbXBsYXRlVXJsOiAnZm9ybWlvL2NvbXBvbmVudHMvc2VsZWN0Ym94ZXMtZGlyZWN0aXZlLmh0bWwnLFxyXG4gICAgICBsaW5rOiBmdW5jdGlvbigkc2NvcGUsIGVsLCBhdHRycywgbmdNb2RlbCkge1xyXG4gICAgICAgIGlmICgkc2NvcGUuYnVpbGRlcikgcmV0dXJuO1xyXG4gICAgICAgIC8vIEluaXRpYWxpemUgbW9kZWxcclxuICAgICAgICB2YXIgbW9kZWwgPSB7fTtcclxuICAgICAgICBhbmd1bGFyLmZvckVhY2goJHNjb3BlLmNvbXBvbmVudC52YWx1ZXMsIGZ1bmN0aW9uKHYpIHtcclxuICAgICAgICAgIG1vZGVsW3YudmFsdWVdID0gbmdNb2RlbC4kdmlld1ZhbHVlLmhhc093blByb3BlcnR5KHYudmFsdWUpXHJcbiAgICAgICAgICAgID8gISFuZ01vZGVsLiR2aWV3VmFsdWVbdi52YWx1ZV1cclxuICAgICAgICAgICAgOiBmYWxzZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBGQS04MzUgLSBVcGRhdGUgdGhlIHZpZXcgbW9kZWwgd2l0aCBvdXIgZGVmYXVsdHMuXHJcbiAgICAgICAgLy8gRkEtOTIxIC0gQXR0ZW1wdCB0byBsb2FkIGEgY3VycmVudCBtb2RlbCwgaWYgcHJlc2VudCBiZWZvcmUgdGhlIGRlZmF1bHRzLlxyXG4gICAgICAgIG5nTW9kZWwuJHNldFZpZXdWYWx1ZSgkc2NvcGUubW9kZWwgfHwgbW9kZWwpO1xyXG5cclxuICAgICAgICBuZ01vZGVsLiRzZXRQcmlzdGluZSh0cnVlKTtcclxuICAgICAgICBuZ01vZGVsLiRpc0VtcHR5ID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSkuZXZlcnkoZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhdmFsdWVba2V5XTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgICRzY29wZS50b2dnbGVDaGVja2JveCA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICB2YXIgX21vZGVsID0gYW5ndWxhci5jb3B5KG5nTW9kZWwuJHZpZXdWYWx1ZSB8fCB7fSk7XHJcbiAgICAgICAgICBfbW9kZWxbdmFsdWVdID0gIV9tb2RlbFt2YWx1ZV07XHJcbiAgICAgICAgICBuZ01vZGVsLiRzZXRWaWV3VmFsdWUoX21vZGVsKTtcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1dKTtcclxuXHJcbiAgYXBwLmNvbmZpZyhbXHJcbiAgICAnZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyJyxcclxuICAgIGZ1bmN0aW9uKGZvcm1pb0NvbXBvbmVudHNQcm92aWRlcikge1xyXG4gICAgICBmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIucmVnaXN0ZXIoJ3NlbGVjdGJveGVzJywge1xyXG4gICAgICAgIHRpdGxlOiAnU2VsZWN0IEJveGVzJyxcclxuICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL3NlbGVjdGJveGVzLmh0bWwnLFxyXG4gICAgICAgIHRhYmxlVmlldzogZnVuY3Rpb24oZGF0YSwgY29tcG9uZW50KSB7XHJcbiAgICAgICAgICBpZiAoIWRhdGEpIHJldHVybiAnJztcclxuXHJcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoZGF0YSlcclxuICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhW2tleV07XHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgLm1hcChmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudC52YWx1ZXMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGl0ZW0udmFsdWUgPT09IGRhdGEpIHtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSBpdGVtLmxhYmVsO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgICAgfSlcclxuICAgICAgICAgIC5qb2luKCcsICcpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0dGluZ3M6IHtcclxuICAgICAgICAgIGlucHV0OiB0cnVlLFxyXG4gICAgICAgICAgdGFibGVWaWV3OiB0cnVlLFxyXG4gICAgICAgICAgbGFiZWw6ICcnLFxyXG4gICAgICAgICAga2V5OiAnc2VsZWN0Ym94ZXNGaWVsZCcsXHJcbiAgICAgICAgICB2YWx1ZXM6IFtdLFxyXG4gICAgICAgICAgaW5saW5lOiBmYWxzZSxcclxuICAgICAgICAgIHByb3RlY3RlZDogZmFsc2UsXHJcbiAgICAgICAgICBwZXJzaXN0ZW50OiB0cnVlLFxyXG4gICAgICAgICAgaGlkZGVuOiBmYWxzZSxcclxuICAgICAgICAgIGNsZWFyT25IaWRlOiB0cnVlLFxyXG4gICAgICAgICAgdmFsaWRhdGU6IHtcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICBdKTtcclxuXHJcbiAgYXBwLnJ1bihbXHJcbiAgICAnJHRlbXBsYXRlQ2FjaGUnLFxyXG4gICAgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9zZWxlY3Rib3hlcy1kaXJlY3RpdmUuaHRtbCcsXHJcbiAgICAgICAgXCI8ZGl2IGNsYXNzPVxcXCJzZWxlY3QtYm94ZXNcXFwiPlxcclxcbiAgPGRpdiBuZy1jbGFzcz1cXFwiY29tcG9uZW50LmlubGluZSA/ICdjaGVja2JveC1pbmxpbmUnIDogJ2NoZWNrYm94J1xcXCIgbmctcmVwZWF0PVxcXCJ2IGluIGNvbXBvbmVudC52YWx1ZXMgdHJhY2sgYnkgJGluZGV4XFxcIj5cXHJcXG4gICAgPGxhYmVsIGNsYXNzPVxcXCJjb250cm9sLWxhYmVsXFxcIiBmb3I9XFxcInt7IGNvbXBvbmVudElkIH19LXt7IHYudmFsdWUgfX1cXFwiPlxcclxcbiAgICAgIDxpbnB1dCB0eXBlPVxcXCJjaGVja2JveFxcXCJcXHJcXG4gICAgICAgIGlkPVxcXCJ7eyBjb21wb25lbnRJZCB9fS17eyB2LnZhbHVlIH19XFxcIlxcclxcbiAgICAgICAgbmFtZT1cXFwie3sgY29tcG9uZW50SWQgfX0te3sgdi52YWx1ZSB9fVxcXCJcXHJcXG4gICAgICAgIHZhbHVlPVxcXCJ7eyB2LnZhbHVlIH19XFxcIlxcclxcbiAgICAgICAgdGFiaW5kZXg9XFxcInt7IGNvbXBvbmVudC50YWJpbmRleCB8fCAwIH19XFxcIlxcclxcbiAgICAgICAgbmctZGlzYWJsZWQ9XFxcInJlYWRPbmx5XFxcIlxcclxcbiAgICAgICAgbmctY2xpY2s9XFxcInRvZ2dsZUNoZWNrYm94KHYudmFsdWUpXFxcIlxcclxcbiAgICAgICAgbmctY2hlY2tlZD1cXFwibW9kZWxbdi52YWx1ZV1cXFwiXFxyXFxuICAgICAgICBncmlkLXJvdz1cXFwiZ3JpZFJvd1xcXCJcXHJcXG4gICAgICAgIGdyaWQtY29sPVxcXCJncmlkQ29sXFxcIlxcclxcbiAgICAgID5cXHJcXG4gICAgICB7eyB2LmxhYmVsIHwgZm9ybWlvVHJhbnNsYXRlOm51bGw6YnVpbGRlciB9fVxcclxcbiAgICA8L2xhYmVsPlxcclxcbiAgPC9kaXY+XFxyXFxuPC9kaXY+XFxyXFxuXCJcclxuICAgICAgKTtcclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9zZWxlY3Rib3hlcy5odG1sJyxcclxuICAgICAgICBcIjxkaXYgY2xhc3M9XFxcInNlbGVjdC1ib3hlc1xcXCI+XFxyXFxuICA8bGFiZWwgbmctaWY9XFxcImNvbXBvbmVudC5sYWJlbCAmJiAhY29tcG9uZW50LmhpZGVMYWJlbFxcXCIgZm9yPVxcXCJ7eyBjb21wb25lbnRJZCB9fVxcXCIgY2xhc3M9XFxcImNvbnRyb2wtbGFiZWxcXFwiIG5nLWNsYXNzPVxcXCJ7J2ZpZWxkLXJlcXVpcmVkJzogaXNSZXF1aXJlZChjb21wb25lbnQpfVxcXCI+XFxyXFxuICAgIHt7IGNvbXBvbmVudC5sYWJlbCB9fVxcclxcbiAgPC9sYWJlbD5cXHJcXG4gIDxmb3JtaW8tc2VsZWN0LWJveGVzXFxyXFxuICAgIG5hbWU9XFxcInt7Y29tcG9uZW50SWR9fVxcXCJcXHJcXG4gICAgbmctbW9kZWw9XFxcImRhdGFbY29tcG9uZW50LmtleV1cXFwiXFxyXFxuICAgIG5nLW1vZGVsLW9wdGlvbnM9XFxcInthbGxvd0ludmFsaWQ6IHRydWV9XFxcIlxcclxcbiAgICBjb21wb25lbnQ9XFxcImNvbXBvbmVudFxcXCJcXHJcXG4gICAgY29tcG9uZW50LWlkPVxcXCJjb21wb25lbnRJZFxcXCJcXHJcXG4gICAgcmVhZC1vbmx5PVxcXCJyZWFkT25seVxcXCJcXHJcXG4gICAgbmctcmVxdWlyZWQ9XFxcImlzUmVxdWlyZWQoY29tcG9uZW50KVxcXCJcXHJcXG4gICAgY3VzdG9tLXZhbGlkYXRvcj1cXFwiY29tcG9uZW50LnZhbGlkYXRlLmN1c3RvbVxcXCJcXHJcXG4gICAgZ3JpZC1yb3c9XFxcImdyaWRSb3dcXFwiXFxyXFxuICAgIGdyaWQtY29sPVxcXCJncmlkQ29sXFxcIlxcclxcbiAgICBidWlsZGVyPVxcXCJidWlsZGVyXFxcIlxcclxcbiAgPjwvZm9ybWlvLXNlbGVjdC1ib3hlcz5cXHJcXG4gIDxkaXYgbmctaWY9XFxcIiEhY29tcG9uZW50LmRlc2NyaXB0aW9uXFxcIiBjbGFzcz1cXFwiaGVscC1ibG9ja1xcXCI+XFxyXFxuICAgIDxzcGFuPnt7IGNvbXBvbmVudC5kZXNjcmlwdGlvbiB9fTwvc3Bhbj5cXHJcXG4gIDwvZGl2PlxcclxcbiAgPGZvcm1pby1lcnJvcnMgbmctaWY9XFxcIjo6IWJ1aWxkZXJcXFwiPjwvZm9ybWlvLWVycm9ycz5cXHJcXG48L2Rpdj5cXHJcXG5cIlxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIF0pO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcblxyXG52YXIgU2lnbmF0dXJlUGFkID0gcmVxdWlyZSgnc2lnbmF0dXJlX3BhZCcpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFwcCkge1xyXG4gIGFwcC5jb25maWcoW1xyXG4gICAgJ2Zvcm1pb0NvbXBvbmVudHNQcm92aWRlcicsXHJcbiAgICBmdW5jdGlvbihmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIpIHtcclxuICAgICAgZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyLnJlZ2lzdGVyKCdzaWduYXR1cmUnLCB7XHJcbiAgICAgICAgdGl0bGU6ICdTaWduYXR1cmUnLFxyXG4gICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvc2lnbmF0dXJlLmh0bWwnLFxyXG4gICAgICAgIHRhYmxlVmlldzogZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgICAgcmV0dXJuIGRhdGEgPyAnWWVzJyA6ICdObyc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBncm91cDogJ2FkdmFuY2VkJyxcclxuICAgICAgICBzZXR0aW5nczoge1xyXG4gICAgICAgICAgaW5wdXQ6IHRydWUsXHJcbiAgICAgICAgICB0YWJsZVZpZXc6IHRydWUsXHJcbiAgICAgICAgICBsYWJlbDogJycsXHJcbiAgICAgICAgICBrZXk6ICdzaWduYXR1cmUnLFxyXG4gICAgICAgICAgcGxhY2Vob2xkZXI6ICcnLFxyXG4gICAgICAgICAgZm9vdGVyOiAnU2lnbiBhYm92ZScsXHJcbiAgICAgICAgICB3aWR0aDogJzEwMCUnLFxyXG4gICAgICAgICAgaGVpZ2h0OiAnMTUwJyxcclxuICAgICAgICAgIHBlbkNvbG9yOiAnYmxhY2snLFxyXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiKDI0NSwyNDUsMjM1KScsXHJcbiAgICAgICAgICBtaW5XaWR0aDogJzAuNScsXHJcbiAgICAgICAgICBtYXhXaWR0aDogJzIuNScsXHJcbiAgICAgICAgICBwcm90ZWN0ZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgcGVyc2lzdGVudDogdHJ1ZSxcclxuICAgICAgICAgIGhpZGRlbjogZmFsc2UsXHJcbiAgICAgICAgICBjbGVhck9uSGlkZTogdHJ1ZSxcclxuICAgICAgICAgIHZhbGlkYXRlOiB7XHJcbiAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdmlld1RlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHNWaWV3L3NpZ25hdHVyZS5odG1sJ1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICBdKTtcclxuICBhcHAuZGlyZWN0aXZlKCdzaWduYXR1cmUnLCBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHJlc3RyaWN0OiAnQScsXHJcbiAgICAgIHNjb3BlOiB7XHJcbiAgICAgICAgY29tcG9uZW50OiAnPSdcclxuICAgICAgfSxcclxuICAgICAgcmVxdWlyZTogJz9uZ01vZGVsJyxcclxuICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBuZ01vZGVsKSB7XHJcbiAgICAgICAgaWYgKHNjb3BlLmJ1aWxkZXIpIHJldHVybjtcclxuICAgICAgICBpZiAoIW5nTW9kZWwpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFNldHMgdGhlIGxhYmVsIG9mIGNvbXBvbmVudCBmb3IgZXJyb3IgZGlzcGxheS5cclxuICAgICAgICBzY29wZS5jb21wb25lbnQubGFiZWwgPSAnU2lnbmF0dXJlJztcclxuICAgICAgICBzY29wZS5jb21wb25lbnQuaGlkZUxhYmVsID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gU2V0cyB0aGUgZGltZW5zaW9uIG9mIGEgd2lkdGggb3IgaGVpZ2h0LlxyXG4gICAgICAgIHZhciBzZXREaW1lbnNpb24gPSBmdW5jdGlvbihkaW0pIHtcclxuICAgICAgICAgIHZhciBwYXJhbSA9IChkaW0gPT09ICd3aWR0aCcpID8gJ2NsaWVudFdpZHRoJyA6ICdjbGllbnRIZWlnaHQnO1xyXG4gICAgICAgICAgaWYgKHNjb3BlLmNvbXBvbmVudFtkaW1dLnNsaWNlKC0xKSA9PT0gJyUnKSB7XHJcbiAgICAgICAgICAgIHZhciBwZXJjZW50ID0gcGFyc2VGbG9hdChzY29wZS5jb21wb25lbnRbZGltXS5zbGljZSgwLCAtMSkpIC8gMTAwO1xyXG4gICAgICAgICAgICBlbGVtZW50WzBdW2RpbV0gPSBlbGVtZW50LnBhcmVudCgpLmVxKDApWzBdW3BhcmFtXSAqIHBlcmNlbnQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZWxlbWVudFswXVtkaW1dID0gcGFyc2VJbnQoc2NvcGUuY29tcG9uZW50W2RpbV0sIDEwKTtcclxuICAgICAgICAgICAgc2NvcGUuY29tcG9uZW50W2RpbV0gPSBlbGVtZW50WzBdW2RpbV0gKyAncHgnO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIFNldCB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgY2FudmFzLlxyXG4gICAgICAgIC8vIFJlc2V0IHNpemUgaWYgZWxlbWVudCBjaGFuZ2VzIHZpc2liaWxpdHkuXHJcbiAgICAgICAgc2NvcGUuJHdhdGNoKCdjb21wb25lbnQuZGlzcGxheScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgc2V0RGltZW5zaW9uKCd3aWR0aCcpO1xyXG4gICAgICAgICAgc2V0RGltZW5zaW9uKCdoZWlnaHQnKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBzaWduYXR1cmUgcGFkLlxyXG4gICAgICAgIHZhciBzaWduYXR1cmVQYWQgPSBuZXcgU2lnbmF0dXJlUGFkKGVsZW1lbnRbMF0sIHtcclxuICAgICAgICAgIG1pbldpZHRoOiBzY29wZS5jb21wb25lbnQubWluV2lkdGgsXHJcbiAgICAgICAgICBtYXhXaWR0aDogc2NvcGUuY29tcG9uZW50Lm1heFdpZHRoLFxyXG4gICAgICAgICAgcGVuQ29sb3I6IHNjb3BlLmNvbXBvbmVudC5wZW5Db2xvcixcclxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogc2NvcGUuY29tcG9uZW50LmJhY2tncm91bmRDb2xvclxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBzY29wZS4kd2F0Y2goJ2NvbXBvbmVudC5wZW5Db2xvcicsIGZ1bmN0aW9uKG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgICBzaWduYXR1cmVQYWQucGVuQ29sb3IgPSBuZXdWYWx1ZTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgc2NvcGUuJHdhdGNoKCdjb21wb25lbnQuYmFja2dyb3VuZENvbG9yJywgZnVuY3Rpb24obmV3VmFsdWUpIHtcclxuICAgICAgICAgIHNpZ25hdHVyZVBhZC5iYWNrZ3JvdW5kQ29sb3IgPSBuZXdWYWx1ZTtcclxuICAgICAgICAgIHNpZ25hdHVyZVBhZC5jbGVhcigpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBDbGVhciB0aGUgc2lnbmF0dXJlLlxyXG4gICAgICAgIHNjb3BlLmNvbXBvbmVudC5jbGVhclNpZ25hdHVyZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgc2lnbmF0dXJlUGFkLmNsZWFyKCk7XHJcbiAgICAgICAgICByZWFkU2lnbmF0dXJlKCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gU2V0IHNvbWUgQ1NTIHByb3BlcnRpZXMuXHJcbiAgICAgICAgZWxlbWVudC5jc3Moe1xyXG4gICAgICAgICAgJ2JvcmRlci1yYWRpdXMnOiAnNHB4JyxcclxuICAgICAgICAgICdib3gtc2hhZG93JzogJzAgMCA1cHggcmdiYSgwLCAwLCAwLCAwLjAyKSBpbnNldCcsXHJcbiAgICAgICAgICAnYm9yZGVyJzogJzFweCBzb2xpZCAjZjRmNGY0J1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkU2lnbmF0dXJlKCkge1xyXG4gICAgICAgICAgaWYgKHNjb3BlLiRwYXJlbnQuaXNSZXF1aXJlZChzY29wZS5jb21wb25lbnQpICYmIHNpZ25hdHVyZVBhZC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgbmdNb2RlbC4kc2V0Vmlld1ZhbHVlKCcnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBuZ01vZGVsLiRzZXRWaWV3VmFsdWUoc2lnbmF0dXJlUGFkLnRvRGF0YVVSTCgpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG5nTW9kZWwuJHJlbmRlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgc2lnbmF0dXJlUGFkLmZyb21EYXRhVVJMKG5nTW9kZWwuJHZpZXdWYWx1ZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBzaWduYXR1cmVQYWQub25FbmQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHNjb3BlLiRldmFsQXN5bmMocmVhZFNpZ25hdHVyZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9KTtcclxuICBhcHAucnVuKFtcclxuICAgICckdGVtcGxhdGVDYWNoZScsXHJcbiAgICAnRm9ybWlvVXRpbHMnLFxyXG4gICAgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUsXHJcbiAgICAgICAgICAgICAgRm9ybWlvVXRpbHMpIHtcclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9zaWduYXR1cmUuaHRtbCcsIEZvcm1pb1V0aWxzLmZpZWxkV3JhcChcclxuICAgICAgICBcIjxkaXYgbmctaWY9XFxcInJlYWRPbmx5XFxcIj5cXHJcXG4gIDxkaXYgbmctaWY9XFxcImRhdGFbY29tcG9uZW50LmtleV0gPT09ICdZRVMnXFxcIj5cXHJcXG4gICAgWyBTaWduYXR1cmUgaXMgaGlkZGVuIF1cXHJcXG4gIDwvZGl2PlxcclxcbiAgPGRpdiBuZy1pZj1cXFwiZGF0YVtjb21wb25lbnQua2V5XSAhPT0gJ1lFUydcXFwiPlxcclxcbiAgICA8aW1nIGNsYXNzPVxcXCJzaWduYXR1cmVcXFwiIG5nLWF0dHItc3JjPVxcXCJ7e2RhdGFbY29tcG9uZW50LmtleV19fVxcXCIgc3JjPVxcXCJcXFwiIC8+XFxyXFxuICA8L2Rpdj5cXHJcXG48L2Rpdj5cXHJcXG48ZGl2IG5nLWlmPVxcXCIhcmVhZE9ubHlcXFwiIHN0eWxlPVxcXCJ3aWR0aDoge3sgY29tcG9uZW50LndpZHRoIH19OyBoZWlnaHQ6IDEwMCVcXFwiPlxcclxcbiAgPGEgY2xhc3M9XFxcImJ0biBidG4teHMgYnRuLWRlZmF1bHRcXFwiIHN0eWxlPVxcXCJwb3NpdGlvbjphYnNvbHV0ZTsgbGVmdDogMDsgdG9wOiAwOyB6LWluZGV4OiAxMDAwXFxcIiBuZy1jbGljaz1cXFwiY29tcG9uZW50LmNsZWFyU2lnbmF0dXJlKClcXFwiPlxcclxcbiAgICA8c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1yZWZyZXNoXFxcIj48L3NwYW4+XFxyXFxuICA8L2E+XFxyXFxuICA8Y2FudmFzIHNpZ25hdHVyZSBjb21wb25lbnQ9XFxcImNvbXBvbmVudFxcXCIgbmFtZT1cXFwie3sgY29tcG9uZW50SWQgfX1cXFwiIG5nLW1vZGVsPVxcXCJkYXRhW2NvbXBvbmVudC5rZXldXFxcIiBuZy1yZXF1aXJlZD1cXFwiaXNSZXF1aXJlZChjb21wb25lbnQpXFxcIj48L2NhbnZhcz5cXHJcXG4gIDxkaXYgY2xhc3M9XFxcImZvcm1pby1zaWduYXR1cmUtZm9vdGVyXFxcIiBzdHlsZT1cXFwidGV4dC1hbGlnbjogY2VudGVyO2NvbG9yOiNDM0MzQzM7XFxcIiBuZy1jbGFzcz1cXFwieydmaWVsZC1yZXF1aXJlZCc6IGlzUmVxdWlyZWQoY29tcG9uZW50KX1cXFwiPnt7IGNvbXBvbmVudC5mb290ZXIgfCBmb3JtaW9UcmFuc2xhdGU6bnVsbDpidWlsZGVyIH19PC9kaXY+XFxyXFxuPC9kaXY+XFxyXFxuXCJcclxuICAgICAgKSk7XHJcblxyXG4gICAgICAkdGVtcGxhdGVDYWNoZS5wdXQoJ2Zvcm1pby9jb21wb25lbnRzVmlldy9zaWduYXR1cmUuaHRtbCcsIEZvcm1pb1V0aWxzLmZpZWxkV3JhcChcclxuICAgICAgICBcIjxkaXYgbmctaWY9XFxcImRhdGFbY29tcG9uZW50LmtleV0gPT09ICdZRVMnXFxcIj5cXHJcXG4gIFsgU2lnbmF0dXJlIGlzIGhpZGRlbiBdXFxyXFxuPC9kaXY+XFxyXFxuPGRpdiBuZy1pZj1cXFwiZGF0YVtjb21wb25lbnQua2V5XSAmJiAoZGF0YVtjb21wb25lbnQua2V5XSAhPT0gJ1lFUycpXFxcIj5cXHJcXG4gIDxpbWcgY2xhc3M9XFxcInNpZ25hdHVyZVxcXCIgbmctYXR0ci1zcmM9XFxcInt7IGRhdGFbY29tcG9uZW50LmtleV0gfX1cXFwiIHNyYz1cXFwiXFxcIiAvPlxcclxcbjwvZGl2PlxcclxcbjxkaXYgY2xhc3M9XFxcIndlbGwgdGV4dC1jZW50ZXJcXFwiIG5nLWlmPVxcXCIhZGF0YVtjb21wb25lbnQua2V5XSB8fCAoZGF0YVtjb21wb25lbnQua2V5XSA9PT0gJ05PJylcXFwiPlxcclxcbiAgPHN0cm9uZz5ObyBzaWduYXR1cmUgcHJvdmlkZWQ8L3N0cm9uZz5cXHJcXG48L2Rpdj5cXHJcXG5cIlxyXG4gICAgICApKTtcclxuICAgIH1cclxuICBdKTtcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBwKSB7XHJcbiAgYXBwLmNvbmZpZyhbXHJcbiAgICAnZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyJyxcclxuICAgIGZ1bmN0aW9uKGZvcm1pb0NvbXBvbmVudHNQcm92aWRlcikge1xyXG4gICAgICBmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIucmVnaXN0ZXIoJ3N1cnZleScsIHtcclxuICAgICAgICB0aXRsZTogJ1N1cnZleScsXHJcbiAgICAgICAgdGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50cy9zdXJ2ZXkuaHRtbCcsXHJcbiAgICAgICAgZ3JvdXA6ICdhZHZhbmNlZCcsXHJcbiAgICAgICAgdGFibGVWaWV3OiBmdW5jdGlvbihkYXRhLCBjb21wb25lbnQpIHtcclxuICAgICAgICAgIHZhciB2aWV3ID0gJzx0YWJsZSBjbGFzcz1cInRhYmxlIHRhYmxlLXN0cmlwZWQgdGFibGUtYm9yZGVyZWRcIj48dGhlYWQ+JztcclxuICAgICAgICAgIHZhciB2YWx1ZXMgPSB7fTtcclxuICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChjb21wb25lbnQudmFsdWVzLCBmdW5jdGlvbih2KSB7XHJcbiAgICAgICAgICAgIHZhbHVlc1t2LnZhbHVlXSA9IHYubGFiZWw7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChjb21wb25lbnQucXVlc3Rpb25zLCBmdW5jdGlvbihxdWVzdGlvbikge1xyXG4gICAgICAgICAgICB2aWV3ICs9ICc8dHI+JztcclxuICAgICAgICAgICAgdmlldyArPSAnPHRoPicgKyBxdWVzdGlvbi5sYWJlbCArICc8L3RoPic7XHJcbiAgICAgICAgICAgIHZpZXcgKz0gJzx0ZD4nICsgdmFsdWVzW2RhdGFbcXVlc3Rpb24udmFsdWVdXSArICc8L3RkPic7XHJcbiAgICAgICAgICAgIHZpZXcgKz0gJzwvdHI+JztcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgdmlldyArPSAnPC90Ym9keT48L3RhYmxlPic7XHJcbiAgICAgICAgICByZXR1cm4gdmlldztcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldHRpbmdzOiB7XHJcbiAgICAgICAgICBpbnB1dDogdHJ1ZSxcclxuICAgICAgICAgIHRhYmxlVmlldzogdHJ1ZSxcclxuICAgICAgICAgIGxhYmVsOiAnJyxcclxuICAgICAgICAgIGtleTogJ3N1cnZleScsXHJcbiAgICAgICAgICBxdWVzdGlvbnM6IFtdLFxyXG4gICAgICAgICAgdmFsdWVzOiBbXSxcclxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogJycsXHJcbiAgICAgICAgICBwcm90ZWN0ZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgcGVyc2lzdGVudDogdHJ1ZSxcclxuICAgICAgICAgIGhpZGRlbjogZmFsc2UsXHJcbiAgICAgICAgICBjbGVhck9uSGlkZTogdHJ1ZSxcclxuICAgICAgICAgIHZhbGlkYXRlOiB7XHJcbiAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcclxuICAgICAgICAgICAgY3VzdG9tOiAnJyxcclxuICAgICAgICAgICAgY3VzdG9tUHJpdmF0ZTogZmFsc2VcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIF0pO1xyXG4gIGFwcC5ydW4oW1xyXG4gICAgJyR0ZW1wbGF0ZUNhY2hlJyxcclxuICAgICdGb3JtaW9VdGlscycsXHJcbiAgICBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSwgRm9ybWlvVXRpbHMpIHtcclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy9zdXJ2ZXkuaHRtbCcsIEZvcm1pb1V0aWxzLmZpZWxkV3JhcChcclxuICAgICAgICBcIjx0YWJsZSBjbGFzcz1cXFwidGFibGUgdGFibGUtc3RyaXBlZCB0YWJsZS1ib3JkZXJlZFxcXCI+XFxyXFxuICA8dGhlYWQ+XFxyXFxuICAgIDx0cj5cXHJcXG4gICAgICA8dGQ+PC90ZD5cXHJcXG4gICAgICA8dGggbmctcmVwZWF0PVxcXCJ2IGluIGNvbXBvbmVudC52YWx1ZXMgdHJhY2sgYnkgJGluZGV4XFxcIiBzdHlsZT1cXFwidGV4dC1hbGlnbjogY2VudGVyO1xcXCI+e3sgdi5sYWJlbCB9fTwvdGg+XFxyXFxuICAgIDwvdHI+XFxyXFxuICA8L3RoZWFkPlxcclxcbiAgPHRyIG5nLXJlcGVhdD1cXFwicXVlc3Rpb24gaW4gY29tcG9uZW50LnF1ZXN0aW9uc1xcXCI+XFxyXFxuICAgIDx0ZD57eyBxdWVzdGlvbi5sYWJlbCB9fTwvdGQ+XFxyXFxuICAgIDx0ZCBuZy1yZXBlYXQ9XFxcInYgaW4gY29tcG9uZW50LnZhbHVlcyB0cmFjayBieSAkaW5kZXhcXFwiIHN0eWxlPVxcXCJ0ZXh0LWFsaWduOiBjZW50ZXI7XFxcIj5cXHJcXG4gICAgICA8aW5wdXRcXHJcXG4gICAgICAgIHR5cGU9XFxcInJhZGlvXFxcIlxcclxcbiAgICAgICAgaWQ9XFxcInt7IGNvbXBvbmVudElkIH19LXt7IHF1ZXN0aW9uLnZhbHVlIH19LXt7IHYudmFsdWUgfX1cXFwiIG5hbWU9XFxcInt7IGNvbXBvbmVudElkIH19LXt7IHF1ZXN0aW9uLnZhbHVlIH19XFxcIlxcclxcbiAgICAgICAgdGFiaW5kZXg9XFxcInt7IGNvbXBvbmVudC50YWJpbmRleCB8fCAwIH19XFxcIlxcclxcbiAgICAgICAgbmctdmFsdWU9XFxcInYudmFsdWVcXFwiXFxyXFxuICAgICAgICBuZy1tb2RlbD1cXFwiZGF0YVtjb21wb25lbnQua2V5XVtxdWVzdGlvbi52YWx1ZV1cXFwiXFxyXFxuICAgICAgICBuZy1yZXF1aXJlZD1cXFwiaXNSZXF1aXJlZChjb21wb25lbnQpXFxcIlxcclxcbiAgICAgICAgbmctZGlzYWJsZWQ9XFxcInJlYWRPbmx5XFxcIlxcclxcbiAgICAgICAgY3VzdG9tLXZhbGlkYXRvcj1cXFwiY29tcG9uZW50LnZhbGlkYXRlLmN1c3RvbVxcXCJcXHJcXG4gICAgICA+XFxyXFxuICAgIDwvdGQ+XFxyXFxuICA8L3RyPlxcclxcbjwvdGFibGU+XFxyXFxuXCJcclxuICAgICAgKSk7XHJcbiAgICB9XHJcbiAgXSk7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xuXHJcbnZhciBHcmlkVXRpbHMgPSByZXF1aXJlKCcuLi9mYWN0b3JpZXMvR3JpZFV0aWxzJykoKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBwKSB7XHJcbiAgYXBwLmNvbmZpZyhbXHJcbiAgICAnZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyJyxcclxuICAgIGZ1bmN0aW9uKGZvcm1pb0NvbXBvbmVudHNQcm92aWRlcikge1xyXG4gICAgICBmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIucmVnaXN0ZXIoJ3RhYmxlJywge1xyXG4gICAgICAgIHRpdGxlOiAnVGFibGUnLFxyXG4gICAgICAgIHRlbXBsYXRlOiAnZm9ybWlvL2NvbXBvbmVudHMvdGFibGUuaHRtbCcsXHJcbiAgICAgICAgZ3JvdXA6ICdsYXlvdXQnLFxyXG4gICAgICAgIHNldHRpbmdzOiB7XHJcbiAgICAgICAgICBpbnB1dDogZmFsc2UsXHJcbiAgICAgICAgICBrZXk6ICd0YWJsZScsXHJcbiAgICAgICAgICBudW1Sb3dzOiAzLFxyXG4gICAgICAgICAgbnVtQ29sczogMyxcclxuICAgICAgICAgIHJvd3M6IFtbe2NvbXBvbmVudHM6IFtdfSwge2NvbXBvbmVudHM6IFtdfSwge2NvbXBvbmVudHM6IFtdfV0sIFt7Y29tcG9uZW50czogW119LCB7Y29tcG9uZW50czogW119LCB7Y29tcG9uZW50czogW119XSwgW3tjb21wb25lbnRzOiBbXX0sIHtjb21wb25lbnRzOiBbXX0sIHtjb21wb25lbnRzOiBbXX1dXSxcclxuICAgICAgICAgIGhlYWRlcjogW10sXHJcbiAgICAgICAgICBjYXB0aW9uOiAnJyxcclxuICAgICAgICAgIHN0cmlwZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgYm9yZGVyZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgaG92ZXI6IGZhbHNlLFxyXG4gICAgICAgICAgY29uZGVuc2VkOiBmYWxzZSxcclxuICAgICAgICAgIHRhYmxlVmlldzogdHJ1ZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdGFibGVWaWV3OiBmdW5jdGlvbihkYXRhLCBjb21wb25lbnQsICRpbnRlcnBvbGF0ZSwgY29tcG9uZW50SW5mbywgdGFibGVDaGlsZCkge1xyXG4gICAgICAgICAgdmFyIHZpZXcgPSAnPHRhYmxlIGNsYXNzPVwidGFibGUgdGFibGUtc3RyaXBlZCB0YWJsZS1ib3JkZXJlZCB0YWJsZS1jaGlsZFwiPic7XHJcblxyXG4gICAgICAgICAgaWYgKCF0YWJsZUNoaWxkKSB7XHJcbiAgICAgICAgICAgIHZpZXcgKz0gJzx0aGVhZD4nO1xyXG4gICAgICAgICAgICB2aWV3ICs9ICc8dHI+PHRoPlRhYmxlICgnICsgY29tcG9uZW50LmtleSArICcpPC90aD48L3RyPic7XHJcbiAgICAgICAgICAgIHZpZXcgKz0gJzwvdGhlYWQ+JztcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB2aWV3ICs9ICc8dGJvZHk+JztcclxuXHJcbiAgICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCB0aGlzLnNldHRpbmdzLm51bVJvd3M7IHJvdysrKSB7XHJcbiAgICAgICAgICAgIHZpZXcgKz0gJzx0cj4nO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCB0aGlzLnNldHRpbmdzLm51bUNvbHM7IGNvbCsrKSB7XHJcbiAgICAgICAgICAgICAgdmlldyArPSAnPHRkPic7XHJcbiAgICAgICAgICAgICAgLy8gRWFjaCBjb2x1bW4gaXMgaXRzIG93biB0YWJsZS5cclxuICAgICAgICAgICAgICB2aWV3ICs9ICc8dGFibGUgY2xhc3M9XCJ0YWJsZSB0YWJsZS1zdHJpcGVkIHRhYmxlLWJvcmRlcmVkIHRhYmxlLWNoaWxkXCI+JztcclxuICAgICAgICAgICAgICB2aWV3ICs9ICc8dGJvZHk+JztcclxuICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goY29tcG9uZW50LnJvd3Nbcm93XVtjb2xdLmNvbXBvbmVudHMsIGZ1bmN0aW9uKGNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgICAgdmlldyArPSAnPHRyPicgKyBHcmlkVXRpbHMuY29sdW1uRm9yQ29tcG9uZW50KGRhdGEsIGNvbXBvbmVudCwgJGludGVycG9sYXRlLCBjb21wb25lbnRJbmZvKSArICc8L3RyPic7XHJcbiAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgIHZpZXcgKz0gJzwvdGJvZHk+PC90YWJsZT4nO1xyXG4gICAgICAgICAgICAgIHZpZXcgKz0gJzwvdGQ+JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2aWV3ICs9ICc8L3RyPic7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdmlldyArPSAnPC90Ym9keT48L3RhYmxlPic7XHJcbiAgICAgICAgICByZXR1cm4gdmlldztcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIF0pO1xyXG4gIGFwcC5ydW4oW1xyXG4gICAgJyR0ZW1wbGF0ZUNhY2hlJyxcclxuICAgIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgICAgIHZhciB0YWJsZUNsYXNzZXMgPSBcInsndGFibGUtc3RyaXBlZCc6IGNvbXBvbmVudC5zdHJpcGVkLCBcIjtcclxuICAgICAgdGFibGVDbGFzc2VzICs9IFwiJ3RhYmxlLWJvcmRlcmVkJzogY29tcG9uZW50LmJvcmRlcmVkLCBcIjtcclxuICAgICAgdGFibGVDbGFzc2VzICs9IFwiJ3RhYmxlLWhvdmVyJzogY29tcG9uZW50LmhvdmVyLCBcIjtcclxuICAgICAgdGFibGVDbGFzc2VzICs9IFwiJ3RhYmxlLWNvbmRlbnNlZCc6IGNvbXBvbmVudC5jb25kZW5zZWR9XCI7XHJcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvdGFibGUuaHRtbCcsXHJcbiAgICAgICAgXCI8ZGl2IGNsYXNzPVxcXCJ0YWJsZS1yZXNwb25zaXZlXFxcIiBpZD1cXFwie3sgY29tcG9uZW50LmtleSB9fVxcXCI+XFxyXFxuICA8dGFibGUgbmctY2xhc3M9XFxcInsndGFibGUtc3RyaXBlZCc6IGNvbXBvbmVudC5zdHJpcGVkLCAndGFibGUtYm9yZGVyZWQnOiBjb21wb25lbnQuYm9yZGVyZWQsICd0YWJsZS1ob3Zlcic6IGNvbXBvbmVudC5ob3ZlciwgJ3RhYmxlLWNvbmRlbnNlZCc6IGNvbXBvbmVudC5jb25kZW5zZWR9XFxcIiBjbGFzcz1cXFwidGFibGVcXFwiPlxcclxcbiAgICA8dGhlYWQgbmctaWY9XFxcImNvbXBvbmVudC5oZWFkZXIubGVuZ3RoXFxcIj5cXHJcXG4gICAgICA8dGggbmctcmVwZWF0PVxcXCJoZWFkZXIgaW4gY29tcG9uZW50LmhlYWRlciB0cmFjayBieSAkaW5kZXhcXFwiPnt7IGhlYWRlciB8IGZvcm1pb1RyYW5zbGF0ZTpudWxsOmJ1aWxkZXIgfX08L3RoPlxcclxcbiAgICA8L3RoZWFkPlxcclxcbiAgICA8dGJvZHk+XFxyXFxuICAgICAgPHRyIG5nLXJlcGVhdD1cXFwicm93IGluIGNvbXBvbmVudC5yb3dzIHRyYWNrIGJ5ICRpbmRleFxcXCI+XFxyXFxuICAgICAgICA8dGQgbmctcmVwZWF0PVxcXCJjb2x1bW4gaW4gcm93IHRyYWNrIGJ5ICRpbmRleFxcXCI+XFxyXFxuICAgICAgICAgIDxmb3JtaW8tY29tcG9uZW50XFxyXFxuICAgICAgICAgICAgbmctcmVwZWF0PVxcXCJfY29tcG9uZW50IGluIGNvbHVtbi5jb21wb25lbnRzIHRyYWNrIGJ5ICRpbmRleFxcXCJcXHJcXG4gICAgICAgICAgICBjb21wb25lbnQ9XFxcIl9jb21wb25lbnRcXFwiXFxyXFxuICAgICAgICAgICAgZGF0YT1cXFwiZGF0YVxcXCJcXHJcXG4gICAgICAgICAgICBmb3JtaW89XFxcImZvcm1pb1xcXCJcXHJcXG4gICAgICAgICAgICBzdWJtaXNzaW9uPVxcXCJzdWJtaXNzaW9uXFxcIlxcclxcbiAgICAgICAgICAgIGhpZGUtY29tcG9uZW50cz1cXFwiaGlkZUNvbXBvbmVudHNcXFwiXFxyXFxuICAgICAgICAgICAgbmctaWY9XFxcImJ1aWxkZXIgPyAnOjp0cnVlJyA6IGlzVmlzaWJsZShfY29tcG9uZW50LCBkYXRhKVxcXCJcXHJcXG4gICAgICAgICAgICBmb3JtaW8tZm9ybT1cXFwiZm9ybWlvRm9ybVxcXCJcXHJcXG4gICAgICAgICAgICByZWFkLW9ubHk9XFxcImlzRGlzYWJsZWQoX2NvbXBvbmVudCwgZGF0YSlcXFwiXFxyXFxuICAgICAgICAgICAgZ3JpZC1yb3c9XFxcImdyaWRSb3dcXFwiXFxyXFxuICAgICAgICAgICAgZ3JpZC1jb2w9XFxcImdyaWRDb2xcXFwiXFxyXFxuICAgICAgICAgICAgYnVpbGRlcj1cXFwiYnVpbGRlclxcXCJcXHJcXG4gICAgICAgICAgPjwvZm9ybWlvLWNvbXBvbmVudD5cXHJcXG4gICAgICAgIDwvdGQ+XFxyXFxuICAgICAgPC90cj5cXHJcXG4gICAgPC90Ym9keT5cXHJcXG4gIDwvdGFibGU+XFxyXFxuPC9kaXY+XFxyXFxuXCJcclxuICAgICAgKTtcclxuXHJcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHNWaWV3L3RhYmxlLmh0bWwnLFxyXG4gICAgICAgIFwiPGRpdiBjbGFzcz1cXFwidGFibGUtcmVzcG9uc2l2ZVxcXCIgaWQ9XFxcInt7IGNvbXBvbmVudC5rZXkgfX1cXFwiPlxcclxcbiAgPHRhYmxlIG5nLWNsYXNzPVxcXCJ7J3RhYmxlLXN0cmlwZWQnOiBjb21wb25lbnQuc3RyaXBlZCwgJ3RhYmxlLWJvcmRlcmVkJzogY29tcG9uZW50LmJvcmRlcmVkLCAndGFibGUtaG92ZXInOiBjb21wb25lbnQuaG92ZXIsICd0YWJsZS1jb25kZW5zZWQnOiBjb21wb25lbnQuY29uZGVuc2VkfVxcXCIgY2xhc3M9XFxcInRhYmxlXFxcIj5cXHJcXG4gICAgPHRoZWFkIG5nLWlmPVxcXCJjb21wb25lbnQuaGVhZGVyLmxlbmd0aFxcXCI+XFxyXFxuICAgICAgPHRoIG5nLXJlcGVhdD1cXFwiaGVhZGVyIGluIGNvbXBvbmVudC5oZWFkZXIgdHJhY2sgYnkgJGluZGV4XFxcIj57eyBoZWFkZXIgfX08L3RoPlxcclxcbiAgICA8L3RoZWFkPlxcclxcbiAgICA8dGJvZHk+XFxyXFxuICAgICAgPHRyIG5nLXJlcGVhdD1cXFwicm93IGluIGNvbXBvbmVudC5yb3dzIHRyYWNrIGJ5ICRpbmRleFxcXCI+XFxyXFxuICAgICAgICA8dGQgbmctcmVwZWF0PVxcXCJjb2x1bW4gaW4gcm93IHRyYWNrIGJ5ICRpbmRleFxcXCI+XFxyXFxuICAgICAgICAgIDxmb3JtaW8tY29tcG9uZW50LXZpZXdcXHJcXG4gICAgICAgICAgICBuZy1yZXBlYXQ9XFxcIl9jb21wb25lbnQgaW4gY29sdW1uLmNvbXBvbmVudHMgdHJhY2sgYnkgJGluZGV4XFxcIlxcclxcbiAgICAgICAgICAgIGNvbXBvbmVudD1cXFwiX2NvbXBvbmVudFxcXCJcXHJcXG4gICAgICAgICAgICBkYXRhPVxcXCJkYXRhXFxcIlxcclxcbiAgICAgICAgICAgIGZvcm09XFxcImZvcm1cXFwiXFxyXFxuICAgICAgICAgICAgc3VibWlzc2lvbj1cXFwic3VibWlzc2lvblxcXCJcXHJcXG4gICAgICAgICAgICBpZ25vcmU9XFxcImlnbm9yZVxcXCJcXHJcXG4gICAgICAgICAgICBuZy1pZj1cXFwiYnVpbGRlciA/ICc6OnRydWUnIDogaXNWaXNpYmxlKF9jb21wb25lbnQsIGRhdGEpXFxcIlxcclxcbiAgICAgICAgICAgIGJ1aWxkZXI9XFxcImJ1aWxkZXJcXFwiXFxyXFxuICAgICAgICAgID48L2Zvcm1pby1jb21wb25lbnQtdmlldz5cXHJcXG4gICAgICAgIDwvdGQ+XFxyXFxuICAgICAgPC90cj5cXHJcXG4gICAgPC90Ym9keT5cXHJcXG4gIDwvdGFibGU+XFxyXFxuPC9kaXY+XFxyXFxuXCJcclxuICAgICAgKTtcclxuICAgIH1cclxuICBdKTtcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcHApIHtcclxuICBhcHAuY29uZmlnKFtcclxuICAgICdmb3JtaW9Db21wb25lbnRzUHJvdmlkZXInLFxyXG4gICAgZnVuY3Rpb24oZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyKSB7XHJcbiAgICAgIGZvcm1pb0NvbXBvbmVudHNQcm92aWRlci5yZWdpc3RlcigndGV4dGFyZWEnLCB7XHJcbiAgICAgICAgdGl0bGU6ICdUZXh0IEFyZWEnLFxyXG4gICAgICAgIHRlbXBsYXRlOiBmdW5jdGlvbigkc2NvcGUpIHtcclxuICAgICAgICAgIGlmICghJHNjb3BlLnJlYWRPbmx5ICYmICRzY29wZS5jb21wb25lbnQud3lzaXd5Zykge1xyXG4gICAgICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XHJcbiAgICAgICAgICAgICAgdG9vbGJhckdyb3VwczogIFtcclxuICAgICAgICAgICAgICAgIHtuYW1lOiAnYmFzaWNzdHlsZXMnLCBncm91cHM6IFsnYmFzaWNzdHlsZXMnLCAnY2xlYW51cCddfSxcclxuICAgICAgICAgICAgICAgIHtuYW1lOiAncGFyYWdyYXBoJywgZ3JvdXBzOiBbJ2xpc3QnLCAnaW5kZW50JywgJ2Jsb2NrcycsICdhbGlnbicsICdiaWRpJywgJ3BhcmFncmFwaCcsICctJywgJ0p1c3RpZnlMZWZ0JywgJ0p1c3RpZnlDZW50ZXInLCAnSnVzdGlmeVJpZ2h0JywgJ0p1c3RpZnlCbG9jayddfSxcclxuICAgICAgICAgICAgICAgIHtuYW1lOiAnbGlua3MnLCBncm91cHM6IFsnbGlua3MnXX0sXHJcbiAgICAgICAgICAgICAgICB7bmFtZTogJ2luc2VydCcsIGdyb3VwczogWydpbnNlcnQnXX0sXHJcbiAgICAgICAgICAgICAgICAnLycsXHJcbiAgICAgICAgICAgICAgICB7bmFtZTogJ3N0eWxlcycsIGdyb3VwczogWydTdHlsZXMnLCAnRm9ybWF0JywgJ0ZvbnQnLCAnRm9udFNpemUnXX0sXHJcbiAgICAgICAgICAgICAgICB7bmFtZTogJ2NvbG9ycycsIGdyb3VwczogWydjb2xvcnMnXX0sXHJcbiAgICAgICAgICAgICAgICB7bmFtZTogJ2NsaXBib2FyZCcsIGdyb3VwczogWydjbGlwYm9hcmQnLCAndW5kbyddfSxcclxuICAgICAgICAgICAgICAgIHtuYW1lOiAnZWRpdGluZycsIGdyb3VwczogWydmaW5kJywgJ3NlbGVjdGlvbicsICdzcGVsbGNoZWNrZXInLCAnZWRpdGluZyddfSxcclxuICAgICAgICAgICAgICAgIHtuYW1lOiAnZG9jdW1lbnQnLCBncm91cHM6IFsnbW9kZScsICdkb2N1bWVudCcsICdkb2N0b29scyddfSxcclxuICAgICAgICAgICAgICAgIHtuYW1lOiAnb3RoZXJzJywgZ3JvdXBzOiBbJ290aGVycyddfSxcclxuICAgICAgICAgICAgICAgIHtuYW1lOiAndG9vbHMnLCBncm91cHM6IFsndG9vbHMnXX1cclxuICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgIGV4dHJhUGx1Z2luczogJ2p1c3RpZnksZm9udCcsXHJcbiAgICAgICAgICAgICAgcmVtb3ZlQnV0dG9uczogJ0N1dCxDb3B5LFBhc3RlLFVuZGVybGluZSxTdWJzY3JpcHQsU3VwZXJzY3JpcHQsU2NheXQsQWJvdXQnLFxyXG4gICAgICAgICAgICAgIHVpQ29sb3I6ICcjZWVlZWVlJyxcclxuICAgICAgICAgICAgICBoZWlnaHQ6ICc0MDBweCcsXHJcbiAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJ1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAoJHNjb3BlLmNvbXBvbmVudC53eXNpd3lnID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgJHNjb3BlLmNvbXBvbmVudC53eXNpd3lnID0gZGVmYXVsdHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgJHNjb3BlLmNvbXBvbmVudC53eXNpd3lnID0gYW5ndWxhci5leHRlbmQoZGVmYXVsdHMsICRzY29wZS5jb21wb25lbnQud3lzaXd5Zyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICdmb3JtaW8vY29tcG9uZW50cy90ZXh0ZWRpdG9yLmh0bWwnO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuICdmb3JtaW8vY29tcG9uZW50cy90ZXh0YXJlYS5odG1sJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldHRpbmdzOiB7XHJcbiAgICAgICAgICBpbnB1dDogdHJ1ZSxcclxuICAgICAgICAgIHRhYmxlVmlldzogdHJ1ZSxcclxuICAgICAgICAgIGxhYmVsOiAnJyxcclxuICAgICAgICAgIGtleTogJ3RleHRhcmVhRmllbGQnLFxyXG4gICAgICAgICAgcGxhY2Vob2xkZXI6ICcnLFxyXG4gICAgICAgICAgcHJlZml4OiAnJyxcclxuICAgICAgICAgIHN1ZmZpeDogJycsXHJcbiAgICAgICAgICByb3dzOiAzLFxyXG4gICAgICAgICAgbXVsdGlwbGU6IGZhbHNlLFxyXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiAnJyxcclxuICAgICAgICAgIHByb3RlY3RlZDogZmFsc2UsXHJcbiAgICAgICAgICBwZXJzaXN0ZW50OiB0cnVlLFxyXG4gICAgICAgICAgaGlkZGVuOiBmYWxzZSxcclxuICAgICAgICAgIHd5c2l3eWc6IGZhbHNlLFxyXG4gICAgICAgICAgY2xlYXJPbkhpZGU6IHRydWUsXHJcbiAgICAgICAgICB2YWxpZGF0ZToge1xyXG4gICAgICAgICAgICByZXF1aXJlZDogZmFsc2UsXHJcbiAgICAgICAgICAgIG1pbkxlbmd0aDogJycsXHJcbiAgICAgICAgICAgIG1heExlbmd0aDogJycsXHJcbiAgICAgICAgICAgIHBhdHRlcm46ICcnLFxyXG4gICAgICAgICAgICBjdXN0b206ICcnXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICBdKTtcclxuICBhcHAucnVuKFtcclxuICAgICckdGVtcGxhdGVDYWNoZScsXHJcbiAgICAnRm9ybWlvVXRpbHMnLFxyXG4gICAgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUsXHJcbiAgICAgICAgICAgICAgRm9ybWlvVXRpbHMpIHtcclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy90ZXh0YXJlYS5odG1sJywgRm9ybWlvVXRpbHMuZmllbGRXcmFwKFxyXG4gICAgICAgIFwiPHRleHRhcmVhXFxyXFxuICBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIlxcclxcbiAgbmctbW9kZWw9XFxcImRhdGFbY29tcG9uZW50LmtleV1cXFwiXFxyXFxuICBuZy1kaXNhYmxlZD1cXFwicmVhZE9ubHlcXFwiXFxyXFxuICBuZy1yZXF1aXJlZD1cXFwiaXNSZXF1aXJlZChjb21wb25lbnQpXFxcIlxcclxcbiAgc2FmZS1tdWx0aXBsZS10by1zaW5nbGVcXHJcXG4gIGlkPVxcXCJ7eyBjb21wb25lbnRJZCB9fVxcXCJcXHJcXG4gIG5hbWU9XFxcInt7IGNvbXBvbmVudElkIH19XFxcIlxcclxcbiAgdGFiaW5kZXg9XFxcInt7IGNvbXBvbmVudC50YWJpbmRleCB8fCAwIH19XFxcIlxcclxcbiAgbmctYXR0ci1wbGFjZWhvbGRlcj1cXFwie3sgY29tcG9uZW50LnBsYWNlaG9sZGVyIHwgZm9ybWlvVHJhbnNsYXRlOm51bGw6YnVpbGRlciB9fVxcXCJcXHJcXG4gIGN1c3RvbS12YWxpZGF0b3I9XFxcImNvbXBvbmVudC52YWxpZGF0ZS5jdXN0b21cXFwiXFxyXFxuICByb3dzPVxcXCJ7eyBjb21wb25lbnQucm93cyB9fVxcXCJcXHJcXG4+PC90ZXh0YXJlYT5cXHJcXG5cIlxyXG4gICAgICApKTtcclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy90ZXh0ZWRpdG9yLmh0bWwnLCBGb3JtaW9VdGlscy5maWVsZFdyYXAoXHJcbiAgICAgICAgXCI8dGV4dGFyZWFcXHJcXG4gIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiXFxyXFxuICBuZy1tb2RlbD1cXFwiZGF0YVtjb21wb25lbnQua2V5XVxcXCJcXHJcXG4gIG5nLWRpc2FibGVkPVxcXCJyZWFkT25seVxcXCJcXHJcXG4gIG5nLXJlcXVpcmVkPVxcXCJpc1JlcXVpcmVkKGNvbXBvbmVudClcXFwiXFxyXFxuICBja2VkaXRvcj1cXFwiY29tcG9uZW50Lnd5c2l3eWdcXFwiXFxyXFxuICBzYWZlLW11bHRpcGxlLXRvLXNpbmdsZVxcclxcbiAgaWQ9XFxcInt7IGNvbXBvbmVudElkIH19XFxcIlxcclxcbiAgbmFtZT1cXFwie3sgY29tcG9uZW50SWQgfX1cXFwiXFxyXFxuICB0YWJpbmRleD1cXFwie3sgY29tcG9uZW50LnRhYmluZGV4IHx8IDAgfX1cXFwiXFxyXFxuICBuZy1hdHRyLXBsYWNlaG9sZGVyPVxcXCJ7eyBjb21wb25lbnQucGxhY2Vob2xkZXIgfX1cXFwiXFxyXFxuICBjdXN0b20tdmFsaWRhdG9yPVxcXCJjb21wb25lbnQudmFsaWRhdGUuY3VzdG9tXFxcIlxcclxcbiAgcm93cz1cXFwie3sgY29tcG9uZW50LnJvd3MgfX1cXFwiXFxyXFxuPjwvdGV4dGFyZWE+XFxyXFxuXCJcclxuICAgICAgKSk7XHJcbiAgICB9XHJcbiAgXSk7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFwcCkge1xyXG4gIGFwcC5jb25maWcoW1xyXG4gICAgJ2Zvcm1pb0NvbXBvbmVudHNQcm92aWRlcicsXHJcbiAgICBmdW5jdGlvbihmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIpIHtcclxuICAgICAgZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyLnJlZ2lzdGVyKCd0ZXh0ZmllbGQnLCB7XHJcbiAgICAgICAgdGl0bGU6ICdUZXh0IEZpZWxkJyxcclxuICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL3RleHRmaWVsZC5odG1sJyxcclxuICAgICAgICBpY29uOiAnZmEgZmEtdGVybWluYWwnLFxyXG4gICAgICAgIHNldHRpbmdzOiB7XHJcbiAgICAgICAgICBpbnB1dDogdHJ1ZSxcclxuICAgICAgICAgIHRhYmxlVmlldzogdHJ1ZSxcclxuICAgICAgICAgIGlucHV0VHlwZTogJ3RleHQnLFxyXG4gICAgICAgICAgaW5wdXRNYXNrOiAnJyxcclxuICAgICAgICAgIGxhYmVsOiAnJyxcclxuICAgICAgICAgIGtleTogJ3RleHRGaWVsZCcsXHJcbiAgICAgICAgICBwbGFjZWhvbGRlcjogJycsXHJcbiAgICAgICAgICBwcmVmaXg6ICcnLFxyXG4gICAgICAgICAgc3VmZml4OiAnJyxcclxuICAgICAgICAgIG11bHRpcGxlOiBmYWxzZSxcclxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogJycsXHJcbiAgICAgICAgICBwcm90ZWN0ZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgdW5pcXVlOiBmYWxzZSxcclxuICAgICAgICAgIHBlcnNpc3RlbnQ6IHRydWUsXHJcbiAgICAgICAgICBoaWRkZW46IGZhbHNlLFxyXG4gICAgICAgICAgY2xlYXJPbkhpZGU6IHRydWUsXHJcbiAgICAgICAgICB2YWxpZGF0ZToge1xyXG4gICAgICAgICAgICByZXF1aXJlZDogZmFsc2UsXHJcbiAgICAgICAgICAgIG1pbkxlbmd0aDogJycsXHJcbiAgICAgICAgICAgIG1heExlbmd0aDogJycsXHJcbiAgICAgICAgICAgIHBhdHRlcm46ICcnLFxyXG4gICAgICAgICAgICBjdXN0b206ICcnLFxyXG4gICAgICAgICAgICBjdXN0b21Qcml2YXRlOiBmYWxzZVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGNvbmRpdGlvbmFsOiB7XHJcbiAgICAgICAgICAgIHNob3c6IG51bGwsXHJcbiAgICAgICAgICAgIHdoZW46IG51bGwsXHJcbiAgICAgICAgICAgIGVxOiAnJ1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgXSk7XHJcblxyXG4gIGFwcC5ydW4oW1xyXG4gICAgJyR0ZW1wbGF0ZUNhY2hlJyxcclxuICAgICdGb3JtaW9VdGlscycsXHJcbiAgICBmdW5jdGlvbihcclxuICAgICAgJHRlbXBsYXRlQ2FjaGUsXHJcbiAgICAgIEZvcm1pb1V0aWxzXHJcbiAgICApIHtcclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50cy90ZXh0ZmllbGQuaHRtbCcsIEZvcm1pb1V0aWxzLmZpZWxkV3JhcChcclxuICAgICAgICBcIjxpbnB1dFxcclxcbiAgdHlwZT1cXFwie3sgY29tcG9uZW50LmlucHV0VHlwZSB9fVxcXCJcXHJcXG4gIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiXFxyXFxuICBpZD1cXFwie3sgY29tcG9uZW50SWQgfX1cXFwiXFxyXFxuICBuYW1lPVxcXCJ7eyBjb21wb25lbnRJZCB9fVxcXCJcXHJcXG4gIHRhYmluZGV4PVxcXCJ7eyBjb21wb25lbnQudGFiaW5kZXggfHwgMCB9fVxcXCJcXHJcXG4gIG5nLWRpc2FibGVkPVxcXCJyZWFkT25seVxcXCJcXHJcXG4gIG5nLW1vZGVsPVxcXCJkYXRhW2NvbXBvbmVudC5rZXldXFxcIlxcclxcbiAgbmctbW9kZWwtb3B0aW9ucz1cXFwieyBkZWJvdW5jZTogNTAwIH1cXFwiXFxyXFxuICBzYWZlLW11bHRpcGxlLXRvLXNpbmdsZVxcclxcbiAgbmctcmVxdWlyZWQ9XFxcImlzUmVxdWlyZWQoY29tcG9uZW50KVxcXCJcXHJcXG4gIG5nLW1pbmxlbmd0aD1cXFwiY29tcG9uZW50LnZhbGlkYXRlLm1pbkxlbmd0aFxcXCJcXHJcXG4gIG5nLW1heGxlbmd0aD1cXFwiY29tcG9uZW50LnZhbGlkYXRlLm1heExlbmd0aFxcXCJcXHJcXG4gIG5nLXBhdHRlcm49XFxcImNvbXBvbmVudC52YWxpZGF0ZS5wYXR0ZXJuXFxcIlxcclxcbiAgY3VzdG9tLXZhbGlkYXRvcj1cXFwiY29tcG9uZW50LnZhbGlkYXRlLmN1c3RvbVxcXCJcXHJcXG4gIG5nLWF0dHItcGxhY2Vob2xkZXI9XFxcInt7IGNvbXBvbmVudC5wbGFjZWhvbGRlciB8IGZvcm1pb1RyYW5zbGF0ZTpudWxsOmJ1aWxkZXIgfX1cXFwiXFxyXFxuICB1aS1tYXNrPVxcXCJ7eyBjb21wb25lbnQuaW5wdXRNYXNrIH19XFxcIlxcclxcbiAgdWktbWFzay1wbGFjZWhvbGRlcj1cXFwiXFxcIlxcclxcbiAgdWktb3B0aW9ucz1cXFwidWlNYXNrT3B0aW9uc1xcXCJcXHJcXG4+XFxyXFxuXCJcclxuICAgICAgKSk7XHJcbiAgICB9XHJcbiAgXSk7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xuXHJcbnZhciBHcmlkVXRpbHMgPSByZXF1aXJlKCcuLi9mYWN0b3JpZXMvR3JpZFV0aWxzJykoKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBwKSB7XHJcbiAgYXBwLmNvbmZpZyhbXHJcbiAgICAnZm9ybWlvQ29tcG9uZW50c1Byb3ZpZGVyJyxcclxuICAgIGZ1bmN0aW9uKGZvcm1pb0NvbXBvbmVudHNQcm92aWRlcikge1xyXG4gICAgICBmb3JtaW9Db21wb25lbnRzUHJvdmlkZXIucmVnaXN0ZXIoJ3dlbGwnLCB7XHJcbiAgICAgICAgdGl0bGU6ICdXZWxsJyxcclxuICAgICAgICB0ZW1wbGF0ZTogJ2Zvcm1pby9jb21wb25lbnRzL3dlbGwuaHRtbCcsXHJcbiAgICAgICAgZ3JvdXA6ICdsYXlvdXQnLFxyXG4gICAgICAgIHNldHRpbmdzOiB7XHJcbiAgICAgICAgICBrZXk6ICd3ZWxsJyxcclxuICAgICAgICAgIGlucHV0OiBmYWxzZSxcclxuICAgICAgICAgIGNvbXBvbmVudHM6IFtdLFxyXG4gICAgICAgICAgdGFibGVWaWV3OiB0cnVlXHJcbiAgICAgICAgfSxcclxuICAgICAgICB2aWV3VGVtcGxhdGU6ICdmb3JtaW8vY29tcG9uZW50c1ZpZXcvd2VsbC5odG1sJyxcclxuICAgICAgICB0YWJsZVZpZXc6IGZ1bmN0aW9uKGRhdGEsIGNvbXBvbmVudCwgJGludGVycG9sYXRlLCBjb21wb25lbnRJbmZvLCB0YWJsZUNoaWxkKSB7XHJcbiAgICAgICAgICB2YXIgdmlldyA9ICc8dGFibGUgY2xhc3M9XCJ0YWJsZSB0YWJsZS1zdHJpcGVkIHRhYmxlLWJvcmRlcmVkIHRhYmxlLWNoaWxkXCI+JztcclxuXHJcbiAgICAgICAgICBpZiAoIXRhYmxlQ2hpbGQpIHtcclxuICAgICAgICAgICAgdmlldyArPSAnPHRoZWFkPjx0cj4nO1xyXG4gICAgICAgICAgICB2aWV3ICs9ICc8dGg+V2VsbCAoJyArIGNvbXBvbmVudC5rZXkgKyAnKTwvdGg+JztcclxuICAgICAgICAgICAgdmlldyArPSAnPC90cj48L3RoZWFkPic7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB2aWV3ICs9ICc8dGJvZHk+JztcclxuICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChjb21wb25lbnQuY29tcG9uZW50cywgZnVuY3Rpb24oY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIHZpZXcgKz0gJzx0cj4nICsgR3JpZFV0aWxzLmNvbHVtbkZvckNvbXBvbmVudChkYXRhLCBjb21wb25lbnQsICRpbnRlcnBvbGF0ZSwgY29tcG9uZW50SW5mbywgdHJ1ZSkgKyAnPC90cj4nO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgdmlldyArPSAnPC90Ym9keT48L3RhYmxlPic7XHJcbiAgICAgICAgICByZXR1cm4gdmlldztcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIF0pO1xyXG4gIGFwcC5ydW4oW1xyXG4gICAgJyR0ZW1wbGF0ZUNhY2hlJyxcclxuICAgIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgICAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgnZm9ybWlvL2NvbXBvbmVudHMvd2VsbC5odG1sJyxcclxuICAgICAgICBcIjxkaXYgY2xhc3M9XFxcIndlbGxcXFwiIGlkPVxcXCJ7eyBjb21wb25lbnQua2V5IH19XFxcIj5cXHJcXG4gIDxmb3JtaW8tY29tcG9uZW50XFxyXFxuICAgIG5nLXJlcGVhdD1cXFwiX2NvbXBvbmVudCBpbiBjb21wb25lbnQuY29tcG9uZW50cyB0cmFjayBieSAkaW5kZXhcXFwiXFxyXFxuICAgIGNvbXBvbmVudD1cXFwiX2NvbXBvbmVudFxcXCJcXHJcXG4gICAgZGF0YT1cXFwiZGF0YVxcXCJcXHJcXG4gICAgZm9ybWlvPVxcXCJmb3JtaW9cXFwiXFxyXFxuICAgIHN1Ym1pc3Npb249XFxcInN1Ym1pc3Npb25cXFwiXFxyXFxuICAgIGhpZGUtY29tcG9uZW50cz1cXFwiaGlkZUNvbXBvbmVudHNcXFwiXFxyXFxuICAgIG5nLWlmPVxcXCJidWlsZGVyID8gJzo6dHJ1ZScgOiBpc1Zpc2libGUoX2NvbXBvbmVudCwgZGF0YSlcXFwiXFxyXFxuICAgIHJlYWQtb25seT1cXFwiaXNEaXNhYmxlZChfY29tcG9uZW50LCBkYXRhKVxcXCJcXHJcXG4gICAgZm9ybWlvLWZvcm09XFxcImZvcm1pb0Zvcm1cXFwiXFxyXFxuICAgIGdyaWQtcm93PVxcXCJncmlkUm93XFxcIlxcclxcbiAgICBncmlkLWNvbD1cXFwiZ3JpZENvbFxcXCJcXHJcXG4gICAgYnVpbGRlcj1cXFwiYnVpbGRlclxcXCJcXHJcXG4gID48L2Zvcm1pby1jb21wb25lbnQ+XFxyXFxuPC9kaXY+XFxyXFxuXCJcclxuICAgICAgKTtcclxuICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KCdmb3JtaW8vY29tcG9uZW50c1ZpZXcvd2VsbC5odG1sJyxcclxuICAgICAgICBcIjxkaXYgY2xhc3M9XFxcIndlbGxcXFwiIGlkPVxcXCJ7eyBjb21wb25lbnQua2V5IH19XFxcIj5cXHJcXG4gIDxmb3JtaW8tY29tcG9uZW50LXZpZXdcXHJcXG4gICAgbmctcmVwZWF0PVxcXCJfY29tcG9uZW50IGluIGNvbXBvbmVudC5jb21wb25lbnRzIHRyYWNrIGJ5ICRpbmRleFxcXCJcXHJcXG4gICAgY29tcG9uZW50PVxcXCJfY29tcG9uZW50XFxcIlxcclxcbiAgICBkYXRhPVxcXCJkYXRhXFxcIlxcclxcbiAgICBmb3JtPVxcXCJmb3JtXFxcIlxcclxcbiAgICBzdWJtaXNzaW9uPVxcXCJzdWJtaXNzaW9uXFxcIlxcclxcbiAgICBpZ25vcmU9XFxcImlnbm9yZVxcXCJcXHJcXG4gICAgbmctaWY9XFxcImJ1aWxkZXIgPyAnOjp0cnVlJyA6IGlzVmlzaWJsZShfY29tcG9uZW50LCBkYXRhKVxcXCJcXHJcXG4gICAgYnVpbGRlcj1cXFwiYnVpbGRlclxcXCJcXHJcXG4gID48L2Zvcm1pby1jb21wb25lbnQtdmlldz5cXHJcXG48L2Rpdj5cXHJcXG5cIlxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIF0pO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlc3RyaWN0OiAnQScsXHJcbiAgICByZXF1aXJlOiAnbmdNb2RlbCcsXHJcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlLCBhdHRycywgY3RybCkge1xyXG4gICAgICBpZiAoc2NvcGUuYnVpbGRlcikgcmV0dXJuO1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgIXNjb3BlLmNvbXBvbmVudC52YWxpZGF0ZSB8fFxyXG4gICAgICAgICFzY29wZS5jb21wb25lbnQudmFsaWRhdGUuY3VzdG9tXHJcbiAgICAgICkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIF9nZXQgPSBmdW5jdGlvbihpdGVtLCBwYXRoLCBkZWYpIHtcclxuICAgICAgICBpZiAoIWl0ZW0pIHtcclxuICAgICAgICAgIHJldHVybiBkZWYgfHwgdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXBhdGgpIHtcclxuICAgICAgICAgIHJldHVybiBpdGVtO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSWYgdGhlIHBhdGggaXMgYSBzdHJpbmcsIHR1cm4gaXQgaW50byBhbiBhcnJheS5cclxuICAgICAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICBwYXRoID0gcGF0aC5zcGxpdCgnLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiB0aGUgcGF0aCBpcyBhbiBhcnJheSwgdGFrZSB0aGUgZmlyc3QgZWxlbWVudCwgYW5kIHJlY3Vyc2UgaXRzIHBhdGhcclxuICAgICAgICBpZiAocGF0aCBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgICB2YXIgY3VycmVudCA9IHBhdGguc2hpZnQoKTtcclxuICAgICAgICAgIGlmIChpdGVtLmhhc093blByb3BlcnR5KGN1cnJlbnQpKSB7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBtb3JlIHBhdGggaXRlbXMsIHN0b3AgaGVyZS5cclxuICAgICAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1bY3VycmVudF07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBfZ2V0KGl0ZW1bY3VycmVudF0sIHBhdGgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgY3RybC4kdmFsaWRhdG9ycy5jdXN0b20gPSBmdW5jdGlvbihtb2RlbFZhbHVlLCB2aWV3VmFsdWUpIHtcclxuICAgICAgICB2YXIgdmFsaWQgPSB0cnVlO1xyXG4gICAgICAgIC8qZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cclxuICAgICAgICB2YXIgaW5wdXQgPSBtb2RlbFZhbHVlIHx8IHZpZXdWYWx1ZTtcclxuXHJcbiAgICAgICAgLy8gRk9SLTI1NSAtIEVuYWJsZSByb3cgZGF0YSBhbmQgZm9ybSBkYXRhIHRvIGJlIHZpc2libGUgaW4gdGhlIHZhbGlkYXRvci5cclxuICAgICAgICB2YXIgZGF0YSA9IHNjb3BlLnN1Ym1pc3Npb24uZGF0YTtcclxuICAgICAgICB2YXIgcm93ID0gc2NvcGUuZGF0YTtcclxuICAgICAgICAvKmVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cclxuXHJcbiAgICAgICAgdmFyIGN1c3RvbSA9IHNjb3BlLmNvbXBvbmVudC52YWxpZGF0ZS5jdXN0b207XHJcbiAgICAgICAgY3VzdG9tID0gY3VzdG9tLnJlcGxhY2UoLyh7e1xcc3swLH0oLipbXlxcc10pezF9XFxzezAsfX19KS9nLCBmdW5jdGlvbihtYXRjaCwgJDEsICQyKSB7XHJcbiAgICAgICAgICByZXR1cm4gX2dldChzY29wZS5zdWJtaXNzaW9uLmRhdGEsICQyKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIC8qIGpzaGludCBldmlsOiB0cnVlICovXHJcbiAgICAgICAgICBldmFsKGN1c3RvbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgIHZhbGlkID0gZXJyLm1lc3NhZ2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodmFsaWQgIT09IHRydWUpIHtcclxuICAgICAgICAgIHNjb3BlLmNvbXBvbmVudC5jdXN0b21FcnJvciA9IHZhbGlkO1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9O1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICByZXBsYWNlOiB0cnVlLFxyXG4gICAgc2NvcGU6IHtcclxuICAgICAgc3JjOiAnPT8nLFxyXG4gICAgICB1cmw6ICc9PycsXHJcbiAgICAgIGZvcm1BY3Rpb246ICc9PycsXHJcbiAgICAgIGZvcm06ICc9PycsXHJcbiAgICAgIHN1Ym1pc3Npb246ICc9PycsXHJcbiAgICAgIHJlYWRPbmx5OiAnPT8nLFxyXG4gICAgICBoaWRlQ29tcG9uZW50czogJz0/JyxcclxuICAgICAgcmVxdWlyZUNvbXBvbmVudHM6ICc9PycsXHJcbiAgICAgIGRpc2FibGVDb21wb25lbnRzOiAnPT8nLFxyXG4gICAgICBmb3JtaW9PcHRpb25zOiAnPT8nLFxyXG4gICAgICBvcHRpb25zOiAnPT8nXHJcbiAgICB9LFxyXG4gICAgY29udHJvbGxlcjogW1xyXG4gICAgICAnJHNjb3BlJyxcclxuICAgICAgJyRodHRwJyxcclxuICAgICAgJyRlbGVtZW50JyxcclxuICAgICAgJ0Zvcm1pb1Njb3BlJyxcclxuICAgICAgJ0Zvcm1pbycsXHJcbiAgICAgICdGb3JtaW9VdGlscycsXHJcbiAgICAgICckcScsXHJcbiAgICAgIGZ1bmN0aW9uKFxyXG4gICAgICAgICRzY29wZSxcclxuICAgICAgICAkaHR0cCxcclxuICAgICAgICAkZWxlbWVudCxcclxuICAgICAgICBGb3JtaW9TY29wZSxcclxuICAgICAgICBGb3JtaW8sXHJcbiAgICAgICAgRm9ybWlvVXRpbHMsXHJcbiAgICAgICAgJHFcclxuICAgICAgKSB7XHJcbiAgICAgICAgdmFyIGlmcmFtZVJlYWR5ID0gJHEuZGVmZXIoKTtcclxuICAgICAgICAkc2NvcGUuX3NyYyA9ICRzY29wZS5zcmMgfHwgJyc7XHJcbiAgICAgICAgJHNjb3BlLmZvcm1pb0FsZXJ0cyA9IFtdO1xyXG4gICAgICAgICRzY29wZS5pZnJhbWVSZWFkeSA9IGZhbHNlO1xyXG4gICAgICAgIC8vIFNob3dzIHRoZSBnaXZlbiBhbGVydHMgKHNpbmdsZSBvciBhcnJheSksIGFuZCBkaXNtaXNzZXMgb2xkIGFsZXJ0c1xyXG4gICAgICAgIHRoaXMuc2hvd0FsZXJ0cyA9ICRzY29wZS5zaG93QWxlcnRzID0gZnVuY3Rpb24oYWxlcnRzKSB7XHJcbiAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1lbXB0eSAqL1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYWxlcnRzLm1lc3NhZ2UgPSAoSlNPTi5wYXJzZShhbGVydHMubWVzc2FnZSkpLmRhdGE7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjYXRjaCAoZSkge31cclxuICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tZW1wdHkgKi9cclxuXHJcbiAgICAgICAgICAkc2NvcGUuZm9ybWlvQWxlcnRzID0gW10uY29uY2F0KGFsZXJ0cyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgJHNjb3BlLmdldElmcmFtZVNyYyA9IGZ1bmN0aW9uKHBkZikge1xyXG4gICAgICAgICAgdmFyIGlmcmFtZVNyYyA9IHBkZi5zcmMgKyAnLmh0bWwnO1xyXG4gICAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xyXG4gICAgICAgICAgaWYgKCRzY29wZS5mb3JtLmJ1aWxkZXIpIHtcclxuICAgICAgICAgICAgcGFyYW1zLnB1c2goJ2J1aWxkZXI9MScpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCRzY29wZS5yZWFkT25seSkge1xyXG4gICAgICAgICAgICBwYXJhbXMucHVzaCgncmVhZG9ubHk9MScpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaWZyYW1lU3JjICs9ICc/JyArIHBhcmFtcy5qb2luKCcmJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gaWZyYW1lU3JjO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgICRzY29wZS5kb3dubG9hZFVybCA9ICcnO1xyXG5cclxuICAgICAgICAkc2NvcGUuZ2V0UERGRG93bmxvYWQgPSBmdW5jdGlvbihwZGYpIHtcclxuICAgICAgICAgIGlmICghJHNjb3BlLmZvcm1pbykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB2YXIgZG93bmxvYWQgPSAnJztcclxuICAgICAgICAgIGlmICgkc2NvcGUuZm9ybWlvICYmICRzY29wZS5mb3JtaW8uc3VibWlzc2lvblVybCkge1xyXG4gICAgICAgICAgICBkb3dubG9hZCA9ICRzY29wZS5mb3JtaW8uc3VibWlzc2lvblVybDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2UgaWYgKCRzY29wZS5zdWJtaXNzaW9uLl9pZCkge1xyXG4gICAgICAgICAgICBkb3dubG9hZCA9IEZvcm1pby5iYXNlVXJsICsgJy9wcm9qZWN0LycgKyAkc2NvcGUuZm9ybS5wcm9qZWN0ICsgJy8nO1xyXG4gICAgICAgICAgICBkb3dubG9hZCArPSAnL2Zvcm0vJyArICRzY29wZS5mb3JtLl9pZDtcclxuICAgICAgICAgICAgZG93bmxvYWQgKz0gJy9zdWJtaXNzaW9uLycgKyAkc2NvcGUuc3VibWlzc2lvbi5faWQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoIWRvd25sb2FkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBkb3dubG9hZCArPSAnL2Rvd25sb2FkLycgKyBwZGYuaWQ7XHJcbiAgICAgICAgICB2YXIgYWxsb3dlZFBhdGggPSBkb3dubG9hZC5yZXBsYWNlKEZvcm1pby5iYXNlVXJsLCAnJyk7XHJcbiAgICAgICAgICBhbGxvd2VkUGF0aCA9IGFsbG93ZWRQYXRoLnJlcGxhY2UoRm9ybWlvLmdldFByb2plY3RVcmwoKSwgJycpO1xyXG4gICAgICAgICAgcmV0dXJuICRzY29wZS5mb3JtaW8uZ2V0VGVtcFRva2VuKDM2MDAsICdHRVQ6JyArIGFsbG93ZWRQYXRoKS50aGVuKGZ1bmN0aW9uKHRlbXBUb2tlbikge1xyXG4gICAgICAgICAgICBkb3dubG9hZCArPSAnP3Rva2VuPScgKyB0ZW1wVG9rZW4ua2V5O1xyXG4gICAgICAgICAgICAkc2NvcGUuZG93bmxvYWRVcmwgPSBkb3dubG9hZDtcclxuICAgICAgICAgICAgcmV0dXJuIGRvd25sb2FkO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gQWRkIHRoZSBsaXZlIGZvcm0gcGFyYW1ldGVyIHRvIHRoZSB1cmwuXHJcbiAgICAgICAgaWYgKCRzY29wZS5fc3JjICYmICgkc2NvcGUuX3NyYy5pbmRleE9mKCdsaXZlPScpID09PSAtMSkpIHtcclxuICAgICAgICAgICRzY29wZS5fc3JjICs9ICgkc2NvcGUuX3NyYy5pbmRleE9mKCc/JykgPT09IC0xKSA/ICc/JyA6ICcmJztcclxuICAgICAgICAgICRzY29wZS5fc3JjICs9ICdsaXZlPTEnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHNlbmRJZnJhbWVNZXNzYWdlID0gZnVuY3Rpb24obWVzc2FnZSkge1xyXG4gICAgICAgICAgaWZyYW1lUmVhZHkucHJvbWlzZS50aGVuKGZ1bmN0aW9uKGlmcmFtZSkge1xyXG4gICAgICAgICAgICBpZnJhbWUuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShKU09OLnN0cmluZ2lmeShtZXNzYWdlKSwgJyonKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgICRzY29wZS4kb24oJ2lmcmFtZS1yZWFkeScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgJHNjb3BlLmlmcmFtZVJlYWR5ID0gdHJ1ZTtcclxuICAgICAgICAgIHZhciBpZnJhbWUgPSAkZWxlbWVudC5maW5kKCcuZm9ybWlvLWlmcmFtZScpWzBdO1xyXG4gICAgICAgICAgaWYgKGlmcmFtZSkge1xyXG4gICAgICAgICAgICBpZnJhbWVSZWFkeS5yZXNvbHZlKGlmcmFtZSk7XHJcbiAgICAgICAgICAgIGlmICgkc2NvcGUuZm9ybSkge1xyXG4gICAgICAgICAgICAgIHNlbmRJZnJhbWVNZXNzYWdlKHtuYW1lOiAnZm9ybScsIGRhdGE6ICRzY29wZS5mb3JtfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCRzY29wZS5zdWJtaXNzaW9uKSB7XHJcbiAgICAgICAgICAgICAgc2VuZElmcmFtZU1lc3NhZ2Uoe25hbWU6ICdzdWJtaXNzaW9uJywgZGF0YTogJHNjb3BlLnN1Ym1pc3Npb259KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAkc2NvcGUuJG9uKCdpZnJhbWVNZXNzYWdlJywgZnVuY3Rpb24oZXZlbnQsIG1lc3NhZ2UpIHtcclxuICAgICAgICAgIHNlbmRJZnJhbWVNZXNzYWdlKG1lc3NhZ2UpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB2YXIgY2FuY2VsRm9ybUxvYWRFdmVudCA9ICRzY29wZS4kb24oJ2Zvcm1Mb2FkJywgZnVuY3Rpb24oZXZlbnQsIGZvcm0pIHtcclxuICAgICAgICAgIGNhbmNlbEZvcm1Mb2FkRXZlbnQoKTtcclxuICAgICAgICAgIGlmcmFtZVJlYWR5LnByb21pc2UudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgJHNjb3BlLmdldFBERkRvd25sb2FkKGZvcm0uc2V0dGluZ3MucGRmKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgc2VuZElmcmFtZU1lc3NhZ2Uoe25hbWU6ICdmb3JtJywgZGF0YTogZm9ybX0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAkc2NvcGUuJG9uKCdzdWJtaXNzaW9uTG9hZCcsIGZ1bmN0aW9uKGV2ZW50LCBzdWJtaXNzaW9uKSB7XHJcbiAgICAgICAgICBzdWJtaXNzaW9uLmVkaXRhYmxlID0gISRzY29wZS5yZWFkT25seTtcclxuICAgICAgICAgIHNlbmRJZnJhbWVNZXNzYWdlKHtuYW1lOiAnc3VibWlzc2lvbicsIGRhdGE6IHN1Ym1pc3Npb259KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gU3VibWl0IHRoZSBmb3JtIGZyb20gdGhlIGlmcmFtZS5cclxuICAgICAgICAkc2NvcGUuJG9uKCdpZnJhbWUtc3VibWlzc2lvbicsIGZ1bmN0aW9uKGV2ZW50LCBzdWJtaXNzaW9uKSB7XHJcbiAgICAgICAgICAkc2NvcGUuc3VibWl0Rm9ybShzdWJtaXNzaW9uKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gQ2FsbGVkIGZyb20gdGhlIHN1Ym1pdCBvbiBpZnJhbWUuXHJcbiAgICAgICAgJHNjb3BlLnN1Ym1pdElGcmFtZUZvcm0gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHNlbmRJZnJhbWVNZXNzYWdlKHtuYW1lOiAnZ2V0U3VibWlzc2lvbid9KTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAkc2NvcGUuem9vbUluID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBzZW5kSWZyYW1lTWVzc2FnZSh7bmFtZTogJ3pvb21Jbid9KTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAkc2NvcGUuem9vbU91dCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgc2VuZElmcmFtZU1lc3NhZ2Uoe25hbWU6ICd6b29tT3V0J30pO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIEZPUi03MVxyXG4gICAgICAgIGlmICghJHNjb3BlLl9zcmMgJiYgISRzY29wZS5idWlsZGVyKSB7XHJcbiAgICAgICAgICAkc2NvcGUuJHdhdGNoKCdzcmMnLCBmdW5jdGlvbihzcmMpIHtcclxuICAgICAgICAgICAgaWYgKCFzcmMpIHtcclxuICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgJHNjb3BlLl9zcmMgPSBzcmM7XHJcbiAgICAgICAgICAgICRzY29wZS5mb3JtaW8gPSBGb3JtaW9TY29wZS5yZWdpc3Rlcigkc2NvcGUsICRlbGVtZW50LCB7XHJcbiAgICAgICAgICAgICAgZm9ybTogdHJ1ZSxcclxuICAgICAgICAgICAgICBzdWJtaXNzaW9uOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDcmVhdGUgdGhlIGZvcm1pbyBvYmplY3QuXHJcbiAgICAgICAgJHNjb3BlLmZvcm1pbyA9IEZvcm1pb1Njb3BlLnJlZ2lzdGVyKCRzY29wZSwgJGVsZW1lbnQsIHtcclxuICAgICAgICAgIGZvcm06IHRydWUsXHJcbiAgICAgICAgICBzdWJtaXNzaW9uOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICRzY29wZS5jaGVja0Vycm9ycyA9IGZ1bmN0aW9uKGZvcm0pIHtcclxuICAgICAgICAgIGlmIChmb3JtLnN1Ym1pdHRpbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBmb3JtLiRzZXREaXJ0eSh0cnVlKTtcclxuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBmb3JtKSB7XHJcbiAgICAgICAgICAgIGlmIChmb3JtW2tleV0gJiYgZm9ybVtrZXldLiR2YWxpZGF0ZSkge1xyXG4gICAgICAgICAgICAgIGZvcm1ba2V5XS4kc2V0RGlydHkodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgZm9ybVtrZXldLiR2YWxpZGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gIWZvcm0uJHZhbGlkO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgICRzY29wZS5pc1Zpc2libGUgPSBmdW5jdGlvbihjb21wb25lbnQsIHJvdykge1xyXG4gICAgICAgICAgcmV0dXJuIEZvcm1pb1V0aWxzLmlzVmlzaWJsZShcclxuICAgICAgICAgICAgY29tcG9uZW50LFxyXG4gICAgICAgICAgICByb3csXHJcbiAgICAgICAgICAgICRzY29wZS5zdWJtaXNzaW9uID8gJHNjb3BlLnN1Ym1pc3Npb24uZGF0YSA6IG51bGwsXHJcbiAgICAgICAgICAgICRzY29wZS5oaWRlQ29tcG9uZW50c1xyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBTaG93IHRoZSBzdWJtaXQgbWVzc2FnZSBhbmQgc2F5IHRoZSBmb3JtIGlzIG5vIGxvbmdlciBzdWJtaXR0aW5nLlxyXG4gICAgICAgIHZhciBvblN1Ym1pdCA9IGZ1bmN0aW9uKHN1Ym1pc3Npb24sIG1lc3NhZ2UsIGZvcm0pIHtcclxuICAgICAgICAgIGlmIChtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICRzY29wZS5zaG93QWxlcnRzKHtcclxuICAgICAgICAgICAgICB0eXBlOiAnc3VjY2VzcycsXHJcbiAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChmb3JtKSB7XHJcbiAgICAgICAgICAgIGZvcm0uc3VibWl0dGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIENhbGxlZCB3aGVuIGEgc3VibWlzc2lvbiBoYXMgYmVlbiBtYWRlLlxyXG4gICAgICAgIHZhciBvblN1Ym1pdERvbmUgPSBmdW5jdGlvbihtZXRob2QsIHN1Ym1pc3Npb24sIGZvcm0pIHtcclxuICAgICAgICAgIHZhciBtZXNzYWdlID0gJyc7XHJcbiAgICAgICAgICBpZiAoJHNjb3BlLm9wdGlvbnMgJiYgJHNjb3BlLm9wdGlvbnMuc3VibWl0TWVzc2FnZSkge1xyXG4gICAgICAgICAgICBtZXNzYWdlID0gJHNjb3BlLm9wdGlvbnMuc3VibWl0TWVzc2FnZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBtZXNzYWdlID0gJ1N1Ym1pc3Npb24gd2FzICcgKyAoKG1ldGhvZCA9PT0gJ3B1dCcpID8gJ3VwZGF0ZWQnIDogJ2NyZWF0ZWQnKSArICcuJztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIG9uU3VibWl0KHN1Ym1pc3Npb24sIG1lc3NhZ2UsIGZvcm0pO1xyXG4gICAgICAgICAgLy8gVHJpZ2dlciB0aGUgZm9ybSBzdWJtaXNzaW9uLlxyXG4gICAgICAgICAgJHNjb3BlLiRlbWl0KCdmb3JtU3VibWlzc2lvbicsIHN1Ym1pc3Npb24pO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgICRzY29wZS5zdWJtaXRGb3JtID0gZnVuY3Rpb24oc3VibWlzc2lvbkRhdGEsIGZvcm0pIHtcclxuICAgICAgICAgIC8vIEFsbG93IGN1c3RvbSBhY3Rpb24gdXJscy5cclxuICAgICAgICAgIGlmICgkc2NvcGUuYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBzdWJtaXNzaW9uRGF0YS5faWQgPyAncHV0JyA6ICdwb3N0JztcclxuICAgICAgICAgICAgdmFyIGFjdGlvbiA9ICRzY29wZS5hY3Rpb247XHJcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgYWN0aW9uIElkIGlmIGl0IGlzIG5vdCBhbHJlYWR5IHBhcnQgb2YgdGhlIHVybC5cclxuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gJ3B1dCcgJiYgKGFjdGlvbi5pbmRleE9mKHN1Ym1pc3Npb25EYXRhLl9pZCkgPT09IC0xKSkge1xyXG4gICAgICAgICAgICAgIGFjdGlvbiArPSAnLycgKyBzdWJtaXNzaW9uRGF0YS5faWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgJGh0dHBbbWV0aG9kXShhY3Rpb24sIHN1Ym1pc3Npb25EYXRhKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgRm9ybWlvLmNsZWFyQ2FjaGUoKTtcclxuICAgICAgICAgICAgICBvblN1Ym1pdERvbmUobWV0aG9kLCByZXNwb25zZS5kYXRhLCBmb3JtKTtcclxuICAgICAgICAgICAgfSwgRm9ybWlvU2NvcGUub25FcnJvcigkc2NvcGUsICRlbGVtZW50KSlcclxuICAgICAgICAgICAgICAuZmluYWxseShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGlmIChmb3JtKSB7XHJcbiAgICAgICAgICAgICAgICAgIGZvcm0uc3VibWl0dGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIElmIHRoZXkgd2lzaCB0byBzdWJtaXQgdG8gdGhlIGRlZmF1bHQgbG9jYXRpb24uXHJcbiAgICAgICAgICBlbHNlIGlmICgkc2NvcGUuZm9ybWlvICYmICEkc2NvcGUuZm9ybWlvLm5vU3VibWl0KSB7XHJcbiAgICAgICAgICAgIC8vIGNvcHkgdG8gcmVtb3ZlIGFuZ3VsYXIgJCRoYXNoS2V5XHJcbiAgICAgICAgICAgICRzY29wZS5mb3JtaW8uc2F2ZVN1Ym1pc3Npb24oc3VibWlzc2lvbkRhdGEsICRzY29wZS5mb3JtaW9PcHRpb25zKS50aGVuKGZ1bmN0aW9uKHN1Ym1pc3Npb24pIHtcclxuICAgICAgICAgICAgICBvblN1Ym1pdERvbmUoc3VibWlzc2lvbi5tZXRob2QsIHN1Ym1pc3Npb24sIGZvcm0pO1xyXG4gICAgICAgICAgICB9LCBGb3JtaW9TY29wZS5vbkVycm9yKCRzY29wZSwgJGVsZW1lbnQpKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgIGlmIChmb3JtKSB7XHJcbiAgICAgICAgICAgICAgICBmb3JtLnN1Ym1pdHRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICRzY29wZS4kZW1pdCgnZm9ybVN1Ym1pc3Npb24nLCBzdWJtaXNzaW9uRGF0YSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgJHNjb3BlLmlzRGlzYWJsZWQgPSBmdW5jdGlvbihjb21wb25lbnQpIHtcclxuICAgICAgICAgIHJldHVybiAkc2NvcGUucmVhZE9ubHkgfHwgY29tcG9uZW50LmRpc2FibGVkIHx8IChBcnJheS5pc0FycmF5KCRzY29wZS5kaXNhYmxlQ29tcG9uZW50cykgJiYgJHNjb3BlLmRpc2FibGVDb21wb25lbnRzLmluZGV4T2YoY29tcG9uZW50LmtleSkgIT09IC0xKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAkc2NvcGUuaXNSZXF1aXJlZCA9IGZ1bmN0aW9uKGNvbXBvbmVudCkge1xyXG4gICAgICAgICAgcmV0dXJuIEZvcm1pb1V0aWxzLmlzUmVxdWlyZWQoY29tcG9uZW50LCAkc2NvcGUucmVxdWlyZUNvbXBvbmVudHMpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIENhbGxlZCB3aGVuIHRoZSBmb3JtIGlzIHN1Ym1pdHRlZC5cclxuICAgICAgICAkc2NvcGUub25TdWJtaXQgPSBmdW5jdGlvbihmb3JtKSB7XHJcbiAgICAgICAgICAkc2NvcGUuZm9ybWlvQWxlcnRzID0gW107XHJcbiAgICAgICAgICBpZiAoJHNjb3BlLmNoZWNrRXJyb3JzKGZvcm0pKSB7XHJcbiAgICAgICAgICAgICRzY29wZS5mb3JtaW9BbGVydHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgdHlwZTogJ2RhbmdlcicsXHJcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ1BsZWFzZSBmaXggdGhlIGZvbGxvd2luZyBlcnJvcnMgYmVmb3JlIHN1Ym1pdHRpbmcuJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZvcm0uc3VibWl0dGluZyA9IHRydWU7XHJcblxyXG4gICAgICAgICAgLy8gQ3JlYXRlIGEgc2FuaXRpemVkIHN1Ym1pc3Npb24gb2JqZWN0LlxyXG4gICAgICAgICAgdmFyIHN1Ym1pc3Npb25EYXRhID0ge2RhdGE6IHt9fTtcclxuICAgICAgICAgIGlmICgkc2NvcGUuc3VibWlzc2lvbi5faWQpIHtcclxuICAgICAgICAgICAgc3VibWlzc2lvbkRhdGEuX2lkID0gJHNjb3BlLnN1Ym1pc3Npb24uX2lkO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCRzY29wZS5zdWJtaXNzaW9uLmRhdGEuX2lkKSB7XHJcbiAgICAgICAgICAgIHN1Ym1pc3Npb25EYXRhLl9pZCA9ICRzY29wZS5zdWJtaXNzaW9uLmRhdGEuX2lkO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHZhciBncmFiSWRzID0gZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgICAgICAgaWYgKCFpbnB1dCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCEoaW5wdXQgaW5zdGFuY2VvZiBBcnJheSkpIHtcclxuICAgICAgICAgICAgICBpbnB1dCA9IFtpbnB1dF07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBmaW5hbCA9IFtdO1xyXG4gICAgICAgICAgICBpbnB1dC5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9pZCkge1xyXG4gICAgICAgICAgICAgICAgZmluYWwucHVzaChlbGVtZW50Ll9pZCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmaW5hbDtcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgdmFyIGRlZmF1bHRQZXJtaXNzaW9ucyA9IHt9O1xyXG4gICAgICAgICAgRm9ybWlvVXRpbHMuZWFjaENvbXBvbmVudCgkc2NvcGUuZm9ybS5jb21wb25lbnRzLCBmdW5jdGlvbihjb21wb25lbnQpIHtcclxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC50eXBlID09PSAncmVzb3VyY2UnICYmIGNvbXBvbmVudC5rZXkgJiYgY29tcG9uZW50LmRlZmF1bHRQZXJtaXNzaW9uKSB7XHJcbiAgICAgICAgICAgICAgZGVmYXVsdFBlcm1pc3Npb25zW2NvbXBvbmVudC5rZXldID0gY29tcG9uZW50LmRlZmF1bHRQZXJtaXNzaW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgkc2NvcGUuc3VibWlzc2lvbi5kYXRhLmhhc093blByb3BlcnR5KGNvbXBvbmVudC5rZXkpKSB7XHJcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gJHNjb3BlLnN1Ym1pc3Npb24uZGF0YVtjb21wb25lbnQua2V5XTtcclxuICAgICAgICAgICAgICBpZiAoY29tcG9uZW50LnR5cGUgPT09ICdudW1iZXInICYmICh2YWx1ZSAhPT0gbnVsbCkpIHtcclxuICAgICAgICAgICAgICAgIHN1Ym1pc3Npb25EYXRhLmRhdGFbY29tcG9uZW50LmtleV0gPSB2YWx1ZSA/IHBhcnNlRmxvYXQodmFsdWUpIDogMDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzdWJtaXNzaW9uRGF0YS5kYXRhW2NvbXBvbmVudC5rZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9LCB0cnVlKTtcclxuXHJcbiAgICAgICAgICBhbmd1bGFyLmZvckVhY2goJHNjb3BlLnN1Ym1pc3Npb24uZGF0YSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgIXZhbHVlLmhhc093blByb3BlcnR5KCdfaWQnKSkge1xyXG4gICAgICAgICAgICAgIHN1Ym1pc3Npb25EYXRhLmRhdGFba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTZXR1cCB0aGUgc3VibWlzc2lvbiBhY2Nlc3MuXHJcbiAgICAgICAgICAgIHZhciBwZXJtID0gZGVmYXVsdFBlcm1pc3Npb25zW2tleV07XHJcbiAgICAgICAgICAgIGlmIChwZXJtKSB7XHJcbiAgICAgICAgICAgICAgc3VibWlzc2lvbkRhdGEuYWNjZXNzID0gc3VibWlzc2lvbkRhdGEuYWNjZXNzIHx8IFtdO1xyXG5cclxuICAgICAgICAgICAgICAvLyBDb2VyY2UgdmFsdWUgaW50byBhbiBhcnJheSBmb3IgcGx1Y2tpbmcuXHJcbiAgICAgICAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gW3ZhbHVlXTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIC8vIFRyeSB0byBmaW5kIGFuZCB1cGRhdGUgYW4gZXhpc3RpbmcgcGVybWlzc2lvbi5cclxuICAgICAgICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICBzdWJtaXNzaW9uRGF0YS5hY2Nlc3MuZm9yRWFjaChmdW5jdGlvbihwZXJtaXNzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGVybWlzc2lvbi50eXBlID09PSBwZXJtKSB7XHJcbiAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgcGVybWlzc2lvbi5yZXNvdXJjZXMgPSBwZXJtaXNzaW9uLnJlc291cmNlcyB8fCBbXTtcclxuICAgICAgICAgICAgICAgICAgcGVybWlzc2lvbi5yZXNvdXJjZXMuY29uY2F0KGdyYWJJZHModmFsdWUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQWRkIGEgcGVybWlzc2lvbiwgYmVjYXVzZSBvbmUgd2FzIG5vdCBmb3VuZC5cclxuICAgICAgICAgICAgICBpZiAoIWZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICBzdWJtaXNzaW9uRGF0YS5hY2Nlc3MucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgIHR5cGU6IHBlcm0sXHJcbiAgICAgICAgICAgICAgICAgIHJlc291cmNlczogZ3JhYklkcyh2YWx1ZSlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgLy8gQWxsb3cgdGhlIGZvcm0gdG8gYmUgY29tcGxldGVkIGV4dGVybmFsbHkuXHJcbiAgICAgICAgICAkc2NvcGUuJG9uKCdzdWJtaXREb25lJywgZnVuY3Rpb24oZXZlbnQsIHN1Ym1pc3Npb24sIG1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgb25TdWJtaXQoc3VibWlzc2lvbiwgbWVzc2FnZSwgZm9ybSk7XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAvLyBBbGxvdyBhbiBlcnJvciB0byBiZSB0aHJvd24gZXh0ZXJuYWxseS5cclxuICAgICAgICAgICRzY29wZS4kb24oJ3N1Ym1pdEVycm9yJywgZnVuY3Rpb24oZXZlbnQsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIEZvcm1pb1Njb3BlLm9uRXJyb3IoJHNjb3BlLCAkZWxlbWVudCkoZXJyb3IpO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgdmFyIHN1Ym1pdEV2ZW50ID0gJHNjb3BlLiRlbWl0KCdmb3JtU3VibWl0Jywgc3VibWlzc2lvbkRhdGEpO1xyXG4gICAgICAgICAgaWYgKHN1Ym1pdEV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgICAgICAgLy8gTGlzdGVuZXIgd2FudHMgdG8gY2FuY2VsIHRoZSBmb3JtIHN1Ym1pc3Npb25cclxuICAgICAgICAgICAgZm9ybS5zdWJtaXR0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgdG8gbWFrZSBhIGNvcHkgb2YgdGhlIHN1Ym1pc3Npb24gZGF0YSB0byByZW1vdmUgYmFkIGNoYXJhY3RlcnMuXHJcbiAgICAgICAgICBzdWJtaXNzaW9uRGF0YSA9IGFuZ3VsYXIuY29weShzdWJtaXNzaW9uRGF0YSk7XHJcbiAgICAgICAgICAkc2NvcGUuc3VibWl0Rm9ybShzdWJtaXNzaW9uRGF0YSwgZm9ybSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgXSxcclxuICAgIHRlbXBsYXRlVXJsOiAnZm9ybWlvLmh0bWwnXHJcbiAgfTtcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFsnJHNjZScsICckcGFyc2UnLCAnJGNvbXBpbGUnLCBmdW5jdGlvbigkc2NlLCAkcGFyc2UsICRjb21waWxlKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlc3RyaWN0OiAnQScsXHJcbiAgICBjb21waWxlOiBmdW5jdGlvbiBmb3JtaW9CaW5kSHRtbENvbXBpbGUodEVsZW1lbnQsIHRBdHRycykge1xyXG4gICAgICB2YXIgZm9ybWlvQmluZEh0bWxHZXR0ZXIgPSAkcGFyc2UodEF0dHJzLmZvcm1pb0JpbmRIdG1sKTtcclxuICAgICAgJGNvbXBpbGUuJCRhZGRCaW5kaW5nQ2xhc3ModEVsZW1lbnQpO1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gZm9ybWlvQmluZEh0bWxMaW5rKHNjb3BlLCBlbGVtZW50LCBhdHRyKSB7XHJcbiAgICAgICAgJGNvbXBpbGUuJCRhZGRCaW5kaW5nSW5mbyhlbGVtZW50LCBhdHRyLmZvcm1pb0JpbmRIdG1sKTtcclxuICAgICAgICB2YXIgdmFsdWUgPSBmb3JtaW9CaW5kSHRtbEdldHRlcihzY29wZSk7XHJcbiAgICAgICAgZWxlbWVudC5odG1sKCRzY2UuZ2V0VHJ1c3RlZEh0bWwodmFsdWUpIHx8ICcnKTtcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9O1xyXG59XTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX2Nsb25lRGVlcCA9IHJlcXVpcmUoJ2xvZGFzaC9jbG9uZURlZXAnKTtcclxudmFyIF9maWx0ZXIgPSByZXF1aXJlKCdsb2Rhc2gvZmlsdGVyJyk7XHJcbnZhciBfZ2V0ID0gcmVxdWlyZSgnbG9kYXNoL2dldCcpO1xyXG5cclxuLy8gRk9SLTUyNCAtIEF0dGVtcHQgdG8gbG9hZCBqc29uIGxvZ2ljLlxyXG52YXIganNvbkxvZ2ljO1xyXG50cnkge1xyXG4gIGpzb25Mb2dpYyA9IHJlcXVpcmUoJ2pzb24tbG9naWMtanMnKSB8fCB1bmRlZmluZWQ7XHJcbn1cclxuY2F0Y2ggKGUpIHtcclxuICAvLyBJZ25vcmUgb3B0aW9uYWwgbW9kdWxlLlxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFtcclxuICAnRm9ybWlvJyxcclxuICAnZm9ybWlvQ29tcG9uZW50cycsXHJcbiAgZnVuY3Rpb24oXHJcbiAgICBGb3JtaW8sXHJcbiAgICBmb3JtaW9Db21wb25lbnRzXHJcbiAgKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICByZXBsYWNlOiB0cnVlLFxyXG4gICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICByZXF1aXJlOiAnP15mb3JtaW8nLFxyXG4gICAgICBzY29wZToge1xyXG4gICAgICAgIGNvbXBvbmVudDogJz0nLFxyXG4gICAgICAgIGRhdGE6ICc9JyxcclxuICAgICAgICBzdWJtaXNzaW9uOiAnPScsXHJcbiAgICAgICAgaGlkZUNvbXBvbmVudHM6ICc9JyxcclxuICAgICAgICBmb3JtaW86ICc9JyxcclxuICAgICAgICBmb3JtaW9Gb3JtOiAnPScsXHJcbiAgICAgICAgcmVhZE9ubHk6ICc9JyxcclxuICAgICAgICBncmlkUm93OiAnPScsXHJcbiAgICAgICAgZ3JpZENvbDogJz0nLFxyXG4gICAgICAgIGJ1aWxkZXI6ICc9PydcclxuICAgICAgfSxcclxuICAgICAgdGVtcGxhdGVVcmw6ICdmb3JtaW8vY29tcG9uZW50Lmh0bWwnLFxyXG4gICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWwsIGF0dHJzLCBmb3JtaW9DdHJsKSB7XHJcbiAgICAgICAgaWYgKGZvcm1pb0N0cmwpIHtcclxuICAgICAgICAgIHNjb3BlLnNob3dBbGVydHMgPSBmb3JtaW9DdHJsLnNob3dBbGVydHMuYmluZChmb3JtaW9DdHJsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICBzY29wZS5zaG93QWxlcnRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGwgJHNjb3BlLnNob3dBbGVydHMgdW5sZXNzIHRoaXMgY29tcG9uZW50IGlzIGluc2lkZSBhIGZvcm1pbyBkaXJlY3RpdmUuJyk7XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgY29udHJvbGxlcjogW1xyXG4gICAgICAgICckc2NvcGUnLFxyXG4gICAgICAgICckaHR0cCcsXHJcbiAgICAgICAgJyRjb250cm9sbGVyJyxcclxuICAgICAgICAnRm9ybWlvVXRpbHMnLFxyXG4gICAgICAgICckdGltZW91dCcsXHJcbiAgICAgICAgZnVuY3Rpb24oXHJcbiAgICAgICAgICAkc2NvcGUsXHJcbiAgICAgICAgICAkaHR0cCxcclxuICAgICAgICAgICRjb250cm9sbGVyLFxyXG4gICAgICAgICAgRm9ybWlvVXRpbHMsXHJcbiAgICAgICAgICAkdGltZW91dFxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgJHNjb3BlLmJ1aWxkZXIgPSAkc2NvcGUuYnVpbGRlciB8fCBmYWxzZTtcclxuICAgICAgICAgIC8vIE9wdGlvbnMgdG8gbWF0Y2gganF1ZXJ5Lm1hc2tlZGlucHV0IG1hc2tzXHJcbiAgICAgICAgICAkc2NvcGUudWlNYXNrT3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgbWFza0RlZmluaXRpb25zOiB7XHJcbiAgICAgICAgICAgICAgJzknOiAvXFxkLyxcclxuICAgICAgICAgICAgICAnYSc6IC9bYS16QS1aXS8sXHJcbiAgICAgICAgICAgICAgJyonOiAvW2EtekEtWjAtOV0vXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNsZWFyT25CbHVyOiBmYWxzZSxcclxuICAgICAgICAgICAgZXZlbnRzVG9IYW5kbGU6IFsnaW5wdXQnLCAna2V5dXAnLCAnY2xpY2snLCAnZm9jdXMnXSxcclxuICAgICAgICAgICAgc2lsZW50RXZlbnRzOiBbJ2NsaWNrJywgJ2ZvY3VzJ11cclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgLy8gU2VlIGlmIHRoaXMgY29tcG9uZW50IGlzIHZpc2libGUgb3Igbm90LlxyXG4gICAgICAgICAgJHNjb3BlLmlzVmlzaWJsZSA9IGZ1bmN0aW9uKGNvbXBvbmVudCwgcm93KSB7XHJcbiAgICAgICAgICAgIGlmICgkc2NvcGUuYnVpbGRlcikgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybiBGb3JtaW9VdGlscy5pc1Zpc2libGUoXHJcbiAgICAgICAgICAgICAgY29tcG9uZW50LFxyXG4gICAgICAgICAgICAgIHJvdyxcclxuICAgICAgICAgICAgICAkc2NvcGUuc3VibWlzc2lvbiA/ICRzY29wZS5zdWJtaXNzaW9uLmRhdGEgOiBudWxsLFxyXG4gICAgICAgICAgICAgICRzY29wZS5oaWRlQ29tcG9uZW50c1xyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAvLyBGT1ItMjQ1IC0gRml4IHJlc2V0IGJ1dHRvbnMuXHJcbiAgICAgICAgICAkc2NvcGUucmVzZXRGb3JtID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IHJlbW92ZSBlYWNoIGtleSBzbyB3ZSBkb24ndCBsb3NlIGEgcmVmZXJlbmNlIHRvIG9yaWdpbmFsXHJcbiAgICAgICAgICAgIC8vIGRhdGEgaW4gY2hpbGQgc2NvcGVzLlxyXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gJHNjb3BlLmRhdGEpIHtcclxuICAgICAgICAgICAgICBkZWxldGUgJHNjb3BlLmRhdGFba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAkc2NvcGUuaXNEaXNhYmxlZCA9IGZ1bmN0aW9uKGNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJHNjb3BlLnJlYWRPbmx5IHx8ICh0eXBlb2YgJHNjb3BlLiRwYXJlbnQuaXNEaXNhYmxlZCA9PT0gJ2Z1bmN0aW9uJyAmJiAkc2NvcGUuJHBhcmVudC5pc0Rpc2FibGVkKGNvbXBvbmVudCkpO1xyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAkc2NvcGUuaXNSZXF1aXJlZCA9IGZ1bmN0aW9uKGNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gRm9ybWlvVXRpbHMuaXNSZXF1aXJlZChjb21wb25lbnQpO1xyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAvLyBQYXNzIHRocm91Z2ggY2hlY2tDb25kaXRpb25hbCBzaW5jZSB0aGlzIGlzIGFuIGlzb2xhdGUgc2NvcGUuXHJcbiAgICAgICAgICAkc2NvcGUuY2hlY2tDb25kaXRpb25hbCA9ICRzY29wZS4kcGFyZW50LmNoZWNrQ29uZGl0aW9uYWw7XHJcblxyXG4gICAgICAgICAgLy8gRk9SLTcxIC0gRG9udCB3YXRjaCBpbiB0aGUgYnVpbGRlciB2aWV3LlxyXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIHZhbHVlIHdoZW4gZGF0YSBjaGFuZ2VzLlxyXG4gICAgICAgICAgaWYgKCEkc2NvcGUuYnVpbGRlciAmJiAoJHNjb3BlLmNvbXBvbmVudC5jYWxjdWxhdGVWYWx1ZSB8fCAoanNvbkxvZ2ljICYmIF9nZXQoJHNjb3BlLmNvbXBvbmVudCwgJ3ZhbGlkYXRlLmpzb24nKSkpKSB7XHJcbiAgICAgICAgICAgICRzY29wZS4kd2F0Y2goJ2RhdGEnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAvLyBQcm9jZXNzIGNhbGN1bGF0ZWQgdmFsdWUgc3R1ZmYgaWYgcHJlc2VudC5cclxuICAgICAgICAgICAgICBpZiAoJHNjb3BlLmNvbXBvbmVudC5jYWxjdWxhdGVWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgJHNjb3BlLmRhdGFbJHNjb3BlLmNvbXBvbmVudC5rZXldID0gZXZhbCgnKGZ1bmN0aW9uKGRhdGEpIHsgdmFyIHZhbHVlID0gW107JyArICRzY29wZS5jb21wb25lbnQuY2FsY3VsYXRlVmFsdWUudG9TdHJpbmcoKSArICc7IHJldHVybiB2YWx1ZTsgfSkoJHNjb3BlLmRhdGEpJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXHJcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQW4gZXJyb3Igb2NjdXJyZWQgY2FsY3VsYXRpbmcgYSB2YWx1ZSBmb3IgJyArICRzY29wZS5jb21wb25lbnQua2V5LCBlKTtcclxuICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAvLyBQcm9jZXNzIGpzb25Mb2dpYyBzdHVmZiBpZiBwcmVzZW50LlxyXG4gICAgICAgICAgICAgIGlmIChqc29uTG9naWMgJiYgX2dldCgkc2NvcGUuY29tcG9uZW50LCAndmFsaWRhdGUuanNvbicpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQ7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gT25seSBqc29uIHBhcnNlIG9uY2UuXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mICRzY29wZS5jb21wb25lbnQudmFsaWRhdGUuanNvbiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBpbnB1dCA9IEpTT04ucGFyc2UoJHNjb3BlLmNvbXBvbmVudC52YWxpZGF0ZS5qc29uKTtcclxuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY29tcG9uZW50LnZhbGlkYXRlLmpzb24gPSBpbnB1dDtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ludmFsaWQgSlNPTiB2YWxpZGF0b3IgZ2l2ZW4gZm9yICcgKyAkc2NvcGUuY29tcG9uZW50LmtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCRzY29wZS5jb21wb25lbnQudmFsaWRhdGUuanNvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlICRzY29wZS5jb21wb25lbnQudmFsaWRhdGUuanNvbjtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBpbnB1dCA9ICRzY29wZS5jb21wb25lbnQudmFsaWRhdGUuanNvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsaWQ7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICB2YWxpZCA9IGpzb25Mb2dpYy5hcHBseShpbnB1dCwge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6ICRzY29wZS5zdWJtaXNzaW9uLmRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgcm93OiAkc2NvcGUuZGF0YVxyXG4gICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgdmFsaWQgPSBlcnIubWVzc2FnZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWQgIT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5jb21wb25lbnQuY3VzdG9tRXJyb3IgPSB2YWxpZDtcclxuICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5mb3JtaW9Gb3JtWyRzY29wZS5jb21wb25lbnQua2V5XS4kc2V0VmFsaWRpdHkoJ2N1c3RvbScsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5mb3JtaW9Gb3JtWyRzY29wZS5jb21wb25lbnQua2V5XS4kc2V0VmFsaWRpdHkoJ2N1c3RvbScsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGFueSBpc3N1ZXMgd2hpbGUgZWRpdGluZyB0aGUgY29tcG9uZW50cy5cclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCB0cnVlKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBHZXQgdGhlIHNldHRpbmdzLlxyXG4gICAgICAgICAgdmFyIGNvbXBvbmVudCA9IGZvcm1pb0NvbXBvbmVudHMuY29tcG9uZW50c1skc2NvcGUuY29tcG9uZW50LnR5cGVdIHx8IGZvcm1pb0NvbXBvbmVudHMuY29tcG9uZW50c1snY3VzdG9tJ107XHJcblxyXG4gICAgICAgICAgLy8gU2V0IHRoZSBjb21wb25lbnQgd2l0aCB0aGUgZGVmYXVsdHMgZnJvbSB0aGUgY29tcG9uZW50IHNldHRpbmdzLlxyXG4gICAgICAgICAgLy8gRG9udCBhZGQgdGhlIGRlZmF1bHQga2V5LCBzbyB0aGF0IGNvbXBvbmVudHMgd2l0aG91dCBrZXlzIHdpbGwgcmVtYWluIHZpc2libGUgYnkgZGVmYXVsdC5cclxuICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChjb21wb25lbnQuc2V0dGluZ3MsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcclxuICAgICAgICAgICAgaWYgKCEkc2NvcGUuY29tcG9uZW50Lmhhc093blByb3BlcnR5KGtleSkgJiYga2V5ICE9PSAna2V5Jykge1xyXG4gICAgICAgICAgICAgICRzY29wZS5jb21wb25lbnRba2V5XSA9IGFuZ3VsYXIuY29weSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIC8vIEFkZCBhIG5ldyBmaWVsZCB2YWx1ZS5cclxuICAgICAgICAgICRzY29wZS5hZGRGaWVsZFZhbHVlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9ICcnO1xyXG4gICAgICAgICAgICBpZiAoJHNjb3BlLmNvbXBvbmVudC5oYXNPd25Qcm9wZXJ0eSgnY3VzdG9tRGVmYXVsdFZhbHVlJykpIHtcclxuICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cclxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gX2Nsb25lRGVlcCgkc2NvcGUuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGV2YWwoJyhmdW5jdGlvbihkYXRhKSB7IHZhciB2YWx1ZSA9IFwiXCI7JyArICRzY29wZS5jb21wb25lbnQuY3VzdG9tRGVmYXVsdFZhbHVlLnRvU3RyaW5nKCkgKyAnOyByZXR1cm4gdmFsdWU7IH0pKGRhdGEpJyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0FuIGVycm9yIG9jY3VycmVuZCBpbiBhIGN1c3RvbSBkZWZhdWx0IHZhbHVlIGluICcgKyAkc2NvcGUuY29tcG9uZW50LmtleSwgZSk7XHJcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cclxuICAgICAgICAgICAgICAgIHZhbHVlID0gJyc7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCRzY29wZS5jb21wb25lbnQuaGFzT3duUHJvcGVydHkoJ2RlZmF1bHRWYWx1ZScpKSB7XHJcbiAgICAgICAgICAgICAgLy8gRml4IGZvciBzZWxlY3QgY29tcG9uZW50c1xyXG4gICAgICAgICAgICAgIGlmICgkc2NvcGUuY29tcG9uZW50LnR5cGUgPT09ICdzZWxlY3QnKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAvLyBBbGxvdyBhIGtleTp2YWx1ZSBzZWFyY2hcclxuICAgICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gJHNjb3BlLmNvbXBvbmVudC5kZWZhdWx0VmFsdWUuc3BsaXQoJzonKTtcclxuICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdHM7XHJcbiAgICAgICAgICAgICAgICAgIC8vIElmIG9ubHkgb25lIHBhcnQgd2FzIHNwZWNpZmllZCwgc2VhcmNoIGJ5IHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1kZXB0aCAqL1xyXG4gICAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IF9maWx0ZXIoJHNjb3BlLnNlbGVjdEl0ZW1zLCB7dmFsdWU6IHBhcnRzWzBdfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyaW0gcmVzdWx0cyBiYXNlZCBvbiBtdWx0aXBsZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghJHNjb3BlLmNvbXBvbmVudC5tdWx0aXBsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZXN1bHRzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZXN1bHRzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAvLyBJZiB0d28gcGFydHMgd2VyZSBzcGVjaWZpZWQsIGFsbG93IGZvciBrZXkgYW5kIHZhbHVlIGN1c3RvbWl6YXRpb24uXHJcbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWFyY2ggPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBzZWFyY2hbcGFydHNbMF1dID0gcGFydHNbMV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBfZmlsdGVyKCRzY29wZS5zZWxlY3RJdGVtcywgc2VhcmNoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJpbSByZXN1bHRzIGJhc2VkIG9uIG11bHRpcGxlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkc2NvcGUuY29tcG9uZW50Lm11bHRpcGxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdHMuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdHM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXHJcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBbiBpc3N1ZSBvY2N1cnJlZCB3aXRoIHRoZSBzZWxlY3QgZGVmYXVsdFZhbHVlIGZvcjogJyArICRzY29wZS5jb21wb25lbnQua2V5KTtcclxuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0NvdWxkIG5vdCBmaW5kIGRlZmF1bHRWYWx1ZSAoJyArICRzY29wZS5kZWZhdWx0VmFsdWUgKyAnKSBpbiB0aGUgc2VsZWN0SXRlbXMnKTtcclxuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJHNjb3BlLnNlbGVjdEl0ZW1zKTtcclxuICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAkc2NvcGUuY29tcG9uZW50LmRlZmF1bHRWYWx1ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgJHNjb3BlLmRhdGFbJHNjb3BlLmNvbXBvbmVudC5rZXldID0gJHNjb3BlLmRhdGFbJHNjb3BlLmNvbXBvbmVudC5rZXldIHx8IFtdO1xyXG4gICAgICAgICAgICAkc2NvcGUuZGF0YVskc2NvcGUuY29tcG9uZW50LmtleV0ucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIC8vIFJlbW92ZSBhIGZpZWxkIHZhbHVlLlxyXG4gICAgICAgICAgJHNjb3BlLnJlbW92ZUZpZWxkVmFsdWUgPSBmdW5jdGlvbihpbmRleCkge1xyXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoJHNjb3BlLmRhdGFbJHNjb3BlLmNvbXBvbmVudC5rZXldKSkge1xyXG4gICAgICAgICAgICAgICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAvLyBTZXQgdGhlIHRlbXBsYXRlIGZvciB0aGUgY29tcG9uZW50LlxyXG4gICAgICAgICAgaWYgKHR5cGVvZiBjb21wb25lbnQudGVtcGxhdGUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgJHNjb3BlLnRlbXBsYXRlID0gY29tcG9uZW50LnRlbXBsYXRlKCRzY29wZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgJHNjb3BlLnRlbXBsYXRlID0gY29tcG9uZW50LnRlbXBsYXRlO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEFsbG93IGNvbXBvbmVudCBrZXlzIHRvIGxvb2sgbGlrZSBcInNldHRpbmdzW3VzZXJuYW1lXVwiXHJcbiAgICAgICAgICBpZiAoJHNjb3BlLmNvbXBvbmVudC5rZXkgJiYgJHNjb3BlLmNvbXBvbmVudC5rZXkuaW5kZXhPZignWycpICE9PSAtMSkge1xyXG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9ICRzY29wZS5jb21wb25lbnQua2V5Lm1hdGNoKC8oW15cXFtdKylcXFsoW15dKylcXF0vKTtcclxuICAgICAgICAgICAgaWYgKChtYXRjaGVzLmxlbmd0aCA9PT0gMykgJiYgJHNjb3BlLmRhdGEuaGFzT3duUHJvcGVydHkobWF0Y2hlc1sxXSkpIHtcclxuICAgICAgICAgICAgICAkc2NvcGUuZGF0YSA9ICRzY29wZS5kYXRhW21hdGNoZXNbMV1dO1xyXG4gICAgICAgICAgICAgICRzY29wZS5jb21wb25lbnQua2V5ID0gbWF0Y2hlc1syXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIElmIHRoZSBjb21wb25lbnQgaGFzIGEgY29udHJvbGxlci5cclxuICAgICAgICAgIGlmIChjb21wb25lbnQuY29udHJvbGxlcikge1xyXG4gICAgICAgICAgICAvLyBNYWludGFpbiByZXZlcnNlIGNvbXBhdGliaWxpdHkgYnkgZXhlY3V0aW5nIHRoZSBvbGQgbWV0aG9kIHN0eWxlLlxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbXBvbmVudC5jb250cm9sbGVyID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgY29tcG9uZW50LmNvbnRyb2xsZXIoJHNjb3BlLmNvbXBvbmVudCwgJHNjb3BlLCAkaHR0cCwgRm9ybWlvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAkY29udHJvbGxlcihjb21wb25lbnQuY29udHJvbGxlciwgeyRzY29wZTogJHNjb3BlLCAkdGltZW91dDogJHRpbWVvdXR9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEZPUi03MSAtIERvbnQgd2F0Y2ggaW4gdGhlIGJ1aWxkZXIgdmlldy5cclxuICAgICAgICAgIGlmICghJHNjb3BlLmJ1aWxkZXIpIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFVzaW5nIHRoZSBsaXN0IG9mIGRlZmF1bHQgb3B0aW9ucywgc3BsaXQgdGhlbSB3aXRoIHRoZSBpZGVudGlmaWVyLCBhbmQgdXNlIGZpbHRlciB0byBnZXQgZWFjaCBpdGVtLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gZGVmYXVsdEl0ZW1zXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSBzZWFyY2hJdGVtc1xyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgcGx1Y2tJdGVtcyA9IGZ1bmN0aW9uKGRlZmF1bHRJdGVtcywgc2VhcmNoSXRlbXMpIHtcclxuICAgICAgICAgICAgICB2YXIgdGVtcCA9IFtdO1xyXG4gICAgICAgICAgICAgIGlmICghZGVmYXVsdEl0ZW1zIHx8ICFkZWZhdWx0SXRlbXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGVtcDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZhdWx0SXRlbXMgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0SXRlbXMgPSBbZGVmYXVsdEl0ZW1zXTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGRlZmF1bHRJdGVtcy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IGl0ZW0uc3BsaXQoJzonKTtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHtcclxuICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IF9maWx0ZXIoc2VhcmNoSXRlbXMsIGZ1bmN0aW9uKHBvdGVudGlhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfZ2V0KHBvdGVudGlhbCwgcGFydHNbMF0pID09PSBwYXJ0c1sxXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wID0gdGVtcC5jb25jYXQocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICByZXR1cm4gdGVtcDtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICRzY29wZS4kd2F0Y2goJ2NvbXBvbmVudC5tdWx0aXBsZScsIGZ1bmN0aW9uKG11bHQpIHtcclxuICAgICAgICAgICAgICAvLyBFc3RhYmxpc2ggYSBkZWZhdWx0IGZvciBkYXRhLlxyXG4gICAgICAgICAgICAgICRzY29wZS5kYXRhID0gJHNjb3BlLmRhdGEgfHwge307XHJcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgLy8gVXNlIHRoZSBjdXJyZW50IGRhdGEgb3IgZGVmYXVsdC5cclxuICAgICAgICAgICAgICBpZiAoJHNjb3BlLmRhdGEuaGFzT3duUHJvcGVydHkoJHNjb3BlLmNvbXBvbmVudC5rZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW11bHQpIHtcclxuICAgICAgICAgICAgICAgICAgJHNjb3BlLmRhdGFbJHNjb3BlLmNvbXBvbmVudC5rZXldID0gJHNjb3BlLmRhdGFbJHNjb3BlLmNvbXBvbmVudC5rZXldO1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgYSB2YWx1ZSBpcyBwcmVzZW50LCBhbmQgaXRzIGFuIGFycmF5LCBhc3NpZ24gaXQgdG8gdGhlIHZhbHVlLlxyXG4gICAgICAgICAgICAgICAgaWYgKCRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gJHNjb3BlLmRhdGFbJHNjb3BlLmNvbXBvbmVudC5rZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gSWYgYSB2YWx1ZSBpcyBwcmVzZW50IGFuZCBpdCBpcyBub3QgYW4gYXJyYXksIHdyYXAgdGhlIHZhbHVlLlxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gJHNjb3BlLmRhdGFbJHNjb3BlLmNvbXBvbmVudC5rZXldLnNwbGl0KCcsJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgJHNjb3BlLmRhdGFbJHNjb3BlLmNvbXBvbmVudC5rZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGVsc2UgaWYgKCRzY29wZS5jb21wb25lbnQuaGFzT3duUHJvcGVydHkoJ2N1c3RvbURlZmF1bHRWYWx1ZScpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW11bHQpIHtcclxuICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGV2YWwoJyhmdW5jdGlvbihkYXRhKSB7IHZhciB2YWx1ZSA9IFwiXCI7JyArICRzY29wZS5jb21wb25lbnQuY3VzdG9tRGVmYXVsdFZhbHVlLnRvU3RyaW5nKCkgKyAnOyByZXR1cm4gdmFsdWU7IH0pKCRzY29wZS5kYXRhKScpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQW4gZXJyb3Igb2NjdXJyZW5kIGluIGEgY3VzdG9tIGRlZmF1bHQgdmFsdWUgaW4gJyArICRzY29wZS5jb21wb25lbnQua2V5LCBlKTtcclxuICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgdmFsdWUgPSBldmFsKCcoZnVuY3Rpb24oZGF0YSkgeyB2YXIgdmFsdWUgPSBcIlwiOycgKyAkc2NvcGUuY29tcG9uZW50LmN1c3RvbURlZmF1bHRWYWx1ZS50b1N0cmluZygpICsgJzsgcmV0dXJuIHZhbHVlOyB9KSgkc2NvcGUuZGF0YSknKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cclxuICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdBbiBlcnJvciBvY2N1cnJlbmQgaW4gYSBjdXN0b20gZGVmYXVsdCB2YWx1ZSBpbiAnICsgJHNjb3BlLmNvbXBvbmVudC5rZXksIGUpO1xyXG4gICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cclxuICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBlbHNlIGlmICgkc2NvcGUuY29tcG9uZW50Lmhhc093blByb3BlcnR5KCdkZWZhdWx0VmFsdWUnKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gRkEtODM1IC0gVGhlIGRlZmF1bHQgdmFsdWVzIGZvciBzZWxlY3QgYm94ZXMgYXJlIHNldCBpbiB0aGUgY29tcG9uZW50LlxyXG4gICAgICAgICAgICAgICAgaWYgKCRzY29wZS5jb21wb25lbnQudHlwZSA9PT0gJ3NlbGVjdGJveGVzJykge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBkZWZhdWx0IHZhbHVlIGFuZCBpdCBpcyBub3QgYW4gYXJyYXksIHdyYXAgdGhlIHZhbHVlLlxyXG4gICAgICAgICAgICAgICAgaWYgKG11bHQgJiYgdHlwZW9mICRzY29wZS5jb21wb25lbnQuZGVmYXVsdFZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9ICRzY29wZS5jb21wb25lbnQuZGVmYXVsdFZhbHVlLnNwbGl0KCcsJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgdmFsdWUgPSAkc2NvcGUuY29tcG9uZW50LmRlZmF1bHRWYWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBubyBkZWZhdWx0IGlzIHByb3ZpZGVkLCB0aGVuIHNraXAuLi5cclxuICAgICAgICAgICAgICAgIGlmICghdmFsdWUgfHwgIXZhbHVlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRk9SLTE5MyAtIEZpeCBkZWZhdWx0IHZhbHVlIGZvciB0aGUgbnVtYmVyIGNvbXBvbmVudC5cclxuICAgICAgICAgICAgICAgIC8vIEZPUi0yNjIgLSBGaXggbXVsdGlwbGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIG51bWJlciBjb21wb25lbnQuXHJcbiAgICAgICAgICAgICAgICBpZiAoJHNjb3BlLmNvbXBvbmVudC50eXBlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgICBpZiAoIW11bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBGT1ItMjkwIC0gRml4IGRlZmF1bHQgdmFsdWVzIGZvciBudW1iZXIgY29tcG9uZW50cywgdG8gYWxsb3cgZGVjaW1hbCBudW1iZXJzLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgkc2NvcGUuY29tcG9uZW50LmRlZmF1bHRWYWx1ZS5pbmRleE9mKCcuJykgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YVskc2NvcGUuY29tcG9uZW50LmtleV0gPSBwYXJzZUZsb2F0KCRzY29wZS5jb21wb25lbnQuZGVmYXVsdFZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSA9IHBhcnNlSW50KCRzY29wZS5jb21wb25lbnQuZGVmYXVsdFZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSA9IHZhbHVlLm1hcChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgIC8vIEZPUi0yOTAgLSBGaXggZGVmYXVsdCB2YWx1ZXMgZm9yIG51bWJlciBjb21wb25lbnRzLCB0byBhbGxvdyBkZWNpbWFsIG51bWJlcnMuXHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5pbmRleE9mKCcuJykgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIEZPUi0xMzUgLSBBZGQgZGVmYXVsdCB2YWx1ZXMgZm9yIHNlbGVjdCBjb21wb25lbnRzLlxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoJHNjb3BlLmNvbXBvbmVudC50eXBlID09PSAnc2VsZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAvLyBGT1ItMzM3IC0gRml4IGRlZmF1bHQgdmFsdWVzIGZvciBzZWxlY3QgY29tcG9uZW50cyB3aXRob3V0IG11bHRpIGVuYWJsZWQuXHJcbiAgICAgICAgICAgICAgICAgIGlmICghbXVsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSA9ICRzY29wZS5jb21wb25lbnQuZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gSWYgdXNpbmcgdGhlIHZhbHVlcyBpbnB1dCwgc3BsaXQgdGhlIGRlZmF1bHQgdmFsdWVzLCBhbmQgc2VhcmNoIHRoZSBvcHRpb25zIGZvciBlYWNoIHZhbHVlIGluIHRoZSBsaXN0LlxyXG4gICAgICAgICAgICAgICAgICBpZiAoJHNjb3BlLmNvbXBvbmVudC5kYXRhU3JjID09PSAndmFsdWVzJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5jb21wb25lbnQuZGF0YS52YWx1ZXMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUuaW5kZXhPZihpdGVtLnZhbHVlKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcC5wdXNoKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YVskc2NvcGUuY29tcG9uZW50LmtleV0gPSB0ZW1wO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAvLyBJZiB1c2luZyBqc29uIGlucHV0LCBzcGxpdCB0aGUgdmFsdWVzIGFuZCBzZWFyY2ggZWFjaCBrZXkgcGF0aCBmb3IgdGhlIGl0ZW1cclxuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoJHNjb3BlLmNvbXBvbmVudC5kYXRhU3JjID09PSAnanNvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mICRzY29wZS5jb21wb25lbnQuZGF0YS5qc29uID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmNvbXBvbmVudC5kYXRhLmpzb24gPSBKU09OLnBhcnNlKCRzY29wZS5jb21wb25lbnQuZGF0YS5qc29uKTtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDb3VsZCBub3QgcGFyc2UgdGhlIGdpdmVuIEpTT04gZm9yIHRoZSBzZWxlY3QgY29tcG9uZW50OiAnICsgJHNjb3BlLmNvbXBvbmVudC5rZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygkc2NvcGUuY29tcG9uZW50LmRhdGEuanNvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY29tcG9uZW50LmRhdGEuanNvbiA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmRhdGFbJHNjb3BlLmNvbXBvbmVudC5rZXldID0gcGx1Y2tJdGVtcyh2YWx1ZSwgJHNjb3BlLmNvbXBvbmVudC5kYXRhLmpzb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBlbHNlIGlmICgkc2NvcGUuY29tcG9uZW50LmRhdGFTcmMgPT09ICd1cmwnIHx8ICRzY29wZS5jb21wb25lbnQuZGF0YVNyYyA9PT0gJ3Jlc291cmNlJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdhaXQgdW50aWwgbG9hZGluZyBpcyBkb25lLlxyXG4gICAgICAgICAgICAgICAgICAgICRzY29wZS4kb24oJ3NlbGVjdExvYWRlZCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmRhdGFbJHNjb3BlLmNvbXBvbmVudC5rZXldID0gcGx1Y2tJdGVtcyh2YWx1ZSwgJHNjb3BlLnNlbGVjdEl0ZW1zKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gRk9SLTUwNCAtIEZpeCBkZWZhdWx0IHZhbHVlcyBmb3Igc3VydmV5IGNvbXBvbmVudHMuXHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgkc2NvcGUuY29tcG9uZW50LnR5cGUgPT09ICdzdXJ2ZXknKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmICghJHNjb3BlLmNvbXBvbmVudC5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdFZhbHVlJykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSA9ICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSB8fCB7fTtcclxuICAgICAgICAgICAgICAgICAgJHNjb3BlLmNvbXBvbmVudC5xdWVzdGlvbnMuZm9yRWFjaChmdW5jdGlvbihxdWVzdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmRhdGFbJHNjb3BlLmNvbXBvbmVudC5rZXldW3F1ZXN0aW9uLnZhbHVlXSA9ICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XVtxdWVzdGlvbi52YWx1ZV0gfHwgJHNjb3BlLmNvbXBvbmVudC5kZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmICghbXVsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5kYXRhWyRzY29wZS5jb21wb25lbnQua2V5XSA9ICRzY29wZS5jb21wb25lbnQuZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBkZWZhdWx0IHZhbHVlIGFuZCBpdCBpcyBhbiBhcnJheSwgYXNzaWduIGl0IHRvIHRoZSB2YWx1ZS5cclxuICAgICAgICAgICAgICAgICAgaWYgKCRzY29wZS5jb21wb25lbnQuZGVmYXVsdFZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YVskc2NvcGUuY29tcG9uZW50LmtleV0gPSAkc2NvcGUuY29tcG9uZW50LmRlZmF1bHRWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIE1ha2UgdGhlIGRlZmF1bHRWYWx1ZSBhIHNpbmdsZSBlbGVtZW50IGFycmF5IGJlY2F1c2Ugd2VyZSBtdWx0aS5cclxuICAgICAgICAgICAgICAgICAgJHNjb3BlLmRhdGFbJHNjb3BlLmNvbXBvbmVudC5rZXldID0gWyRzY29wZS5jb21wb25lbnQuZGVmYXVsdFZhbHVlXTtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgLy8gQ291bGRuJ3Qgc2FmZWx5IGRlZmF1bHQsIGRvbid0IGFkZCBhIGdhcmJhZ2UgdmFsdWUuXHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBTZXQgdGhlIGNvbXBvbmVudCBuYW1lLlxyXG4gICAgICAgICAgJHNjb3BlLmNvbXBvbmVudElkID0gJHNjb3BlLmNvbXBvbmVudC5rZXk7XHJcbiAgICAgICAgICBpZiAoJHNjb3BlLmdyaWRSb3cgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAkc2NvcGUuY29tcG9uZW50SWQgKz0gKCctJyArICRzY29wZS5ncmlkUm93KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICgkc2NvcGUuZ3JpZENvbCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICRzY29wZS5jb21wb25lbnRJZCArPSAoJy0nICsgJHNjb3BlLmdyaWRDb2wpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgXVxyXG4gICAgfTtcclxuICB9XHJcbl07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBbXHJcbiAgJ2Zvcm1pb0NvbXBvbmVudHMnLFxyXG4gIGZ1bmN0aW9uKFxyXG4gICAgZm9ybWlvQ29tcG9uZW50c1xyXG4gICkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcmVwbGFjZTogdHJ1ZSxcclxuICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgc2NvcGU6IHtcclxuICAgICAgICBjb21wb25lbnQ6ICc9JyxcclxuICAgICAgICBkYXRhOiAnPScsXHJcbiAgICAgICAgZm9ybTogJz0nLFxyXG4gICAgICAgIHN1Ym1pc3Npb246ICc9JyxcclxuICAgICAgICBpZ25vcmU6ICc9PycsXHJcbiAgICAgICAgYnVpbGRlcjogJz0/J1xyXG4gICAgICB9LFxyXG4gICAgICB0ZW1wbGF0ZVVybDogJ2Zvcm1pby9jb21wb25lbnQtdmlldy5odG1sJyxcclxuICAgICAgY29udHJvbGxlcjogW1xyXG4gICAgICAgICckc2NvcGUnLFxyXG4gICAgICAgICdGb3JtaW8nLFxyXG4gICAgICAgICdGb3JtaW9VdGlscycsXHJcbiAgICAgICAgZnVuY3Rpb24oXHJcbiAgICAgICAgICAkc2NvcGUsXHJcbiAgICAgICAgICBGb3JtaW8sXHJcbiAgICAgICAgICBGb3JtaW9VdGlsc1xyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgLy8gU2V0IHRoZSBmb3JtIHVybC5cclxuICAgICAgICAgICRzY29wZS5mb3JtVXJsID0gJHNjb3BlLmZvcm0gPyBGb3JtaW8uZ2V0QXBwVXJsKCkgKyAnL2Zvcm0vJyArICRzY29wZS5mb3JtLl9pZC50b1N0cmluZygpIDogJyc7XHJcbiAgICAgICAgICAkc2NvcGUuaXNWaXNpYmxlID0gZnVuY3Rpb24oY29tcG9uZW50LCByb3cpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEZvcm1pb1V0aWxzLmlzVmlzaWJsZShcclxuICAgICAgICAgICAgICBjb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgcm93LFxyXG4gICAgICAgICAgICAgICRzY29wZS5zdWJtaXNzaW9uID8gJHNjb3BlLnN1Ym1pc3Npb24uZGF0YSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgJHNjb3BlLmhpZGVDb21wb25lbnRzXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIC8vIEdldCB0aGUgc2V0dGluZ3MuXHJcbiAgICAgICAgICB2YXIgY29tcG9uZW50ID0gZm9ybWlvQ29tcG9uZW50cy5jb21wb25lbnRzWyRzY29wZS5jb21wb25lbnQudHlwZV0gfHwgZm9ybWlvQ29tcG9uZW50cy5jb21wb25lbnRzWydjdXN0b20nXTtcclxuXHJcbiAgICAgICAgICAvLyBTZXQgdGhlIHRlbXBsYXRlIGZvciB0aGUgY29tcG9uZW50LlxyXG4gICAgICAgICAgaWYgKCFjb21wb25lbnQudmlld1RlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgICRzY29wZS50ZW1wbGF0ZSA9ICdmb3JtaW8vZWxlbWVudC12aWV3Lmh0bWwnO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNvbXBvbmVudC52aWV3VGVtcGxhdGUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgJHNjb3BlLnRlbXBsYXRlID0gY29tcG9uZW50LnZpZXdUZW1wbGF0ZSgkc2NvcGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICRzY29wZS50ZW1wbGF0ZSA9IGNvbXBvbmVudC52aWV3VGVtcGxhdGU7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gU2V0IHRoZSBjb21wb25lbnQgbmFtZS5cclxuICAgICAgICAgICRzY29wZS5jb21wb25lbnRJZCA9ICRzY29wZS5jb21wb25lbnQua2V5O1xyXG4gICAgICAgICAgaWYgKCRzY29wZS5ncmlkUm93ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgJHNjb3BlLmNvbXBvbmVudElkICs9ICgnLScgKyAkc2NvcGUuZ3JpZFJvdyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoJHNjb3BlLmdyaWRDb2wgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAkc2NvcGUuY29tcG9uZW50SWQgKz0gKCctJyArICRzY29wZS5ncmlkQ29sKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIF1cclxuICAgIH07XHJcbiAgfVxyXG5dO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICByZXBsYWNlOiB0cnVlLFxyXG4gICAgc2NvcGU6IHtcclxuICAgICAgZm9ybTogJz0/JyxcclxuICAgICAgc3VibWlzc2lvbjogJz0/JyxcclxuICAgICAgc3JjOiAnPT8nLFxyXG4gICAgICBmb3JtQWN0aW9uOiAnPT8nLFxyXG4gICAgICByZXNvdXJjZU5hbWU6ICc9PycsXHJcbiAgICAgIG1lc3NhZ2U6ICc9PydcclxuICAgIH0sXHJcbiAgICB0ZW1wbGF0ZVVybDogJ2Zvcm1pby1kZWxldGUuaHRtbCcsXHJcbiAgICBjb250cm9sbGVyOiBbXHJcbiAgICAgICckc2NvcGUnLFxyXG4gICAgICAnJGVsZW1lbnQnLFxyXG4gICAgICAnRm9ybWlvU2NvcGUnLFxyXG4gICAgICAnRm9ybWlvJyxcclxuICAgICAgJyRodHRwJyxcclxuICAgICAgZnVuY3Rpb24oXHJcbiAgICAgICAgJHNjb3BlLFxyXG4gICAgICAgICRlbGVtZW50LFxyXG4gICAgICAgIEZvcm1pb1Njb3BlLFxyXG4gICAgICAgIEZvcm1pbyxcclxuICAgICAgICAkaHR0cFxyXG4gICAgICApIHtcclxuICAgICAgICAkc2NvcGUuX3NyYyA9ICRzY29wZS5zcmMgfHwgJyc7XHJcbiAgICAgICAgJHNjb3BlLmZvcm1pb0FsZXJ0cyA9IFtdO1xyXG4gICAgICAgIC8vIFNob3dzIHRoZSBnaXZlbiBhbGVydHMgKHNpbmdsZSBvciBhcnJheSksIGFuZCBkaXNtaXNzZXMgb2xkIGFsZXJ0c1xyXG4gICAgICAgICRzY29wZS5zaG93QWxlcnRzID0gZnVuY3Rpb24oYWxlcnRzKSB7XHJcbiAgICAgICAgICAkc2NvcGUuZm9ybWlvQWxlcnRzID0gW10uY29uY2F0KGFsZXJ0cyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgcmVzb3VyY2VOYW1lID0gJ3Jlc291cmNlJztcclxuICAgICAgICB2YXIgbWV0aG9kTmFtZSA9ICcnO1xyXG4gICAgICAgIHZhciBsb2FkZXIgPSBGb3JtaW9TY29wZS5yZWdpc3Rlcigkc2NvcGUsICRlbGVtZW50LCB7XHJcbiAgICAgICAgICBmb3JtOiB0cnVlLFxyXG4gICAgICAgICAgc3VibWlzc2lvbjogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAobG9hZGVyKSB7XHJcbiAgICAgICAgICByZXNvdXJjZU5hbWUgPSBsb2FkZXIuc3VibWlzc2lvbklkID8gJ3N1Ym1pc3Npb24nIDogJ2Zvcm0nO1xyXG4gICAgICAgICAgdmFyIHJlc291cmNlVGl0bGUgPSByZXNvdXJjZU5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyByZXNvdXJjZU5hbWUuc2xpY2UoMSk7XHJcbiAgICAgICAgICBtZXRob2ROYW1lID0gJ2RlbGV0ZScgKyByZXNvdXJjZVRpdGxlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2V0IHRoZSByZXNvdXJjZSBuYW1lXHJcbiAgICAgICAgJHNjb3BlLl9yZXNvdXJjZU5hbWUgPSAkc2NvcGUucmVzb3VyY2VOYW1lIHx8IHJlc291cmNlTmFtZTtcclxuICAgICAgICAkc2NvcGUuZGVsZXRlTWVzc2FnZSA9ICRzY29wZS5tZXNzYWdlIHx8ICdBcmUgeW91IHN1cmUgeW91IHdpc2ggdG8gZGVsZXRlIHRoZSAnICsgJHNjb3BlLl9yZXNvdXJjZU5hbWUgKyAnPyc7XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBkZWxldGUgY2FwYWJpbGl0eS5cclxuICAgICAgICAkc2NvcGUub25EZWxldGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIC8vIFJlYnVpbGQgcmVzb3VyY2VUaXRsZSwgJHNjb3BlLnJlc291cmNlTmFtZSBjb3VsZCBoYXZlIGNoYW5nZWRcclxuICAgICAgICAgIHZhciByZXNvdXJjZU5hbWUgPSAkc2NvcGUucmVzb3VyY2VOYW1lIHx8ICRzY29wZS5fcmVzb3VyY2VOYW1lO1xyXG4gICAgICAgICAgdmFyIHJlc291cmNlVGl0bGUgPSByZXNvdXJjZU5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyByZXNvdXJjZU5hbWUuc2xpY2UoMSk7XHJcbiAgICAgICAgICAvLyBDYWxsZWQgd2hlbiB0aGUgZGVsZXRlIGlzIGRvbmUuXHJcbiAgICAgICAgICB2YXIgb25EZWxldGVEb25lID0gZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgICAgICAkc2NvcGUuc2hvd0FsZXJ0cyh7XHJcbiAgICAgICAgICAgICAgdHlwZTogJ3N1Y2Nlc3MnLFxyXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IHJlc291cmNlVGl0bGUgKyAnIHdhcyBkZWxldGVkLidcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIEZvcm1pby5jbGVhckNhY2hlKCk7XHJcbiAgICAgICAgICAgICRzY29wZS4kZW1pdCgnZGVsZXRlJywgZGF0YSk7XHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIGlmICgkc2NvcGUuYWN0aW9uKSB7XHJcbiAgICAgICAgICAgICRodHRwLmRlbGV0ZSgkc2NvcGUuYWN0aW9uKS50aGVuKG9uRGVsZXRlRG9uZSwgRm9ybWlvU2NvcGUub25FcnJvcigkc2NvcGUsICRlbGVtZW50KSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIGlmIChsb2FkZXIpIHtcclxuICAgICAgICAgICAgaWYgKCFtZXRob2ROYW1lKSByZXR1cm47XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbG9hZGVyW21ldGhvZE5hbWVdICE9PSAnZnVuY3Rpb24nKSByZXR1cm47XHJcbiAgICAgICAgICAgIGxvYWRlclttZXRob2ROYW1lXSgpLnRoZW4ob25EZWxldGVEb25lLCBGb3JtaW9TY29wZS5vbkVycm9yKCRzY29wZSwgJGVsZW1lbnQpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgICRzY29wZS5vbkNhbmNlbCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgJHNjb3BlLiRlbWl0KCdjYW5jZWwnKTtcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICBdXHJcbiAgfTtcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFtcclxuICAnJGNvbXBpbGUnLFxyXG4gICckdGVtcGxhdGVDYWNoZScsXHJcbiAgZnVuY3Rpb24oXHJcbiAgICAkY29tcGlsZSxcclxuICAgICR0ZW1wbGF0ZUNhY2hlXHJcbiAgKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzY29wZTogZmFsc2UsXHJcbiAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50KSB7XHJcbiAgICAgICAgZWxlbWVudC5yZXBsYWNlV2l0aCgkY29tcGlsZSgkdGVtcGxhdGVDYWNoZS5nZXQoc2NvcGUudGVtcGxhdGUpKShzY29wZSkpO1xyXG4gICAgICAgIHNjb3BlLiRlbWl0KCdmb3JtRWxlbWVudFJlbmRlcicsIGVsZW1lbnQpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuXTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICBzY29wZTogZmFsc2UsXHJcbiAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgdGVtcGxhdGVVcmw6ICdmb3JtaW8vZXJyb3JzLmh0bWwnXHJcbiAgfTtcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXBsYWNlOiB0cnVlLFxyXG4gICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgIHNjb3BlOiB7XHJcbiAgICAgIGZvcm06ICc9JyxcclxuICAgICAgc3VibWlzc2lvbjogJz0nLFxyXG4gICAgICBpZ25vcmU6ICc9PydcclxuICAgIH0sXHJcbiAgICB0ZW1wbGF0ZVVybDogJ2Zvcm1pby9zdWJtaXNzaW9uLmh0bWwnLFxyXG4gICAgY29udHJvbGxlcjogW1xyXG4gICAgICAnJHNjb3BlJyxcclxuICAgICAgJ0Zvcm1pb1V0aWxzJyxcclxuICAgICAgZnVuY3Rpb24oXHJcbiAgICAgICAgJHNjb3BlLFxyXG4gICAgICAgIEZvcm1pb1V0aWxzXHJcbiAgICAgICkge1xyXG4gICAgICAgICRzY29wZS5pc1Zpc2libGUgPSBmdW5jdGlvbihjb21wb25lbnQsIHJvdykge1xyXG4gICAgICAgICAgcmV0dXJuIEZvcm1pb1V0aWxzLmlzVmlzaWJsZShcclxuICAgICAgICAgICAgY29tcG9uZW50LFxyXG4gICAgICAgICAgICByb3csXHJcbiAgICAgICAgICAgICRzY29wZS5zdWJtaXNzaW9uID8gJHNjb3BlLnN1Ym1pc3Npb24uZGF0YSA6IG51bGwsXHJcbiAgICAgICAgICAgICRzY29wZS5pZ25vcmVcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgXVxyXG4gIH07XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4ge1xyXG4gICAgcmVwbGFjZTogdHJ1ZSxcclxuICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICBzY29wZToge1xyXG4gICAgICBzcmM6ICc9PycsXHJcbiAgICAgIGZvcm06ICc9PycsXHJcbiAgICAgIHN1Ym1pc3Npb25zOiAnPT8nLFxyXG4gICAgICBwZXJQYWdlOiAnPT8nXHJcbiAgICB9LFxyXG4gICAgdGVtcGxhdGVVcmw6ICdmb3JtaW8vc3VibWlzc2lvbnMuaHRtbCcsXHJcbiAgICBjb250cm9sbGVyOiBbXHJcbiAgICAgICckc2NvcGUnLFxyXG4gICAgICAnJGVsZW1lbnQnLFxyXG4gICAgICAnRm9ybWlvU2NvcGUnLFxyXG4gICAgICBmdW5jdGlvbihcclxuICAgICAgICAkc2NvcGUsXHJcbiAgICAgICAgJGVsZW1lbnQsXHJcbiAgICAgICAgRm9ybWlvU2NvcGVcclxuICAgICAgKSB7XHJcbiAgICAgICAgJHNjb3BlLl9zcmMgPSAkc2NvcGUuc3JjIHx8ICcnO1xyXG4gICAgICAgICRzY29wZS5mb3JtaW9BbGVydHMgPSBbXTtcclxuICAgICAgICAvLyBTaG93cyB0aGUgZ2l2ZW4gYWxlcnRzIChzaW5nbGUgb3IgYXJyYXkpLCBhbmQgZGlzbWlzc2VzIG9sZCBhbGVydHNcclxuICAgICAgICB0aGlzLnNob3dBbGVydHMgPSAkc2NvcGUuc2hvd0FsZXJ0cyA9IGZ1bmN0aW9uKGFsZXJ0cykge1xyXG4gICAgICAgICAgJHNjb3BlLmZvcm1pb0FsZXJ0cyA9IFtdLmNvbmNhdChhbGVydHMpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgICRzY29wZS5wZXJQYWdlID0gJHNjb3BlLnBlclBhZ2UgPT09IHVuZGVmaW5lZCA/IDEwIDogJHNjb3BlLnBlclBhZ2U7XHJcbiAgICAgICAgJHNjb3BlLmZvcm1pbyA9IEZvcm1pb1Njb3BlLnJlZ2lzdGVyKCRzY29wZSwgJGVsZW1lbnQsIHtcclxuICAgICAgICAgIGZvcm06IHRydWUsXHJcbiAgICAgICAgICBzdWJtaXNzaW9uczogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAkc2NvcGUuY3VycmVudFBhZ2UgPSAxO1xyXG4gICAgICAgICRzY29wZS5wYWdlQ2hhbmdlZCA9IGZ1bmN0aW9uKHBhZ2UpIHtcclxuICAgICAgICAgICRzY29wZS5za2lwID0gKHBhZ2UgLSAxKSAqICRzY29wZS5wZXJQYWdlO1xyXG4gICAgICAgICAgJHNjb3BlLnVwZGF0ZVN1Ym1pc3Npb25zKCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgJHNjb3BlLnRhYmxlVmlldyA9IGZ1bmN0aW9uKGNvbXBvbmVudCkge1xyXG4gICAgICAgICAgcmV0dXJuICFjb21wb25lbnQuaGFzT3duUHJvcGVydHkoJ3RhYmxlVmlldycpIHx8IGNvbXBvbmVudC50YWJsZVZpZXc7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgJHNjb3BlLiR3YXRjaCgnc3VibWlzc2lvbnMnLCBmdW5jdGlvbihzdWJtaXNzaW9ucykge1xyXG4gICAgICAgICAgaWYgKHN1Ym1pc3Npb25zICYmIHN1Ym1pc3Npb25zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgJHNjb3BlLiRlbWl0KCdzdWJtaXNzaW9uTG9hZCcsICRzY29wZS5zdWJtaXNzaW9ucyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIF1cclxuICB9O1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICByZXBsYWNlOiB0cnVlLFxyXG4gICAgdGVtcGxhdGVVcmw6ICdmb3JtaW8td2l6YXJkLmh0bWwnLFxyXG4gICAgc2NvcGU6IHtcclxuICAgICAgc3JjOiAnPT8nLFxyXG4gICAgICB1cmw6ICc9PycsXHJcbiAgICAgIGZvcm1BY3Rpb246ICc9PycsXHJcbiAgICAgIGZvcm06ICc9PycsXHJcbiAgICAgIHN1Ym1pc3Npb246ICc9PycsXHJcbiAgICAgIHJlYWRPbmx5OiAnPT8nLFxyXG4gICAgICBoaWRlQ29tcG9uZW50czogJz0/JyxcclxuICAgICAgZGlzYWJsZUNvbXBvbmVudHM6ICc9PycsXHJcbiAgICAgIGZvcm1pb09wdGlvbnM6ICc9PycsXHJcbiAgICAgIHN0b3JhZ2U6ICc9PydcclxuICAgIH0sXHJcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCkge1xyXG4gICAgICAvLyBGcm9tIGh0dHBzOi8vc2lvbmd1aS5naXRodWIuaW8vMjAxMy8wNS8xMi9hbmd1bGFyanMtZ2V0LWVsZW1lbnQtb2Zmc2V0LXBvc2l0aW9uL1xyXG4gICAgICB2YXIgb2Zmc2V0ID0gZnVuY3Rpb24oZWxtKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHJldHVybiBlbG0ub2Zmc2V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAvLyBEbyBub3RoaW5nLi4uXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByYXdEb20gPSBlbG1bMF07XHJcbiAgICAgICAgdmFyIF94ID0gMDtcclxuICAgICAgICB2YXIgX3kgPSAwO1xyXG4gICAgICAgIHZhciBib2R5ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IGRvY3VtZW50LmJvZHk7XHJcbiAgICAgICAgdmFyIHNjcm9sbFggPSB3aW5kb3cucGFnZVhPZmZzZXQgfHwgYm9keS5zY3JvbGxMZWZ0O1xyXG4gICAgICAgIHZhciBzY3JvbGxZID0gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGJvZHkuc2Nyb2xsVG9wO1xyXG4gICAgICAgIF94ID0gcmF3RG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgKyBzY3JvbGxYO1xyXG4gICAgICAgIF95ID0gcmF3RG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIHNjcm9sbFk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIGxlZnQ6IF94LFxyXG4gICAgICAgICAgdG9wOiBfeVxyXG4gICAgICAgIH07XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBzY29wZS53aXphcmRMb2FkZWQgPSBmYWxzZTtcclxuICAgICAgc2NvcGUud2l6YXJkVG9wID0gb2Zmc2V0KGVsZW1lbnQpLnRvcDtcclxuICAgICAgaWYgKHNjb3BlLndpemFyZFRvcCA+IDUwKSB7XHJcbiAgICAgICAgc2NvcGUud2l6YXJkVG9wIC09IDUwO1xyXG4gICAgICB9XHJcbiAgICAgIHNjb3BlLndpemFyZEVsZW1lbnQgPSBhbmd1bGFyLmVsZW1lbnQoJy5mb3JtaW8td2l6YXJkJywgZWxlbWVudCk7XHJcbiAgICB9LFxyXG4gICAgY29udHJvbGxlcjogW1xyXG4gICAgICAnJHNjb3BlJyxcclxuICAgICAgJyRjb21waWxlJyxcclxuICAgICAgJyRlbGVtZW50JyxcclxuICAgICAgJ0Zvcm1pbycsXHJcbiAgICAgICdGb3JtaW9TY29wZScsXHJcbiAgICAgICdGb3JtaW9VdGlscycsXHJcbiAgICAgICckaHR0cCcsXHJcbiAgICAgICckdGltZW91dCcsXHJcbiAgICAgIGZ1bmN0aW9uKFxyXG4gICAgICAgICRzY29wZSxcclxuICAgICAgICAkY29tcGlsZSxcclxuICAgICAgICAkZWxlbWVudCxcclxuICAgICAgICBGb3JtaW8sXHJcbiAgICAgICAgRm9ybWlvU2NvcGUsXHJcbiAgICAgICAgRm9ybWlvVXRpbHMsXHJcbiAgICAgICAgJGh0dHAsXHJcbiAgICAgICAgJHRpbWVvdXRcclxuICAgICAgKSB7XHJcbiAgICAgICAgdmFyIHNlc3Npb24gPSAoJHNjb3BlLnN0b3JhZ2UgJiYgISRzY29wZS5yZWFkT25seSkgPyBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgkc2NvcGUuc3RvcmFnZSkgOiBmYWxzZTtcclxuICAgICAgICBpZiAoc2Vzc2lvbikge1xyXG4gICAgICAgICAgc2Vzc2lvbiA9IGFuZ3VsYXIuZnJvbUpzb24oc2Vzc2lvbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAkc2NvcGUuZm9ybWlvID0gbnVsbDtcclxuICAgICAgICAkc2NvcGUudXJsID0gJHNjb3BlLnVybCB8fCAkc2NvcGUuc3JjO1xyXG4gICAgICAgICRzY29wZS5wYWdlID0ge307XHJcbiAgICAgICAgJHNjb3BlLnBhZ2VzID0gW107XHJcbiAgICAgICAgJHNjb3BlLmhhc1RpdGxlcyA9IGZhbHNlO1xyXG4gICAgICAgICRzY29wZS5jb2xjbGFzcyA9ICcnO1xyXG4gICAgICAgIGlmICghJHNjb3BlLnN1Ym1pc3Npb24gfHwgIU9iamVjdC5rZXlzKCRzY29wZS5zdWJtaXNzaW9uKS5sZW5ndGgpIHtcclxuICAgICAgICAgICRzY29wZS5zdWJtaXNzaW9uID0gc2Vzc2lvbiA/IHtkYXRhOiBzZXNzaW9uLmRhdGF9IDoge2RhdGE6IHt9fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgJHNjb3BlLmN1cnJlbnRQYWdlID0gc2Vzc2lvbiA/IHNlc3Npb24ucGFnZSA6IDA7XHJcbiAgICAgICAgJHNjb3BlLmZvcm1pb0FsZXJ0cyA9IFtdO1xyXG4gICAgICAgICRzY29wZS5mb3JtaW9PcHRpb25zID0gJHNjb3BlLmZvcm1pb09wdGlvbnMgfHwge307XHJcblxyXG4gICAgICAgIHZhciBnZXRGb3JtID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICB2YXIgZWxlbWVudCA9ICRlbGVtZW50LmZpbmQoJyNmb3JtaW8td2l6YXJkLWZvcm0nKTtcclxuICAgICAgICAgIGlmICghZWxlbWVudC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQuY2hpbGRyZW4oKS5zY29wZSgpLmZvcm1pb0Zvcm07XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gU2hvdyB0aGUgY3VycmVudCBwYWdlLlxyXG4gICAgICAgIHZhciBzaG93UGFnZSA9IGZ1bmN0aW9uKHNjcm9sbCkge1xyXG4gICAgICAgICAgLy8gV2hlbiBhbGxvd2luZyBuYXZpZ2F0ZSBvbiBpbnZzYWxpZFxyXG4gICAgICAgICAgLy8gcHJldiBwYWdlIGFsZXJ0IGNhbiBiZSB2aXNpYmxlLlxyXG4gICAgICAgICAgLy8gTGV0J3MgY2xlYXIgaXRcclxuICAgICAgICAgICRzY29wZS5zaG93QWxlcnRzKG51bGwpO1xyXG4gICAgICAgICAgJHNjb3BlLnBhZ2VXYXNWaXNpdGVkWyRzY29wZS5jdXJyZW50UGFnZV0gPSB0cnVlO1xyXG5cclxuICAgICAgICAgICRzY29wZS53aXphcmRMb2FkZWQgPSBmYWxzZTtcclxuICAgICAgICAgICRzY29wZS5wYWdlLmNvbXBvbmVudHMgPSBbXTtcclxuICAgICAgICAgICRzY29wZS5wYWdlLmNvbXBvbmVudHMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvLyBJZiB0aGUgcGFnZSBpcyBwYXN0IHRoZSBjb21wb25lbnRzIGxlbmd0aCwgdHJ5IHRvIGNsZWFyIGZpcnN0LlxyXG4gICAgICAgICAgICBpZiAoJHNjb3BlLmN1cnJlbnRQYWdlID49ICRzY29wZS5wYWdlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAkc2NvcGUuY2xlYXIoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCRzY29wZS5zdG9yYWdlICYmICEkc2NvcGUucmVhZE9ubHkpIHtcclxuICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgkc2NvcGUuc3RvcmFnZSwgYW5ndWxhci50b0pzb24oe1xyXG4gICAgICAgICAgICAgICAgcGFnZTogJHNjb3BlLmN1cnJlbnRQYWdlLFxyXG4gICAgICAgICAgICAgICAgZGF0YTogJHNjb3BlLnN1Ym1pc3Npb24uZGF0YVxyXG4gICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgJHNjb3BlLnBhZ2UuY29tcG9uZW50cyA9ICRzY29wZS5wYWdlc1skc2NvcGUuY3VycmVudFBhZ2VdLmNvbXBvbmVudHM7XHJcbiAgICAgICAgICAgICRzY29wZS5mb3JtaW9BbGVydHMgPSBbXTtcclxuICAgICAgICAgICAgaWYgKHNjcm9sbCkge1xyXG4gICAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAkc2NvcGUud2l6YXJkVG9wKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAkc2NvcGUud2l6YXJkTG9hZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgJHNjb3BlLiRlbWl0KCd3aXphcmRQYWdlJywgJHNjb3BlLmN1cnJlbnRQYWdlKTtcclxuICAgICAgICAgICAgJHRpbWVvdXQoJHNjb3BlLiRhcHBseS5iaW5kKCRzY29wZSkpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYgKCEkc2NvcGUuZm9ybSAmJiAkc2NvcGUuc3JjKSB7XHJcbiAgICAgICAgICAobmV3IEZvcm1pbygkc2NvcGUuc3JjKSkubG9hZEZvcm0oKS50aGVuKGZ1bmN0aW9uKGZvcm0pIHtcclxuICAgICAgICAgICAgJHNjb3BlLmZvcm0gPSBmb3JtO1xyXG4gICAgICAgICAgICBpZiAoISRzY29wZS53aXphcmRMb2FkZWQpIHtcclxuICAgICAgICAgICAgICBzaG93UGFnZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFdlIGNhbiBiZSBjb21taW5nIGJhY2sgd2l0aCB0aGUgJ3ByZXYnIGJ1dHRvbi5cclxuICAgICAgICAvLyBXYWl0IGZvciB0aGUgZm9ybSB0byBiZSBsb2FkZWQuXHJcbiAgICAgICAgLy8gVGhlbiB0aW1lb3V0IHRvIHdhaXQgdGhlIGxvYWRlZCBmb3JtIHRvIGJlIHJlbmRlcmVkXHJcbiAgICAgICAgLy8gYmVmb3JlIGNoZWNraW5nIGZvciBlcnJvcnMuXHJcbiAgICAgICAgJHNjb3BlLiRvbignZm9ybUxvYWQnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGlmICgkc2NvcGUucGFnZUhhc0Vycm9yc1skc2NvcGUuY3VycmVudFBhZ2VdKSB7XHJcbiAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICRzY29wZS5jaGVja0Vycm9ycygpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gU2hvd3MgdGhlIGdpdmVuIGFsZXJ0cyAoc2luZ2xlIG9yIGFycmF5KSwgYW5kIGRpc21pc3NlcyBvbGQgYWxlcnRzXHJcbiAgICAgICAgdGhpcy5zaG93QWxlcnRzID0gJHNjb3BlLnNob3dBbGVydHMgPSBmdW5jdGlvbihhbGVydHMpIHtcclxuICAgICAgICAgICRzY29wZS5mb3JtaW9BbGVydHMgPSBbXS5jb25jYXQoYWxlcnRzKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAkc2NvcGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGlmICgkc2NvcGUuc3RvcmFnZSAmJiAhJHNjb3BlLnJlYWRPbmx5KSB7XHJcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCRzY29wZS5zdG9yYWdlLCAnJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAkc2NvcGUuc3VibWlzc2lvbiA9IHtkYXRhOiB7fX07XHJcbiAgICAgICAgICAkc2NvcGUuY3VycmVudFBhZ2UgPSAwO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGZvciBlcnJvcnMuXHJcbiAgICAgICAgJHNjb3BlLmNoZWNrRXJyb3JzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBpZiAoISRzY29wZS5pc1ZhbGlkKCkpIHtcclxuICAgICAgICAgICAgLy8gQ2hhbmdlIGFsbCBvZiB0aGUgZmllbGRzIHRvIG5vdCBiZSBwcmlzdGluZS5cclxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKCRlbGVtZW50LmZpbmQoJ1tuYW1lPVwiZm9ybWlvRm9ybVwiXScpLmNoaWxkcmVuKCksIGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICB2YXIgZWxlbWVudFNjb3BlID0gYW5ndWxhci5lbGVtZW50KGVsZW1lbnQpLnNjb3BlKCk7XHJcbiAgICAgICAgICAgICAgdmFyIGZpZWxkRm9ybSA9IGVsZW1lbnRTY29wZS5mb3JtaW9Gb3JtO1xyXG4gICAgICAgICAgICAgIGlmIChmaWVsZEZvcm1bZWxlbWVudFNjb3BlLmNvbXBvbmVudC5rZXldKSB7XHJcbiAgICAgICAgICAgICAgICBmaWVsZEZvcm1bZWxlbWVudFNjb3BlLmNvbXBvbmVudC5rZXldLiRwcmlzdGluZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICRzY29wZS5mb3JtaW9BbGVydHMgPSBbe1xyXG4gICAgICAgICAgICAgIHR5cGU6ICdkYW5nZXInLFxyXG4gICAgICAgICAgICAgIG1lc3NhZ2U6ICdQbGVhc2UgZml4IHRoZSBmb2xsb3dpbmcgZXJyb3JzIGJlZm9yZSBwcm9jZWVkaW5nLidcclxuICAgICAgICAgICAgfV07XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIFN1Ym1pdCB0aGUgc3VibWlzc2lvbi5cclxuICAgICAgICAkc2NvcGUuc3VibWl0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBpZiAoJHNjb3BlLmNoZWNrRXJyb3JzKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFdlIHdhbnQgdG8gc3VibWl0LCBidXQgZnJlZSBuYXZpZ2F0aW9uIGlzIGVuYWJsZWQuXHJcbiAgICAgICAgICAvLyBMZXRzIGNoZWNrIGlmIHByZXZpb3VzIHBhZ2VzIHdoZXJlIG5vdCB2aXNpdGVkIG9yIGhhcyBlcnJvcnMuXHJcbiAgICAgICAgICAvLyBJZiBmaW5kIG9uZSwgc3RvcCBzZWFyY2hpbmcsIGdvIHRvIHRoYXQgcGFnZSBhbmQgZG8gbm90IGNvbnRpbnVlIHdpdGggdGhlIHN1Ym1pc3Npb24uXHJcbiAgICAgICAgICBpZiAoJHNjb3BlLmZvcm1pb09wdGlvbnMud2l6YXJkRnJlZU5hdmlnYXRpb24pIHtcclxuICAgICAgICAgICAgdmFyIGJhY2tUb1BhZ2UgPSBudWxsO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8ICRzY29wZS5wYWdlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgIGlmICgkc2NvcGUucGFnZUhhc0Vycm9yc1tpXSB8fCAhJHNjb3BlLnBhZ2VXYXNWaXNpdGVkW2ldKSB7XHJcbiAgICAgICAgICAgICAgICBiYWNrVG9QYWdlID0gaTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYmFja1RvUGFnZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiAkc2NvcGUuZ290byhiYWNrVG9QYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIENyZWF0ZSBhIHNhbml0aXplZCBzdWJtaXNzaW9uIG9iamVjdC5cclxuICAgICAgICAgIHZhciBzdWJtaXNzaW9uRGF0YSA9IHtkYXRhOiB7fX07XHJcbiAgICAgICAgICBpZiAoJHNjb3BlLnN1Ym1pc3Npb24uX2lkKSB7XHJcbiAgICAgICAgICAgIHN1Ym1pc3Npb25EYXRhLl9pZCA9ICRzY29wZS5zdWJtaXNzaW9uLl9pZDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICgkc2NvcGUuc3VibWlzc2lvbi5kYXRhLl9pZCkge1xyXG4gICAgICAgICAgICBzdWJtaXNzaW9uRGF0YS5faWQgPSAkc2NvcGUuc3VibWlzc2lvbi5kYXRhLl9pZDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB2YXIgZ3JhYklkcyA9IGZ1bmN0aW9uKGlucHV0KSB7XHJcbiAgICAgICAgICAgIGlmICghaW5wdXQpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghKGlucHV0IGluc3RhbmNlb2YgQXJyYXkpKSB7XHJcbiAgICAgICAgICAgICAgaW5wdXQgPSBbaW5wdXRdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZmluYWwgPSBbXTtcclxuICAgICAgICAgICAgaW5wdXQuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5faWQpIHtcclxuICAgICAgICAgICAgICAgIGZpbmFsLnB1c2goZWxlbWVudC5faWQpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZmluYWw7XHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIHZhciBkZWZhdWx0UGVybWlzc2lvbnMgPSB7fTtcclxuICAgICAgICAgIEZvcm1pb1V0aWxzLmVhY2hDb21wb25lbnQoJHNjb3BlLmZvcm0uY29tcG9uZW50cywgZnVuY3Rpb24oY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQudHlwZSA9PT0gJ3Jlc291cmNlJyAmJiBjb21wb25lbnQua2V5ICYmIGNvbXBvbmVudC5kZWZhdWx0UGVybWlzc2lvbikge1xyXG4gICAgICAgICAgICAgIGRlZmF1bHRQZXJtaXNzaW9uc1tjb21wb25lbnQua2V5XSA9IGNvbXBvbmVudC5kZWZhdWx0UGVybWlzc2lvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc3VibWlzc2lvbkRhdGEuZGF0YS5oYXNPd25Qcm9wZXJ0eShjb21wb25lbnQua2V5KSAmJiAoY29tcG9uZW50LnR5cGUgPT09ICdudW1iZXInKSkge1xyXG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9ICRzY29wZS5zdWJtaXNzaW9uLmRhdGFbY29tcG9uZW50LmtleV07XHJcbiAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudC50eXBlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgc3VibWlzc2lvbkRhdGEuZGF0YVtjb21wb25lbnQua2V5XSA9IHZhbHVlID8gcGFyc2VGbG9hdCh2YWx1ZSkgOiAwO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN1Ym1pc3Npb25EYXRhLmRhdGFbY29tcG9uZW50LmtleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0sIHRydWUpO1xyXG5cclxuICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaCgkc2NvcGUuc3VibWlzc2lvbi5kYXRhLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XHJcbiAgICAgICAgICAgIHN1Ym1pc3Npb25EYXRhLmRhdGFba2V5XSA9IHZhbHVlO1xyXG5cclxuICAgICAgICAgICAgLy8gU2V0dXAgdGhlIHN1Ym1pc3Npb24gYWNjZXNzLlxyXG4gICAgICAgICAgICB2YXIgcGVybSA9IGRlZmF1bHRQZXJtaXNzaW9uc1trZXldO1xyXG4gICAgICAgICAgICBpZiAocGVybSkge1xyXG4gICAgICAgICAgICAgIHN1Ym1pc3Npb25EYXRhLmFjY2VzcyA9IHN1Ym1pc3Npb25EYXRhLmFjY2VzcyB8fCBbXTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQ29lcmNlIHZhbHVlIGludG8gYW4gYXJyYXkgZm9yIHBsdWNraW5nLlxyXG4gICAgICAgICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV07XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAvLyBUcnkgdG8gZmluZCBhbmQgdXBkYXRlIGFuIGV4aXN0aW5nIHBlcm1pc3Npb24uXHJcbiAgICAgICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgc3VibWlzc2lvbkRhdGEuYWNjZXNzLmZvckVhY2goZnVuY3Rpb24ocGVybWlzc2lvbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBlcm1pc3Npb24udHlwZSA9PT0gcGVybSkge1xyXG4gICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgIHBlcm1pc3Npb24ucmVzb3VyY2VzID0gcGVybWlzc2lvbi5yZXNvdXJjZXMgfHwgW107XHJcbiAgICAgICAgICAgICAgICAgIHBlcm1pc3Npb24ucmVzb3VyY2VzLmNvbmNhdChncmFiSWRzKHZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEFkZCBhIHBlcm1pc3Npb24sIGJlY2F1c2Ugb25lIHdhcyBub3QgZm91bmQuXHJcbiAgICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgc3VibWlzc2lvbkRhdGEuYWNjZXNzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICB0eXBlOiBwZXJtLFxyXG4gICAgICAgICAgICAgICAgICByZXNvdXJjZXM6IGdyYWJJZHModmFsdWUpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgLy8gU3RyaXAgb3V0IGFueSBhbmd1bGFyIGtleXMuXHJcbiAgICAgICAgICBzdWJtaXNzaW9uRGF0YSA9IGFuZ3VsYXIuY29weShzdWJtaXNzaW9uRGF0YSk7XHJcblxyXG4gICAgICAgICAgdmFyIHN1Ym1pdEV2ZW50ID0gJHNjb3BlLiRlbWl0KCdmb3JtU3VibWl0Jywgc3VibWlzc2lvbkRhdGEpO1xyXG4gICAgICAgICAgaWYgKHN1Ym1pdEV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgICAgICAgICAvLyBMaXN0ZW5lciB3YW50cyB0byBjYW5jZWwgdGhlIGZvcm0gc3VibWlzc2lvblxyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB2YXIgb25Eb25lID0gZnVuY3Rpb24oc3VibWlzc2lvbikge1xyXG4gICAgICAgICAgICBpZiAoJHNjb3BlLnN0b3JhZ2UgJiYgISRzY29wZS5yZWFkT25seSkge1xyXG4gICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCRzY29wZS5zdG9yYWdlLCAnJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgJHNjb3BlLnNob3dBbGVydHMoe1xyXG4gICAgICAgICAgICAgIHR5cGU6ICdzdWNjZXNzJyxcclxuICAgICAgICAgICAgICBtZXNzYWdlOiAnU3VibWlzc2lvbiBDb21wbGV0ZSEnXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAkc2NvcGUuJGVtaXQoJ2Zvcm1TdWJtaXNzaW9uJywgc3VibWlzc2lvbik7XHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIC8vIFNhdmUgdG8gc3BlY2lmaWVkIGFjdGlvbi5cclxuICAgICAgICAgIGlmICgkc2NvcGUuYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBzdWJtaXNzaW9uRGF0YS5faWQgPyAncHV0JyA6ICdwb3N0JztcclxuICAgICAgICAgICAgJGh0dHBbbWV0aG9kXSgkc2NvcGUuYWN0aW9uLCBzdWJtaXNzaW9uRGF0YSkudGhlbihmdW5jdGlvbihzdWJtaXNzaW9uKSB7XHJcbiAgICAgICAgICAgICAgRm9ybWlvLmNsZWFyQ2FjaGUoKTtcclxuICAgICAgICAgICAgICBvbkRvbmUoc3VibWlzc2lvbik7XHJcbiAgICAgICAgICAgIH0sIEZvcm1pb1Njb3BlLm9uRXJyb3IoJHNjb3BlLCAkZWxlbWVudCkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSBpZiAoJHNjb3BlLmZvcm1pbyAmJiAhJHNjb3BlLmZvcm1pby5ub1N1Ym1pdCkge1xyXG4gICAgICAgICAgICAkc2NvcGUuZm9ybWlvLnNhdmVTdWJtaXNzaW9uKHN1Ym1pc3Npb25EYXRhKS50aGVuKG9uRG9uZSkuY2F0Y2goRm9ybWlvU2NvcGUub25FcnJvcigkc2NvcGUsICRlbGVtZW50KSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb25Eb25lKHN1Ym1pc3Npb25EYXRhKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAkc2NvcGUuY2FuY2VsID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAkc2NvcGUuY2xlYXIoKTtcclxuICAgICAgICAgIHNob3dQYWdlKHRydWUpO1xyXG4gICAgICAgICAgJHNjb3BlLiRlbWl0KCdjYW5jZWwnKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAkc2NvcGUucGFnZUhhc0Vycm9ycyA9IHt9O1xyXG4gICAgICAgICRzY29wZS5wYWdlV2FzVmlzaXRlZCA9IHt9O1xyXG5cclxuICAgICAgICAvLyBNb3ZlIG9udG8gdGhlIG5leHQgcGFnZS5cclxuICAgICAgICAkc2NvcGUubmV4dCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgdmFyIGVycm9ycyA9ICRzY29wZS5jaGVja0Vycm9ycygpO1xyXG4gICAgICAgICAgaWYgKGVycm9ycykge1xyXG4gICAgICAgICAgICAkc2NvcGUucGFnZUhhc0Vycm9yc1skc2NvcGUuY3VycmVudFBhZ2VdID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKCEkc2NvcGUuZm9ybWlvT3B0aW9ucy53aXphcmRGcmVlTmF2aWdhdGlvbikge1xyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICRzY29wZS5wYWdlSGFzRXJyb3JzWyRzY29wZS5jdXJyZW50UGFnZV0gPSBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICgkc2NvcGUuY3VycmVudFBhZ2UgPj0gKCRzY29wZS5wYWdlcy5sZW5ndGggLSAxKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAkc2NvcGUuY3VycmVudFBhZ2UrKztcclxuICAgICAgICAgIHNob3dQYWdlKHRydWUpO1xyXG4gICAgICAgICAgJHNjb3BlLiRlbWl0KCd3aXphcmROZXh0JywgJHNjb3BlLmN1cnJlbnRQYWdlKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBNb3ZlIG9udG8gdGhlIHByZXZpb3VzIHBhZ2UuXHJcbiAgICAgICAgJHNjb3BlLnByZXYgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGlmICgkc2NvcGUuY3VycmVudFBhZ2UgPCAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgICRzY29wZS5jdXJyZW50UGFnZS0tO1xyXG4gICAgICAgICAgc2hvd1BhZ2UodHJ1ZSk7XHJcbiAgICAgICAgICAkc2NvcGUuJGVtaXQoJ3dpemFyZFByZXYnLCAkc2NvcGUuY3VycmVudFBhZ2UpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgICRzY29wZS5nb3RvID0gZnVuY3Rpb24ocGFnZSkge1xyXG4gICAgICAgICAgaWYgKHBhZ2UgPCAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChwYWdlID49ICRzY29wZS5wYWdlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdmFyIGVycm9ycyA9ICRzY29wZS5jaGVja0Vycm9ycygpO1xyXG4gICAgICAgICAgJHNjb3BlLnBhZ2VIYXNFcnJvcnNbJHNjb3BlLmN1cnJlbnRQYWdlXSA9IGVycm9ycztcclxuICAgICAgICAgICRzY29wZS5jdXJyZW50UGFnZSA9IHBhZ2U7XHJcbiAgICAgICAgICBzaG93UGFnZSh0cnVlKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAkc2NvcGUuaXNWYWxpZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgcmV0dXJuIGdldEZvcm0oKS4kdmFsaWQ7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgJHNjb3BlLiRvbignd2l6YXJkR29Ub1BhZ2UnLCBmdW5jdGlvbihldmVudCwgcGFnZSkge1xyXG4gICAgICAgICAgJHNjb3BlLmdvdG8ocGFnZSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHZhciB1cGRhdGVQYWdlcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgaWYgKCRzY29wZS5wYWdlcy5sZW5ndGggPiA2KSB7XHJcbiAgICAgICAgICAgICRzY29wZS5tYXJnaW4gPSAoKDEgLSAoJHNjb3BlLnBhZ2VzLmxlbmd0aCAqIDAuMDgzMzMzMzMzMykpIC8gMikgKiAxMDA7XHJcbiAgICAgICAgICAgICRzY29wZS5jb2xjbGFzcyA9ICdjb2wtc20tMSc7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgJHNjb3BlLm1hcmdpbiA9ICgoMSAtICgkc2NvcGUucGFnZXMubGVuZ3RoICogMC4xNjY2NjY2NjY3KSkgLyAyKSAqIDEwMDtcclxuICAgICAgICAgICAgJHNjb3BlLmNvbGNsYXNzID0gJ2NvbC1zbS0yJztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB2YXIgYWxsUGFnZXMgPSBbXTtcclxuICAgICAgICB2YXIgaGFzQ29uZGl0aW9uYWxQYWdlcyA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBzZXRGb3JtID0gZnVuY3Rpb24oZm9ybSkge1xyXG4gICAgICAgICAgJHNjb3BlLnBhZ2VzID0gW107XHJcbiAgICAgICAgICBhbmd1bGFyLmZvckVhY2goZm9ybS5jb21wb25lbnRzLCBmdW5jdGlvbihjb21wb25lbnQpIHtcclxuICAgICAgICAgICAgLy8gT25seSBpbmNsdWRlIHBhbmVscyBmb3IgdGhlIHBhZ2VzLlxyXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50LnR5cGUgPT09ICdwYW5lbCcpIHtcclxuICAgICAgICAgICAgICBpZiAoISRzY29wZS5oYXNUaXRsZXMgJiYgY29tcG9uZW50LnRpdGxlKSB7XHJcbiAgICAgICAgICAgICAgICAkc2NvcGUuaGFzVGl0bGVzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5jdXN0b21Db25kaXRpb25hbCkge1xyXG4gICAgICAgICAgICAgICAgaGFzQ29uZGl0aW9uYWxQYWdlcyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGVsc2UgaWYgKGNvbXBvbmVudC5jb25kaXRpb25hbCAmJiBjb21wb25lbnQuY29uZGl0aW9uYWwud2hlbikge1xyXG4gICAgICAgICAgICAgICAgaGFzQ29uZGl0aW9uYWxQYWdlcyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGlzIHBhZ2UgaXMgbm90IGluIHRoZSBoaWRlIGNvbXBvZW5lbnRzIGFycmF5LlxyXG4gICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICgkc2NvcGUuaGlkZUNvbXBvbmVudHMpICYmXHJcbiAgICAgICAgICAgICAgICAoY29tcG9uZW50LmtleSkgJiZcclxuICAgICAgICAgICAgICAgICgkc2NvcGUuaGlkZUNvbXBvbmVudHMuaW5kZXhPZihjb21wb25lbnQua2V5KSAhPT0gLTEpXHJcbiAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGFsbFBhZ2VzLnB1c2goY29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAkc2NvcGUucGFnZXMucHVzaChjb21wb25lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAvLyBGT1ItNzFcclxuICAgICAgICAgIGlmICghJHNjb3BlLmJ1aWxkZXIgJiYgaGFzQ29uZGl0aW9uYWxQYWdlcykge1xyXG4gICAgICAgICAgICAkc2NvcGUuJHdhdGNoKCdzdWJtaXNzaW9uLmRhdGEnLCBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgICAgICAgICAgdmFyIG5ld1BhZ2VzID0gW107XHJcbiAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGFsbFBhZ2VzLCBmdW5jdGlvbihwYWdlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoRm9ybWlvVXRpbHMuaXNWaXNpYmxlKHBhZ2UsIG51bGwsIGRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICAgIG5ld1BhZ2VzLnB1c2gocGFnZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgJHNjb3BlLnBhZ2VzID0gbmV3UGFnZXM7XHJcbiAgICAgICAgICAgICAgdXBkYXRlUGFnZXMoKTtcclxuICAgICAgICAgICAgICBzZXRUaW1lb3V0KCRzY29wZS4kYXBwbHkuYmluZCgkc2NvcGUpLCAxMCk7XHJcbiAgICAgICAgICAgIH0sIHRydWUpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICRzY29wZS5mb3JtID0gJHNjb3BlLmZvcm0gPyBhbmd1bGFyLm1lcmdlKCRzY29wZS5mb3JtLCBhbmd1bGFyLmNvcHkoZm9ybSkpIDogYW5ndWxhci5jb3B5KGZvcm0pO1xyXG4gICAgICAgICAgJHNjb3BlLnBhZ2UgPSBhbmd1bGFyLmNvcHkoZm9ybSk7XHJcbiAgICAgICAgICAkc2NvcGUucGFnZS5kaXNwbGF5ID0gJ2Zvcm0nO1xyXG4gICAgICAgICAgJHNjb3BlLiRlbWl0KCd3aXphcmRGb3JtTG9hZCcsIGZvcm0pO1xyXG4gICAgICAgICAgdXBkYXRlUGFnZXMoKTtcclxuICAgICAgICAgIHNob3dQYWdlKCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gRk9SLTcxXHJcbiAgICAgICAgaWYgKCEkc2NvcGUuYnVpbGRlcikge1xyXG4gICAgICAgICAgJHNjb3BlLiR3YXRjaCgnZm9ybScsIGZ1bmN0aW9uKGZvcm0pIHtcclxuICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICRzY29wZS5zcmMgfHxcclxuICAgICAgICAgICAgICAhZm9ybSB8fFxyXG4gICAgICAgICAgICAgICFPYmplY3Qua2V5cyhmb3JtKS5sZW5ndGggfHxcclxuICAgICAgICAgICAgICAhZm9ybS5jb21wb25lbnRzIHx8XHJcbiAgICAgICAgICAgICAgIWZvcm0uY29tcG9uZW50cy5sZW5ndGhcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBmb3JtVXJsID0gZm9ybS5wcm9qZWN0ID8gJy9wcm9qZWN0LycgKyBmb3JtLnByb2plY3QgOiAnJztcclxuICAgICAgICAgICAgZm9ybVVybCArPSAnL2Zvcm0vJyArIGZvcm0uX2lkO1xyXG4gICAgICAgICAgICAkc2NvcGUuZm9ybWlvID0gbmV3IEZvcm1pbyhmb3JtVXJsKTtcclxuICAgICAgICAgICAgc2V0Rm9ybShmb3JtKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gV2hlbiB0aGUgY29tcG9uZW50cyBsZW5ndGggY2hhbmdlcyB1cGRhdGUgdGhlIHBhZ2VzLlxyXG4gICAgICAgICRzY29wZS4kd2F0Y2goJ2Zvcm0uY29tcG9uZW50cy5sZW5ndGgnLCB1cGRhdGVQYWdlcyk7XHJcblxyXG4gICAgICAgIC8vIExvYWQgdGhlIGZvcm0uXHJcbiAgICAgICAgaWYgKCRzY29wZS5zcmMpIHtcclxuICAgICAgICAgICRzY29wZS5mb3JtaW8gPSBuZXcgRm9ybWlvKCRzY29wZS5zcmMpO1xyXG4gICAgICAgICAgJHNjb3BlLmZvcm1pby5sb2FkRm9ybSgpLnRoZW4oZnVuY3Rpb24oZm9ybSkge1xyXG4gICAgICAgICAgICBzZXRGb3JtKGZvcm0pO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgJHNjb3BlLnNyYyA9ICcnO1xyXG4gICAgICAgICAgJHNjb3BlLmZvcm1pbyA9IG5ldyBGb3JtaW8oJHNjb3BlLnNyYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICBdXHJcbiAgfTtcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFtcclxuICAnRm9ybWlvJyxcclxuICAnZm9ybWlvQ29tcG9uZW50cycsXHJcbiAgJyR0aW1lb3V0JyxcclxuICBmdW5jdGlvbihcclxuICAgIEZvcm1pbyxcclxuICAgIGZvcm1pb0NvbXBvbmVudHMsXHJcbiAgICAkdGltZW91dFxyXG4gICkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgb25FcnJvcjogZnVuY3Rpb24oJHNjb3BlLCAkZWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihlcnJvcikge1xyXG4gICAgICAgICAgaWYgKChlcnJvci5uYW1lID09PSAnVmFsaWRhdGlvbkVycm9yJykgJiYgJGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgJGVsZW1lbnQuZmluZCgnI2Zvcm0tZ3JvdXAtJyArIGVycm9yLmRldGFpbHNbMF0ucGF0aCkuYWRkQ2xhc3MoJ2hhcy1lcnJvcicpO1xyXG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9ICdWYWxpZGF0aW9uRXJyb3I6ICcgKyBlcnJvci5kZXRhaWxzWzBdLm1lc3NhZ2U7XHJcbiAgICAgICAgICAgICRzY29wZS5zaG93QWxlcnRzKHtcclxuICAgICAgICAgICAgICB0eXBlOiAnZGFuZ2VyJyxcclxuICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgZXJyb3IgPSBlcnJvci50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICBlcnJvciA9IEpTT04uc3RyaW5naWZ5KGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAkc2NvcGUuc2hvd0FsZXJ0cyh7XHJcbiAgICAgICAgICAgICAgdHlwZTogJ2RhbmdlcicsXHJcbiAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAkc2NvcGUuJGVtaXQoJ2Zvcm1FcnJvcicsIGVycm9yKTtcclxuICAgICAgICB9O1xyXG4gICAgICB9LFxyXG4gICAgICByZWdpc3RlcjogZnVuY3Rpb24oJHNjb3BlLCAkZWxlbWVudCwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBsb2FkZXIgPSBudWxsO1xyXG4gICAgICAgICRzY29wZS5mb3JtTG9hZGluZyA9IHRydWU7XHJcbiAgICAgICAgJHNjb3BlLmZvcm0gPSBhbmd1bGFyLmlzRGVmaW5lZCgkc2NvcGUuZm9ybSkgPyAkc2NvcGUuZm9ybSA6IHt9O1xyXG4gICAgICAgICRzY29wZS5zdWJtaXNzaW9uID0gYW5ndWxhci5pc0RlZmluZWQoJHNjb3BlLnN1Ym1pc3Npb24pID8gJHNjb3BlLnN1Ym1pc3Npb24gOiB7ZGF0YToge319O1xyXG4gICAgICAgICRzY29wZS5zdWJtaXNzaW9ucyA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRzY29wZS5zdWJtaXNzaW9ucykgPyAkc2NvcGUuc3VibWlzc2lvbnMgOiBbXTtcclxuXHJcbiAgICAgICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgZWxlbWVudHMgcmVuZGVyZWQuXHJcbiAgICAgICAgdmFyIGVsZW1lbnRzUmVuZGVyZWQgPSAwO1xyXG4gICAgICAgICRzY29wZS4kb24oJ2Zvcm1FbGVtZW50UmVuZGVyJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBlbGVtZW50c1JlbmRlcmVkKys7XHJcbiAgICAgICAgICBpZiAoZWxlbWVudHNSZW5kZXJlZCA9PT0gJHNjb3BlLmZvcm0uY29tcG9uZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgJHNjb3BlLiRlbWl0KCdmb3JtUmVuZGVyJywgJHNjb3BlLmZvcm0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgJHNjb3BlLnNldExvYWRpbmcgPSBmdW5jdGlvbihfbG9hZGluZykge1xyXG4gICAgICAgICAgJHNjb3BlLmZvcm1Mb2FkaW5nID0gX2xvYWRpbmc7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gVXNlZCB0byBzZXQgdGhlIGZvcm0gYWN0aW9uLlxyXG4gICAgICAgIHZhciBnZXRBY3Rpb24gPSBmdW5jdGlvbihhY3Rpb24pIHtcclxuICAgICAgICAgIGlmICghYWN0aW9uKSByZXR1cm4gJyc7XHJcbiAgICAgICAgICBpZiAoYWN0aW9uLnN1YnN0cigwLCAxKSA9PT0gJy8nKSB7XHJcbiAgICAgICAgICAgIGFjdGlvbiA9IEZvcm1pby5nZXRCYXNlVXJsKCkgKyBhY3Rpb247XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gYWN0aW9uO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIFNldCB0aGUgYWN0aW9uLlxyXG4gICAgICAgICRzY29wZS5hY3Rpb24gPSBnZXRBY3Rpb24oJHNjb3BlLmZvcm1BY3Rpb24pO1xyXG5cclxuICAgICAgICAvLyBBbGxvdyBzdWIgY29tcG9uZW50cyB0aGUgYWJpbGl0eSB0byBhZGQgbmV3IGZvcm0gY29tcG9uZW50cyB0byB0aGUgZm9ybS5cclxuICAgICAgICB2YXIgYWRkZWREYXRhID0ge307XHJcbiAgICAgICAgJHNjb3BlLiRvbignYWRkRm9ybUNvbXBvbmVudCcsIGZ1bmN0aW9uKGV2ZW50LCBjb21wb25lbnQpIHtcclxuICAgICAgICAgIGlmICghYWRkZWREYXRhLmhhc093blByb3BlcnR5KGNvbXBvbmVudC5zZXR0aW5ncy5rZXkpKSB7XHJcbiAgICAgICAgICAgIGFkZGVkRGF0YVtjb21wb25lbnQuc2V0dGluZ3Mua2V5XSA9IHRydWU7XHJcbiAgICAgICAgICAgIHZhciBkZWZhdWx0Q29tcG9uZW50ID0gZm9ybWlvQ29tcG9uZW50cy5jb21wb25lbnRzW2NvbXBvbmVudC50eXBlXTtcclxuICAgICAgICAgICAgJHNjb3BlLmZvcm0uY29tcG9uZW50cy5wdXNoKGFuZ3VsYXIuZXh0ZW5kKGRlZmF1bHRDb21wb25lbnQuc2V0dGluZ3MsIGNvbXBvbmVudC5zZXR0aW5ncykpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBTZXQgdGhlIGFjdGlvbiBpZiB0aGV5IHByb3ZpZGVkIGl0IGluIHRoZSBmb3JtLlxyXG4gICAgICAgICRzY29wZS4kd2F0Y2goJ2Zvcm0uYWN0aW9uJywgZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgIGlmICghdmFsdWUpIHJldHVybjtcclxuICAgICAgICAgIHZhciBhY3Rpb24gPSBnZXRBY3Rpb24odmFsdWUpO1xyXG4gICAgICAgICAgaWYgKGFjdGlvbikge1xyXG4gICAgICAgICAgICAkc2NvcGUuYWN0aW9uID0gYWN0aW9uO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBUcmlnZ2VyIGEgZm9ybSBsb2FkIGV2ZW50IHdoZW4gdGhlIGNvbXBvbmVudHMgbGVuZ3RoIGlzIG1vcmUgdGhhbiAwLlxyXG4gICAgICAgICRzY29wZS4kd2F0Y2goJ2Zvcm0uY29tcG9uZW50cy5sZW5ndGgnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgISRzY29wZS5mb3JtIHx8XHJcbiAgICAgICAgICAgICEkc2NvcGUuZm9ybS5jb21wb25lbnRzIHx8XHJcbiAgICAgICAgICAgICEkc2NvcGUuZm9ybS5jb21wb25lbnRzLmxlbmd0aFxyXG4gICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgICRzY29wZS5zZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICAgICRzY29wZS4kZW1pdCgnZm9ybUxvYWQnLCAkc2NvcGUuZm9ybSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICRzY29wZS51cGRhdGVTdWJtaXNzaW9ucyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgJHNjb3BlLnNldExvYWRpbmcodHJ1ZSk7XHJcbiAgICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgICBpZiAoJHNjb3BlLnBlclBhZ2UpIHBhcmFtcy5saW1pdCA9ICRzY29wZS5wZXJQYWdlO1xyXG4gICAgICAgICAgaWYgKCRzY29wZS5za2lwKSBwYXJhbXMuc2tpcCA9ICRzY29wZS5za2lwO1xyXG4gICAgICAgICAgbG9hZGVyLmxvYWRTdWJtaXNzaW9ucyh7cGFyYW1zOiBwYXJhbXN9KS50aGVuKGZ1bmN0aW9uKHN1Ym1pc3Npb25zKSB7XHJcbiAgICAgICAgICAgIGFuZ3VsYXIubWVyZ2UoJHNjb3BlLnN1Ym1pc3Npb25zLCBhbmd1bGFyLmNvcHkoc3VibWlzc2lvbnMpKTtcclxuICAgICAgICAgICAgJHNjb3BlLnNldExvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICAkc2NvcGUuJGVtaXQoJ3N1Ym1pc3Npb25zTG9hZCcsIHN1Ym1pc3Npb25zKTtcclxuICAgICAgICAgIH0sIHRoaXMub25FcnJvcigkc2NvcGUpKTtcclxuICAgICAgICB9LmJpbmQodGhpcyk7XHJcblxyXG4gICAgICAgIGlmICgkc2NvcGUuX3NyYykge1xyXG4gICAgICAgICAgbG9hZGVyID0gbmV3IEZvcm1pbygkc2NvcGUuX3NyYyk7XHJcbiAgICAgICAgICBpZiAob3B0aW9ucy5mb3JtKSB7XHJcbiAgICAgICAgICAgICRzY29wZS5zZXRMb2FkaW5nKHRydWUpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgYSBmb3JtIGlzIGFscmVhZHkgcHJvdmlkZWQsIHRoZW4gc2tpcCB0aGUgbG9hZC5cclxuICAgICAgICAgICAgaWYgKCRzY29wZS5mb3JtICYmIE9iamVjdC5rZXlzKCRzY29wZS5mb3JtKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAkc2NvcGUuc2V0TG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgICAgJHNjb3BlLiRlbWl0KCdmb3JtTG9hZCcsICRzY29wZS5mb3JtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICBsb2FkZXIubG9hZEZvcm0oKS50aGVuKGZ1bmN0aW9uKGZvcm0pIHtcclxuICAgICAgICAgICAgICAgIGFuZ3VsYXIubWVyZ2UoJHNjb3BlLmZvcm0sIGFuZ3VsYXIuY29weShmb3JtKSk7XHJcbiAgICAgICAgICAgICAgICAkc2NvcGUuc2V0TG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAkc2NvcGUuJGVtaXQoJ2Zvcm1Mb2FkJywgJHNjb3BlLmZvcm0pO1xyXG4gICAgICAgICAgICAgIH0sIHRoaXMub25FcnJvcigkc2NvcGUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKG9wdGlvbnMuc3VibWlzc2lvbiAmJiBsb2FkZXIuc3VibWlzc2lvbklkKSB7XHJcbiAgICAgICAgICAgICRzY29wZS5zZXRMb2FkaW5nKHRydWUpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgYSBzdWJtaXNzaW9uIGlzIGFscmVhZHkgcHJvdmlkZWQsIHRoZW4gc2tpcCB0aGUgbG9hZC5cclxuICAgICAgICAgICAgaWYgKCRzY29wZS5zdWJtaXNzaW9uICYmIE9iamVjdC5rZXlzKCRzY29wZS5zdWJtaXNzaW9uLmRhdGEpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICRzY29wZS5zZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgICAkc2NvcGUuJGVtaXQoJ3N1Ym1pc3Npb25Mb2FkJywgJHNjb3BlLnN1Ym1pc3Npb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgIGxvYWRlci5sb2FkU3VibWlzc2lvbigpLnRoZW4oZnVuY3Rpb24oc3VibWlzc2lvbikge1xyXG4gICAgICAgICAgICAgICAgYW5ndWxhci5tZXJnZSgkc2NvcGUuc3VibWlzc2lvbiwgYW5ndWxhci5jb3B5KHN1Ym1pc3Npb24pKTtcclxuICAgICAgICAgICAgICAgICRzY29wZS5zZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICRzY29wZS4kZW1pdCgnc3VibWlzc2lvbkxvYWQnLCBzdWJtaXNzaW9uKTtcclxuICAgICAgICAgICAgICB9LCB0aGlzLm9uRXJyb3IoJHNjb3BlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChvcHRpb25zLnN1Ym1pc3Npb25zKSB7XHJcbiAgICAgICAgICAgICRzY29wZS51cGRhdGVTdWJtaXNzaW9ucygpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIC8vIElmIHRoZXkgcHJvdmlkZSBhIHVybCB0byB0aGUgZm9ybSwgd2Ugc3RpbGwgbmVlZCB0byBjcmVhdGUgaXQgYnV0IHRlbGwgaXQgdG8gbm90IHN1Ym1pdC5cclxuICAgICAgICAgIGlmICgkc2NvcGUudXJsKSB7XHJcbiAgICAgICAgICAgIGxvYWRlciA9IG5ldyBGb3JtaW8oJHNjb3BlLnVybCk7XHJcbiAgICAgICAgICAgIGxvYWRlci5ub1N1Ym1pdCA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgJHNjb3BlLmZvcm1vTG9hZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICRzY29wZS5mb3JtTG9hZGluZyA9ICEkc2NvcGUuZm9ybSB8fCAoT2JqZWN0LmtleXMoJHNjb3BlLmZvcm0pLmxlbmd0aCA9PT0gMCkgfHwgISRzY29wZS5mb3JtLmNvbXBvbmVudHMubGVuZ3RoO1xyXG4gICAgICAgICAgJHNjb3BlLnNldExvYWRpbmcoJHNjb3BlLmZvcm1Mb2FkaW5nKTtcclxuXHJcbiAgICAgICAgICAvLyBFbWl0IHRoZSBldmVudHMgaWYgdGhlc2Ugb2JqZWN0cyBhcmUgYWxyZWFkeSBsb2FkZWQuXHJcbiAgICAgICAgICBpZiAoISRzY29wZS5mb3JtTG9hZGluZykge1xyXG4gICAgICAgICAgICAkc2NvcGUuJGVtaXQoJ2Zvcm1Mb2FkJywgJHNjb3BlLmZvcm0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCRzY29wZS5zdWJtaXNzaW9uKSB7XHJcbiAgICAgICAgICAgICRzY29wZS4kZW1pdCgnc3VibWlzc2lvbkxvYWQnLCAkc2NvcGUuc3VibWlzc2lvbik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoJHNjb3BlLnN1Ym1pc3Npb25zKSB7XHJcbiAgICAgICAgICAgICRzY29wZS4kZW1pdCgnc3VibWlzc2lvbnNMb2FkJywgJHNjb3BlLnN1Ym1pc3Npb25zKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJldHVybiB0aGUgbG9hZGVyLlxyXG4gICAgICAgIHJldHVybiBsb2FkZXI7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG5dO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBmb3JtaW9VdGlscyA9IHJlcXVpcmUoJ2Zvcm1pb2pzL3V0aWxzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICBjaGVja1Zpc2libGU6IGZ1bmN0aW9uKGNvbXBvbmVudCwgcm93LCBkYXRhKSB7XHJcbiAgICAgIHZhciB2aXNpYmxlID0gZm9ybWlvVXRpbHMuY2hlY2tDb25kaXRpb24oY29tcG9uZW50LCByb3csIGRhdGEpO1xyXG4gICAgICBpZiAoIXZpc2libGUpIHtcclxuICAgICAgICBpZiAoIWNvbXBvbmVudC5oYXNPd25Qcm9wZXJ0eSgnY2xlYXJPbkhpZGUnKSB8fCBjb21wb25lbnQuY2xlYXJPbkhpZGUudG9TdHJpbmcoKSA9PT0gJ3RydWUnKSB7XHJcbiAgICAgICAgICBpZiAocm93ICYmIHJvdy5oYXNPd25Qcm9wZXJ0eShjb21wb25lbnQua2V5KSkge1xyXG4gICAgICAgICAgICBkZWxldGUgcm93W2NvbXBvbmVudC5rZXldO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5oYXNPd25Qcm9wZXJ0eShjb21wb25lbnQua2V5KSkge1xyXG4gICAgICAgICAgICBkZWxldGUgZGF0YVtjb21wb25lbnQua2V5XTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSxcclxuICAgIGlzVmlzaWJsZTogZnVuY3Rpb24oY29tcG9uZW50LCByb3csIGRhdGEsIGhpZGUpIHtcclxuICAgICAgLy8gSWYgdGhlIGNvbXBvbmVudCBpcyBpbiB0aGUgaGlkZUNvbXBvbmVudHMgYXJyYXksIHRoZW4gaGlkZSBpdCBieSBkZWZhdWx0LlxyXG4gICAgICBpZiAoaGlkZSAmJiBBcnJheS5pc0FycmF5KGhpZGUpICYmIChoaWRlLmluZGV4T2YoY29tcG9uZW50LmtleSkgIT09IC0xKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuY2hlY2tWaXNpYmxlKGNvbXBvbmVudCwgcm93LCBkYXRhKTtcclxuICAgIH0sXHJcbiAgICBmbGF0dGVuQ29tcG9uZW50czogZm9ybWlvVXRpbHMuZmxhdHRlbkNvbXBvbmVudHMsXHJcbiAgICBlYWNoQ29tcG9uZW50OiBmb3JtaW9VdGlscy5lYWNoQ29tcG9uZW50LFxyXG4gICAgZ2V0Q29tcG9uZW50OiBmb3JtaW9VdGlscy5nZXRDb21wb25lbnQsXHJcbiAgICBnZXRWYWx1ZTogZm9ybWlvVXRpbHMuZ2V0VmFsdWUsXHJcbiAgICBoaWRlRmllbGRzOiBmdW5jdGlvbihmb3JtLCBjb21wb25lbnRzKSB7XHJcbiAgICAgIHRoaXMuZWFjaENvbXBvbmVudChmb3JtLmNvbXBvbmVudHMsIGZ1bmN0aW9uKGNvbXBvbmVudCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgaW4gY29tcG9uZW50cykge1xyXG4gICAgICAgICAgaWYgKGNvbXBvbmVudC5rZXkgPT09IGNvbXBvbmVudHNbaV0pIHtcclxuICAgICAgICAgICAgY29tcG9uZW50LnR5cGUgPSAnaGlkZGVuJztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIHVuaXF1ZU5hbWU6IGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgdmFyIHBhcnRzID0gbmFtZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1teMC05YS16XFwuXS9nLCAnJykuc3BsaXQoJy4nKTtcclxuICAgICAgdmFyIGZpbGVOYW1lID0gcGFydHNbMF07XHJcbiAgICAgIHZhciBleHQgPSAnJztcclxuICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICBleHQgPSAnLicgKyBwYXJ0c1socGFydHMubGVuZ3RoIC0gMSldO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmaWxlTmFtZS5zdWJzdHIoMCwgMTApICsgJy0nICsgdGhpcy5ndWlkKCkgKyBleHQ7XHJcbiAgICB9LFxyXG4gICAgZ3VpZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uKGMpIHtcclxuICAgICAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkqMTZ8MCwgdiA9IGMgPT09ICd4JyA/IHIgOiAociYweDN8MHg4KTtcclxuICAgICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIGZpZWxkV3JhcDogZnVuY3Rpb24oaW5wdXQpIHtcclxuICAgICAgdmFyIG11bHRpSW5wdXQgPSBpbnB1dC5yZXBsYWNlKCdkYXRhW2NvbXBvbmVudC5rZXldJywgJ2RhdGFbY29tcG9uZW50LmtleV1bJGluZGV4XScpO1xyXG4gICAgICB2YXIgaW5wdXRMYWJlbCA9ICc8bGFiZWwgbmctaWY9XCJjb21wb25lbnQubGFiZWwgJiYgIWNvbXBvbmVudC5oaWRlTGFiZWxcIiBmb3I9XCJ7eyBjb21wb25lbnQua2V5IH19XCIgY2xhc3M9XCJjb250cm9sLWxhYmVsXCIgbmctY2xhc3M9XCJ7XFwnZmllbGQtcmVxdWlyZWRcXCc6IGlzUmVxdWlyZWQoY29tcG9uZW50KX1cIj57eyBjb21wb25lbnQubGFiZWwgfCBmb3JtaW9UcmFuc2xhdGU6bnVsbDpidWlsZGVyIH19PC9sYWJlbD4nO1xyXG4gICAgICB2YXIgcmVxdWlyZWRJbmxpbmUgPSAnPHNwYW4gbmctaWY9XCIoY29tcG9uZW50LmhpZGVMYWJlbCA9PT0gdHJ1ZSB8fCBjb21wb25lbnQubGFiZWwgPT09IFxcJ1xcJyB8fCAhY29tcG9uZW50LmxhYmVsKSAmJiBpc1JlcXVpcmVkKGNvbXBvbmVudClcIiBjbGFzcz1cImdseXBoaWNvbiBnbHlwaGljb24tYXN0ZXJpc2sgZm9ybS1jb250cm9sLWZlZWRiYWNrIGZpZWxkLXJlcXVpcmVkLWlubGluZVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvc3Bhbj4nO1xyXG4gICAgICB2YXIgdGVtcGxhdGUgPVxyXG4gICAgICAgICc8ZGl2IG5nLWlmPVwiIWNvbXBvbmVudC5tdWx0aXBsZVwiPicgK1xyXG4gICAgICAgICAgaW5wdXRMYWJlbCArXHJcbiAgICAgICAgICAnPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwXCI+JyArXHJcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXAtYWRkb25cIiBuZy1pZj1cIiEhY29tcG9uZW50LnByZWZpeFwiPnt7IGNvbXBvbmVudC5wcmVmaXggfX08L2Rpdj4nICtcclxuICAgICAgICAgICAgaW5wdXQgK1xyXG4gICAgICAgICAgICByZXF1aXJlZElubGluZSArXHJcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXAtYWRkb25cIiBuZy1pZj1cIiEhY29tcG9uZW50LnN1ZmZpeFwiPnt7IGNvbXBvbmVudC5zdWZmaXggfX08L2Rpdj4nICtcclxuICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZm9ybWlvLWVycm9yc1wiPicgK1xyXG4gICAgICAgICAgICAnPGZvcm1pby1lcnJvcnMgbmctaWY9XCI6OiFidWlsZGVyXCI+PC9mb3JtaW8tZXJyb3JzPicgK1xyXG4gICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAnPGRpdiBuZy1pZj1cIiEhY29tcG9uZW50LmRlc2NyaXB0aW9uXCIgY2xhc3M9XCJoZWxwLWJsb2NrXCI+JyArXHJcbiAgICAgICAgICAnPHNwYW4+e3sgY29tcG9uZW50LmRlc2NyaXB0aW9uIH19PC9zcGFuPicgK1xyXG4gICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAnPGRpdiBuZy1pZj1cImNvbXBvbmVudC5tdWx0aXBsZVwiPjx0YWJsZSBjbGFzcz1cInRhYmxlIHRhYmxlLWJvcmRlcmVkXCI+JyArXHJcbiAgICAgICAgICBpbnB1dExhYmVsICtcclxuICAgICAgICAgICc8dHIgbmctcmVwZWF0PVwidmFsdWUgaW4gZGF0YVtjb21wb25lbnQua2V5XSB0cmFjayBieSAkaW5kZXhcIj4nICtcclxuICAgICAgICAgICAgJzx0ZD4nICtcclxuICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwXCI+JyArXHJcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwLWFkZG9uXCIgbmctaWY9XCIhIWNvbXBvbmVudC5wcmVmaXhcIj57eyBjb21wb25lbnQucHJlZml4IH19PC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAgIG11bHRpSW5wdXQgK1xyXG4gICAgICAgICAgICAgICAgICByZXF1aXJlZElubGluZSArXHJcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwLWFkZG9uXCIgbmctaWY9XCIhIWNvbXBvbmVudC5zdWZmaXhcIj57eyBjb21wb25lbnQuc3VmZml4IH19PC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZm9ybWlvLWVycm9yc1wiPicgK1xyXG4gICAgICAgICAgICAgICAgJzxmb3JtaW8tZXJyb3JzIG5nLWlmPVwiOjohYnVpbGRlclwiPjwvZm9ybWlvLWVycm9ycz4nICtcclxuICAgICAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAgICc8L3RkPicgK1xyXG4gICAgICAgICAgICAnPHRkPjxhIG5nLWNsaWNrPVwicmVtb3ZlRmllbGRWYWx1ZSgkaW5kZXgpXCIgY2xhc3M9XCJidG4gYnRuLWRlZmF1bHRcIj48c3BhbiBjbGFzcz1cImdseXBoaWNvbiBnbHlwaGljb24tcmVtb3ZlLWNpcmNsZVwiPjwvc3Bhbj48L2E+PC90ZD4nICtcclxuICAgICAgICAgICc8L3RyPicgK1xyXG4gICAgICAgICAgJzx0cj4nICtcclxuICAgICAgICAgICAgJzx0ZCBjb2xzcGFuPVwiMlwiPjxhIG5nLWNsaWNrPVwiYWRkRmllbGRWYWx1ZSgpXCIgY2xhc3M9XCJidG4gYnRuLXByaW1hcnlcIj48c3BhbiBjbGFzcz1cImdseXBoaWNvbiBnbHlwaGljb24tcGx1c1wiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvc3Bhbj4ge3sgY29tcG9uZW50LmFkZEFub3RoZXIgfHwgXCJBZGQgQW5vdGhlclwiIHwgZm9ybWlvVHJhbnNsYXRlOm51bGw6YnVpbGRlciB9fTwvYT48L3RkPicgK1xyXG4gICAgICAgICAgJzwvdHI+JyArXHJcbiAgICAgICAgJzwvdGFibGU+PC9kaXY+JztcclxuICAgICAgcmV0dXJuIHRlbXBsYXRlO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGlmIGEgY29tcG9uZW50IGlzIHJlcXVpcmVkXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbXBvbmVudCBUaGUgY29tcG9uZW50IHRvIGJlIGNoZWNrZWRcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvbXBvbmVudHNUb1JlcXVpcmUgQW4gYXJyYXkgb2YgY29tcG9uZW50IGtleXMgbWFudWFsbHkgc2V0IHRvIG1hcmsgc3BlY2lmaWMgY29tcG9uZW50cyBhcyByZXF1aXJlZFxyXG4gICAgICovXHJcbiAgICBpc1JlcXVpcmVkOiBmdW5jdGlvbihjb21wb25lbnQsIGNvbXBvbmVudHNUb1JlcXVpcmUpIHtcclxuICAgICAgcmV0dXJuIChjb21wb25lbnQudmFsaWRhdGUgJiYgY29tcG9uZW50LnZhbGlkYXRlLnJlcXVpcmVkKSB8fCAoQXJyYXkuaXNBcnJheShjb21wb25lbnRzVG9SZXF1aXJlKSAmJiBjb21wb25lbnRzVG9SZXF1aXJlLmluZGV4T2YoY29tcG9uZW50LmtleSkgIT09IC0xKTtcclxuICAgIH1cclxuICB9O1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XHJcbiAgdmFyIGdlbmVyaWMgPSBmdW5jdGlvbihkYXRhLCBjb21wb25lbnQpIHtcclxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9XHJcbiAgICB2YXIgc3RhcnRUYWJsZSA9IGZ1bmN0aW9uKGxhYmVscykge1xyXG4gICAgICBpZiAoIShsYWJlbHMgaW5zdGFuY2VvZiBBcnJheSkpIHtcclxuICAgICAgICBsYWJlbHMgPSBbbGFiZWxzXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHZpZXcgPSAnPHRhYmxlIGNsYXNzPVwidGFibGUgdGFibGUtc3RyaXBlZCB0YWJsZS1ib3JkZXJlZFwiPjx0aGVhZD48dHI+JztcclxuXHJcbiAgICAgIGxhYmVscy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcclxuICAgICAgICB2aWV3ICs9ICc8dGg+JyArIGl0ZW0gKyAnPC90aD4nO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHZpZXcgKz0gJzwvdHI+PC90aGVhZD4nO1xyXG4gICAgICB2aWV3ICs9ICc8dGJvZHk+JztcclxuICAgICAgcmV0dXJuIHZpZXc7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBmaW5pc2hUYWJsZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gJzwvdGJvZHk+PC90YWJsZT4nO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgbWFrZVJvdyA9IGZ1bmN0aW9uKGRhdGEsIG5vUm93KSB7XHJcbiAgICAgIHZhciB2aWV3ID0gIW5vUm93ID8gJzx0cj4nIDogJyc7XHJcblxyXG4gICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHZpZXcgKz0gJzx0ZD4nICsgZGF0YSArICc8L3RkPic7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB2aWV3ICs9ICc8dGQ+PC90ZD4nO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICB2aWV3ICs9IG1ha2VSb3coaXRlbSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmIGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdmFyIGxhYmVscyA9IE9iamVjdC5rZXlzKGRhdGEpO1xyXG5cclxuICAgICAgICB2aWV3ICs9ICc8dGQ+JyArIHN0YXJ0VGFibGUobGFiZWxzKTtcclxuICAgICAgICBsYWJlbHMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgIHZpZXcgKz0gbWFrZVJvdyhkYXRhW2tleV0sIHRydWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZpZXcgKz0gZmluaXNoVGFibGUoKSArICc8L3RkPic7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZpZXcgKz0gIW5vUm93ID8gJzwvdHI+JyA6ICcnO1xyXG4gICAgICByZXR1cm4gdmlldztcclxuICAgIH07XHJcblxyXG4gICAgLy8gQ3JlYXRlIGEgdGVtcGxhdGVcclxuICAgIHZhciB2aWV3ID0gJyc7XHJcbiAgICB2YXIgbGFiZWw7XHJcbiAgICBpZiAoIWxhYmVsICYmIGNvbXBvbmVudCAmJiBjb21wb25lbnQubGFiZWwpIHtcclxuICAgICAgbGFiZWwgPSBjb21wb25lbnQubGFiZWw7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICghbGFiZWwgJiYgY29tcG9uZW50ICYmIGNvbXBvbmVudC5rZXkpIHtcclxuICAgICAgbGFiZWwgPSBjb21wb25lbnQua2V5O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIGxhYmVsID0gJyc7XHJcbiAgICB9XHJcblxyXG4gICAgdmlldyArPSBzdGFydFRhYmxlKGxhYmVsKTtcclxuICAgIHZpZXcgKz0gbWFrZVJvdyhkYXRhKTtcclxuICAgIHZpZXcgKz0gZmluaXNoVGFibGUoKTtcclxuICAgIHJldHVybiB2aWV3O1xyXG4gIH07XHJcblxyXG4gIC8vIEdlbmVyYXRlIGEgY29sdW1uIGZvciB0aGUgY29tcG9uZW50LlxyXG4gIHZhciBjb2x1bW5Gb3JDb21wb25lbnQgPSBmdW5jdGlvbihkYXRhLCBjb21wb25lbnQsICRpbnRlcnBvbGF0ZSwgY29tcG9uZW50SW5mbywgdGFibGVDaGlsZCkge1xyXG4gICAgLy8gSWYgbm8gY29tcG9uZW50IGlzIGdpdmVuLCBnZW5lcmF0ZSBhbiBlbXB0eSBjZWxsLlxyXG4gICAgaWYgKCFjb21wb25lbnQpIHtcclxuICAgICAgcmV0dXJuICc8dGQ+PC90ZD4nO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEdlbmVyYXRlIGEgdGFibGUgZm9yIGVhY2ggY29tcG9uZW50IHdpdGggb25lIGNvbHVtbiB0byBkaXNwbGF5IHRoZSBrZXkvdmFsdWUgZm9yIGVhY2ggY29tcG9uZW50LlxyXG4gICAgdmFyIHZpZXcgPSAnPHRkPic7XHJcbiAgICB2aWV3ICs9ICc8dGFibGUgY2xhc3M9XCJ0YWJsZSB0YWJsZS1zdHJpcGVkIHRhYmxlLWJvcmRlcmVkJyArICh0YWJsZUNoaWxkID8gJyB0YWJsZS1jaGlsZCcgOiAnJykgKyAnXCI+JztcclxuICAgIHZpZXcgKz0gJzx0aGVhZD48dHI+JztcclxuICAgIHZpZXcgKz0gJzx0aD4nICsgKGNvbXBvbmVudC5sYWJlbCB8fCAnJykgKyAnICgnICsgY29tcG9uZW50LmtleSArICcpPC90aD4nO1xyXG4gICAgdmlldyArPSAnPC90cj48L3RoZWFkPic7XHJcbiAgICB2aWV3ICs9ICc8dGJvZHk+JztcclxuXHJcbiAgICAvLyBJZiB0aGUgY29tcG9uZW50IGhhcyBhIGRlZmluZWQgdGFibGVWaWV3LCB1c2UgdGhhdCwgb3RoZXJ3aXNlIHRyeSBhbmQgdXNlIHRoZSByYXcgZGF0YSBhcyBhIHN0cmluZy5cclxuICAgIHZhciBpbmZvID0gY29tcG9uZW50SW5mby5jb21wb25lbnRzLmhhc093blByb3BlcnR5KGNvbXBvbmVudC50eXBlKVxyXG4gICAgICA/IGNvbXBvbmVudEluZm8uY29tcG9uZW50c1tjb21wb25lbnQudHlwZV1cclxuICAgICAgOiB7fTtcclxuICAgIGlmIChpbmZvLnRhYmxlVmlldykge1xyXG4gICAgICB2aWV3ICs9ICc8dGQ+JyArXHJcbiAgICAgICAgaW5mby50YWJsZVZpZXcoXHJcbiAgICAgICAgICBkYXRhICYmIGNvbXBvbmVudC5rZXkgJiYgKGRhdGEuaGFzT3duUHJvcGVydHkoY29tcG9uZW50LmtleSkgPyBkYXRhW2NvbXBvbmVudC5rZXldIDogZGF0YSksXHJcbiAgICAgICAgICBjb21wb25lbnQsXHJcbiAgICAgICAgICAkaW50ZXJwb2xhdGUsXHJcbiAgICAgICAgICBjb21wb25lbnRJbmZvLFxyXG4gICAgICAgICAgdGFibGVDaGlsZFxyXG4gICAgICAgICkgKyAnPC90ZD4nO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIHZpZXcgKz0gJzx0ZD4nO1xyXG4gICAgICBpZiAoY29tcG9uZW50LnByZWZpeCkge1xyXG4gICAgICAgIHZpZXcgKz0gY29tcG9uZW50LnByZWZpeDtcclxuICAgICAgfVxyXG4gICAgICB2aWV3ICs9IGRhdGEgJiYgY29tcG9uZW50LmtleSAmJiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShjb21wb25lbnQua2V5KSA/IGRhdGFbY29tcG9uZW50LmtleV0gOiAnJyk7XHJcbiAgICAgIGlmIChjb21wb25lbnQuc3VmZml4KSB7XHJcbiAgICAgICAgdmlldyArPSAnICcgKyBjb21wb25lbnQuc3VmZml4O1xyXG4gICAgICB9XHJcbiAgICAgIHZpZXcgKz0gJzwvdGQ+JztcclxuICAgIH1cclxuXHJcbiAgICB2aWV3ICs9ICc8L3Rib2R5PjwvdGFibGU+JztcclxuICAgIHZpZXcgKz0gJzwvdGQ+JztcclxuICAgIHJldHVybiB2aWV3O1xyXG4gIH07XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBnZW5lcmljOiBnZW5lcmljLFxyXG4gICAgY29sdW1uRm9yQ29tcG9uZW50OiBjb2x1bW5Gb3JDb21wb25lbnRcclxuICB9O1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gW1xyXG4gICckcScsXHJcbiAgJyRyb290U2NvcGUnLFxyXG4gICdGb3JtaW8nLFxyXG4gIGZ1bmN0aW9uKCRxLCAkcm9vdFNjb3BlLCBGb3JtaW8pIHtcclxuICAgIHZhciBJbnRlcmNlcHRvciA9IHtcclxuICAgICAgLyoqXHJcbiAgICAgICAqIFVwZGF0ZSBKV1QgdG9rZW4gcmVjZWl2ZWQgZnJvbSByZXNwb25zZS5cclxuICAgICAgICovXHJcbiAgICAgIHJlc3BvbnNlOiBmdW5jdGlvbihyZXNwb25zZSkge1xyXG4gICAgICAgIHZhciB0b2tlbiA9IHJlc3BvbnNlLmhlYWRlcnMoJ3gtand0LXRva2VuJyk7XHJcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA+PSAyMDAgJiYgcmVzcG9uc2Uuc3RhdHVzIDwgMzAwICYmIHRva2VuICYmIHRva2VuICE9PSAnJykge1xyXG4gICAgICAgICAgRm9ybWlvLnNldFRva2VuKHRva2VuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEludGVyY2VwdCBhIHJlc3BvbnNlIGVycm9yLlxyXG4gICAgICAgKi9cclxuICAgICAgcmVzcG9uc2VFcnJvcjogZnVuY3Rpb24ocmVzcG9uc2UpIHtcclxuICAgICAgICBpZiAocGFyc2VJbnQocmVzcG9uc2Uuc3RhdHVzLCAxMCkgPT09IDQ0MCkge1xyXG4gICAgICAgICAgcmVzcG9uc2UubG9nZ2VkT3V0ID0gdHJ1ZTtcclxuICAgICAgICAgIEZvcm1pby5zZXRUb2tlbihudWxsKTtcclxuICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnZm9ybWlvLnNlc3Npb25FeHBpcmVkJywgcmVzcG9uc2UuYm9keSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBhcnNlSW50KHJlc3BvbnNlLnN0YXR1cywgMTApID09PSA0MDEpIHtcclxuICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnZm9ybWlvLnVuYXV0aG9yaXplZCcsIHJlc3BvbnNlLmJvZHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJHEucmVqZWN0KHJlc3BvbnNlKTtcclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBTZXQgdGhlIHRva2VuIGluIHRoZSByZXF1ZXN0IGhlYWRlcnMuXHJcbiAgICAgICAqL1xyXG4gICAgICByZXF1ZXN0OiBmdW5jdGlvbihjb25maWcpIHtcclxuICAgICAgICBpZiAoY29uZmlnLmRpc2FibGVKV1QpIHJldHVybiBjb25maWc7XHJcbiAgICAgICAgdmFyIHRva2VuID0gRm9ybWlvLmdldFRva2VuKCk7XHJcbiAgICAgICAgaWYgKHRva2VuKSBjb25maWcuaGVhZGVyc1sneC1qd3QtdG9rZW4nXSA9IHRva2VuO1xyXG4gICAgICAgIHJldHVybiBjb25maWc7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIEludGVyY2VwdG9yO1xyXG4gIH1cclxuXTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFtcclxuICAnRm9ybWlvJyxcclxuICAnZm9ybWlvQ29tcG9uZW50cycsXHJcbiAgJyRpbnRlcnBvbGF0ZScsXHJcbiAgZnVuY3Rpb24oXHJcbiAgICBGb3JtaW8sXHJcbiAgICBmb3JtaW9Db21wb25lbnRzLFxyXG4gICAgJGludGVycG9sYXRlXHJcbiAgKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGNvbXBvbmVudCkge1xyXG4gICAgICBpZiAoIXZhbHVlICYmIHZhbHVlICE9PSAwICYmIHZhbHVlICE9PSBmYWxzZSkge1xyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgICAgfVxyXG4gICAgICBpZiAoIWNvbXBvbmVudCB8fCAhY29tcG9uZW50LmlucHV0fHwgIWNvbXBvbmVudC50eXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBjb21wb25lbnRJbmZvID0gZm9ybWlvQ29tcG9uZW50cy5jb21wb25lbnRzW2NvbXBvbmVudC50eXBlXTtcclxuICAgICAgaWYgKCFjb21wb25lbnRJbmZvLnRhYmxlVmlldykge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoY29tcG9uZW50Lm11bHRpcGxlICYmICh2YWx1ZS5sZW5ndGggPiAwKSkge1xyXG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcclxuICAgICAgICBhbmd1bGFyLmZvckVhY2godmFsdWUsIGZ1bmN0aW9uKGFycmF5VmFsdWUpIHtcclxuICAgICAgICAgIHZhbHVlcy5wdXNoKGNvbXBvbmVudEluZm8udGFibGVWaWV3KGFycmF5VmFsdWUsIGNvbXBvbmVudCwgJGludGVycG9sYXRlLCBmb3JtaW9Db21wb25lbnRzKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gY29tcG9uZW50SW5mby50YWJsZVZpZXcodmFsdWUsIGNvbXBvbmVudCwgJGludGVycG9sYXRlLCBmb3JtaW9Db21wb25lbnRzKTtcclxuICAgIH07XHJcbiAgfVxyXG5dO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gW1xyXG4gICdGb3JtaW9VdGlscycsXHJcbiAgZnVuY3Rpb24oRm9ybWlvVXRpbHMpIHtcclxuICAgIHJldHVybiBGb3JtaW9VdGlscy5mbGF0dGVuQ29tcG9uZW50cztcclxuICB9XHJcbl07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBbXHJcbiAgJyRzY2UnLFxyXG4gIGZ1bmN0aW9uKFxyXG4gICAgJHNjZVxyXG4gICkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGh0bWwpIHtcclxuICAgICAgcmV0dXJuICRzY2UudHJ1c3RBc0h0bWwoaHRtbCk7XHJcbiAgICB9O1xyXG4gIH1cclxuXTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFtcclxuICBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbihjb21wb25lbnRzKSB7XHJcbiAgICAgIHZhciB0YWJsZUNvbXBzID0gW107XHJcbiAgICAgIGlmICghY29tcG9uZW50cyB8fCAhY29tcG9uZW50cy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gdGFibGVDb21wcztcclxuICAgICAgfVxyXG4gICAgICBjb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24oY29tcG9uZW50KSB7XHJcbiAgICAgICAgaWYgKGNvbXBvbmVudC50YWJsZVZpZXcpIHtcclxuICAgICAgICAgIHRhYmxlQ29tcHMucHVzaChjb21wb25lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiB0YWJsZUNvbXBzO1xyXG4gICAgfTtcclxuICB9XHJcbl07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBbXHJcbiAgJ2Zvcm1pb1RhYmxlVmlldycsXHJcbiAgZnVuY3Rpb24oXHJcbiAgICBmb3JtaW9UYWJsZVZpZXdcclxuICApIHtcclxuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgY29tcG9uZW50KSB7XHJcbiAgICAgIHJldHVybiBmb3JtaW9UYWJsZVZpZXcodmFsdWUsIGNvbXBvbmVudCk7XHJcbiAgICB9O1xyXG4gIH1cclxuXTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFtcclxuICAnRm9ybWlvJyxcclxuICAnZm9ybWlvVGFibGVWaWV3JyxcclxuICBmdW5jdGlvbihcclxuICAgIEZvcm1pbyxcclxuICAgIGZvcm1pb1RhYmxlVmlld1xyXG4gICkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGEsIGNvbXBvbmVudCkge1xyXG4gICAgICByZXR1cm4gZm9ybWlvVGFibGVWaWV3KEZvcm1pby5maWVsZERhdGEoZGF0YSwgY29tcG9uZW50KSwgY29tcG9uZW50KTtcclxuICAgIH07XHJcbiAgfVxyXG5dO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gW1xyXG4gICckZmlsdGVyJyxcclxuICAnJGluamVjdG9yJyxcclxuICBmdW5jdGlvbihcclxuICAgICRmaWx0ZXIsXHJcbiAgICAkaW5qZWN0b3JcclxuICApIHtcclxuICAgIHJldHVybiBmdW5jdGlvbih0ZXh0LCBrZXksIGJ1aWxkZXIpIHtcclxuICAgICAgLyoqXHJcbiAgICAgICAqIExvb2t1cCB0aGUgYXZhaWxhYmxlIHRyYW5zbGF0ZSBsaWJyYXJpZXMsIGN1cnJlbnRseSBzdXBwb3J0czpcclxuICAgICAgICogYW5ndWxhci10cmFuc2xhdGU6IEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXItdHJhbnNsYXRlL2FuZ3VsYXItdHJhbnNsYXRlXHJcbiAgICAgICAqIGFuZ3VsYXItZ2V0dGV4dDogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcnViZW52L2FuZ3VsYXItZ2V0dGV4dFxyXG4gICAgICAgKi9cclxuICAgICAgdmFyICR0cmFuc2xhdGUsIGdldHRleHRDYXRhbG9nO1xyXG4gICAgICBpZiAoJGluamVjdG9yLmhhcygnJHRyYW5zbGF0ZScpKSB7XHJcbiAgICAgICAgJHRyYW5zbGF0ZSA9ICRpbmplY3Rvci5nZXQoJyR0cmFuc2xhdGUnKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmICgkaW5qZWN0b3IuaGFzKCdnZXR0ZXh0Q2F0YWxvZycpKSB7XHJcbiAgICAgICAgZ2V0dGV4dENhdGFsb2cgPSAkaW5qZWN0b3IuZ2V0KCdnZXR0ZXh0Q2F0YWxvZycpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChidWlsZGVyKSByZXR1cm4gdGV4dDtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBUcmFuc2xhdGUgdGV4dCB1c2luZyBlaXRoZXIgYW5ndWxhci10cmFuc2xhdGUgb3IgYW5ndWxhci1nZXR0ZXh0XHJcbiAgICAgICAgdmFyIHRyYW5zbGF0ZVRleHQgPSBmdW5jdGlvbih0ZXh0KSB7XHJcbiAgICAgICAgICBpZiAoJHRyYW5zbGF0ZSkgcmV0dXJuICR0cmFuc2xhdGUuaW5zdGFudCh0ZXh0KTtcclxuICAgICAgICAgIGlmIChnZXR0ZXh0Q2F0YWxvZykgcmV0dXJuIGdldHRleHRDYXRhbG9nLmdldFN0cmluZyh0ZXh0KTtcclxuICAgICAgICAgIHJldHVybiB0ZXh0O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIEFsbG93IHRyYW5zbGF0aW5nIGJ5IGZpZWxkIGtleSB3aGljaCBoZWxwcyB3aXRoIGxhcmdlIGJsb2NrcyBvZiBodG1sLlxyXG4gICAgICAgIGlmIChrZXkpIHtcclxuICAgICAgICAgIHZhciByZXN1bHQgPSB0cmFuc2xhdGVUZXh0KGtleSk7XHJcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSBrZXkpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gdHJhbnNsYXRlVGV4dCh0ZXh0KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJhbnNsYXRlVGV4dCh0ZXh0KTtcclxuICAgICAgfVxyXG4gICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIHJldHVybiB0ZXh0O1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuXTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFsnJHNjZScsIGZ1bmN0aW9uKCRzY2UpIHtcclxuICByZXR1cm4gZnVuY3Rpb24odmFsKSB7XHJcbiAgICByZXR1cm4gJHNjZS50cnVzdEFzUmVzb3VyY2VVcmwodmFsKTtcclxuICB9O1xyXG59XTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4ndXNlIHN0cmljdCc7XHJcblxyXG5pZiAodHlwZW9mIE9iamVjdC5hc3NpZ24gIT0gJ2Z1bmN0aW9uJykge1xyXG4gIChmdW5jdGlvbigpIHtcclxuICAgIE9iamVjdC5hc3NpZ24gPSBmdW5jdGlvbih0YXJnZXQpIHtcclxuICAgICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgICAvLyBXZSBtdXN0IGNoZWNrIGFnYWluc3QgdGhlc2Ugc3BlY2lmaWMgY2FzZXMuXHJcbiAgICAgIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCB8fCB0YXJnZXQgPT09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIG91dHB1dCA9IE9iamVjdCh0YXJnZXQpO1xyXG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtZGVwdGggKi9cclxuICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XTtcclxuICAgICAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQgJiYgc291cmNlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICBmb3IgKHZhciBuZXh0S2V5IGluIHNvdXJjZSkge1xyXG4gICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KG5leHRLZXkpKSB7XHJcbiAgICAgICAgICAgICAgb3V0cHV0W25leHRLZXldID0gc291cmNlW25leHRLZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWRlcHRoICovXHJcbiAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICB9O1xyXG4gIH0pKCk7XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4ndXNlIHN0cmljdCc7XHJcblxyXG5yZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xyXG4gIC8vIFRoZSBmb3JtaW8gY2xhc3MuXHJcbiAgdmFyIEZvcm1pbyA9IHJlcXVpcmUoJ2Zvcm1pb2pzJyk7XHJcblxyXG4gIC8vIFJldHVybiB0aGUgcHJvdmlkZXIgaW50ZXJmYWNlLlxyXG4gIHJldHVybiB7XHJcblxyXG4gICAgLy8gRXhwb3NlIEZvcm1pbyBjb25maWd1cmF0aW9uIGZ1bmN0aW9uc1xyXG4gICAgc2V0QmFzZVVybDogRm9ybWlvLnNldEJhc2VVcmwsXHJcbiAgICBnZXRCYXNlVXJsOiBGb3JtaW8uZ2V0QmFzZVVybCxcclxuICAgIHNldEFwaVVybDogRm9ybWlvLnNldEJhc2VVcmwsXHJcbiAgICBnZXRBcGlVcmw6IEZvcm1pby5nZXRCYXNlVXJsLFxyXG4gICAgc2V0QXBwVXJsOiBGb3JtaW8uc2V0QXBwVXJsLFxyXG4gICAgc2V0UHJvamVjdFVybDogRm9ybWlvLnNldFByb2plY3RVcmwsXHJcbiAgICBnZXRBcHBVcmw6IEZvcm1pby5nZXRBcHBVcmwsXHJcbiAgICBnZXRQcm9qZWN0VXJsOiBGb3JtaW8uZ2V0UHJvamVjdFVybCxcclxuICAgIHJlZ2lzdGVyUGx1Z2luOiBGb3JtaW8ucmVnaXN0ZXJQbHVnaW4sXHJcbiAgICBnZXRQbHVnaW46IEZvcm1pby5nZXRQbHVnaW4sXHJcbiAgICBwcm92aWRlcnM6IEZvcm1pby5wcm92aWRlcnMsXHJcbiAgICBzZXREb21haW46IGZ1bmN0aW9uKCkge1xyXG4gICAgICAvLyBSZW1vdmUgdGhpcz9cclxuICAgIH0sXHJcblxyXG4gICAgJGdldDogW1xyXG4gICAgICAnJHJvb3RTY29wZScsXHJcbiAgICAgICckcScsXHJcbiAgICAgIGZ1bmN0aW9uKFxyXG4gICAgICAgICRyb290U2NvcGUsXHJcbiAgICAgICAgJHFcclxuICAgICAgKSB7XHJcbiAgICAgICAgdmFyIHdyYXBRUHJvbWlzZSA9IGZ1bmN0aW9uKHByb21pc2UpIHtcclxuICAgICAgICAgIHJldHVybiAkcS53aGVuKHByb21pc2UpXHJcbiAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcclxuICAgICAgICAgICAgaWYgKGVycm9yID09PSAnVW5hdXRob3JpemVkJykge1xyXG4gICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnZm9ybWlvLnVuYXV0aG9yaXplZCcsIGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChlcnJvciA9PT0gJ0xvZ2luIFRpbWVvdXQnKSB7XHJcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdmb3JtaW8uc2Vzc2lvbkV4cGlyZWQnLCBlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUHJvcGFnYXRlIGVycm9yXHJcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgRm9ybWlvLnJlZ2lzdGVyUGx1Z2luKHtcclxuICAgICAgICAgIHByaW9yaXR5OiAtMTAwLFxyXG4gICAgICAgICAgLy8gV3JhcCBGb3JtaW8ucmVxdWVzdCdzIHByb21pc2VzIHdpdGggJHEgc28gJGFwcGx5IGdldHMgY2FsbGVkIGNvcnJlY3RseS5cclxuICAgICAgICAgIHdyYXBSZXF1ZXN0UHJvbWlzZTogd3JhcFFQcm9taXNlLFxyXG4gICAgICAgICAgd3JhcFN0YXRpY1JlcXVlc3RQcm9taXNlOiB3cmFwUVByb21pc2VcclxuICAgICAgICB9LCAnbmdGb3JtaW9Qcm9taXNlV3JhcHBlcicpO1xyXG5cclxuICAgICAgICAvLyBCcm9hZGNhc3Qgb2ZmbGluZSBldmVudHMgZnJvbSAkcm9vdFNjb3BlXHJcbiAgICAgICAgRm9ybWlvLmV2ZW50cy5vbkFueShmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHZhciBldmVudCA9ICdmb3JtaW8uJyArIHRoaXMuZXZlbnQ7XHJcbiAgICAgICAgICB2YXIgYXJncyA9IFtdLnNwbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XHJcbiAgICAgICAgICBhcmdzLnVuc2hpZnQoZXZlbnQpO1xyXG4gICAgICAgICAgJHJvb3RTY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdC5hcHBseSgkcm9vdFNjb3BlLCBhcmdzKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4gdGhlIGZvcm1pbyBpbnRlcmZhY2UuXHJcbiAgICAgICAgcmV0dXJuIEZvcm1pbztcclxuICAgICAgfVxyXG4gICAgXVxyXG4gIH07XHJcbn07XHJcbiJdfQ==